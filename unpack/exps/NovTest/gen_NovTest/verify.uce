
/** BEGIN_INPUT_DEFINITION *********************************************
 *
 * All specifications as seen by the parser.
 *
 * Do not edit - automatically generated.
 */

/**********************************************************
 * Dump of all structures:
 */

BARRIER()
{
  UINT32 barrier NOENCODE
  {
     0_19: no;
    20_31: ba = RANGE(0xf52,0xf58);
  }
}

external EXT_AIDA()
;

FEBEX_EVENT(card)
{
  MEMBER(DATA32 event_trigger_time_hi);
  MEMBER(DATA32 event_trigger_time_lo);
  MEMBER(DATA16 hit_pattern);
  MEMBER(DATA16 channel_trigger_time_hi[16] ZERO_SUPPRESS);
  MEMBER(DATA32 channel_trigger_time_lo[16] ZERO_SUPPRESS);
  MEMBER(DATA8 pileup[16] ZERO_SUPPRESS);
  MEMBER(DATA8 overflow[16] ZERO_SUPPRESS);
  MEMBER(DATA8 channel_cfd[16] ZERO_SUPPRESS);
  MEMBER(DATA32 channel_energy[16] ZERO_SUPPRESS);
  UINT32 sumchannel NOENCODE
  {
     0_07: 52;
     8_11: trigger_type;
    12_15: sfpnr;
    16_23: card = MATCH(card);
    24_31: 255;
  }
  UINT32 channel_size NOENCODE
  {
     0_01: ignore;
     2_31: size;
  }
  UINT32 event_timestamp_hi NOENCODE
  {
     0_15: timestamp_hi;
    16_31: ignore;
    ENCODE(event_trigger_time_hi,(value=timestamp_hi));
  }
  UINT32 event_timestamp_lo NOENCODE
  {
     0_31: timestamp_lo;
    ENCODE(event_trigger_time_lo,(value=timestamp_lo));
  }
  UINT32 hp NOENCODE
  {
     0_15: hp;
    16_31: ignore;
    ENCODE(hit_pattern,(value=hp));
  }
  UINT32 deadbeef NOENCODE
  {
     0_31: 0xdeadbeef;
  }
  list(0<=index<((channel_size.size / 4) - 1))
  {
    UINT32 channelids NOENCODE
    {
       0_15: chan_ts_hi;
      16_23: channel_id_bits;
      24_31: 240;
      ENCODE(channel_trigger_time_hi[channelids.channel_id_bits],(value=chan_ts_hi));
    }
    UINT32 channel_ts NOENCODE
    {
       0_31: chan_ts_lo;
      ENCODE(channel_trigger_time_lo[channelids.channel_id_bits],(value=chan_ts_lo));
    }
    UINT32 chan_enrgy NOENCODE
    {
       0_23: chan_energy;
      24_29: TSF;
         30: pileup_flag;
         31: overflow_flag;
      ENCODE(channel_cfd[channelids.channel_id_bits],(value=TSF));
      ENCODE(channel_energy[channelids.channel_id_bits],(value=chan_energy));
      ENCODE(pileup[channelids.channel_id_bits],(value=pileup_flag));
      ENCODE(overflow[channelids.channel_id_bits],(value=overflow_flag));
    }
    UINT32 future_use NOENCODE
    {
       0_31: 0;
    }
  }
}

FEBEX_EVENT_TRACES(card)
{
  MEMBER(DATA32 event_trigger_time_hi);
  MEMBER(DATA32 event_trigger_time_lo);
  MEMBER(DATA16 hit_pattern);
  MEMBER(DATA32 num_channels_fired);
  MEMBER(DATA8 channel_id[16] ZERO_SUPPRESS);
  MEMBER(DATA16 channel_trigger_time_hi[16] ZERO_SUPPRESS);
  MEMBER(DATA32 channel_trigger_time_lo[16] ZERO_SUPPRESS);
  MEMBER(DATA8 pileup[16]);
  MEMBER(DATA8 overflow[16]);
  MEMBER(DATA8 channel_cfd[16] ZERO_SUPPRESS);
  MEMBER(DATA32 channel_energy[16] ZERO_SUPPRESS);
  MEMBER(DATA16 traces[16][10000] ZERO_SUPPRESS);
  UINT32 sumchannel NOENCODE
  {
     0_07: 52;
     8_11: trigger_type;
    12_15: sfpnr;
    16_23: board_id = MATCH(card);
    24_31: 255;
  }
  UINT32 channel_size NOENCODE
  {
     0_01: ignore;
     2_31: size;
    ENCODE(num_channels_fired,(value=((size / 4) - 1)));
  }
  UINT32 event_timestamp_hi NOENCODE
  {
     0_15: timestamp_hi;
    16_31: ignore;
    ENCODE(event_trigger_time_hi,(value=timestamp_hi));
  }
  UINT32 event_timestamp_lo NOENCODE
  {
     0_31: timestamp_lo;
    ENCODE(event_trigger_time_lo,(value=timestamp_lo));
  }
  UINT32 hp NOENCODE
  {
     0_15: hp;
    16_31: ignore;
    ENCODE(hit_pattern,(value=hp));
  }
  UINT32 deadbeef NOENCODE
  {
     0_31: 0xdeadbeef;
  }
  if((sumchannel.trigger_type == 1))
  {
    list(0<=index<((channel_size.size / 4) - 1))
    {
      UINT32 channelids NOENCODE
      {
         0_15: chan_ts_hi;
        16_23: channel_id_bits;
        24_31: 240;
        ENCODE(channel_id[index],(value=channel_id_bits));
        ENCODE(channel_trigger_time_hi[index],(value=chan_ts_hi));
      }
      UINT32 channel_ts NOENCODE
      {
         0_31: chan_ts_lo;
        ENCODE(channel_trigger_time_lo[index],(value=chan_ts_lo));
      }
      UINT32 chan_enrgy NOENCODE
      {
         0_23: chan_energy;
        24_29: TSF;
           30: pileup_flag;
           31: overflow_flag;
        ENCODE(channel_cfd[index],(value=TSF));
        ENCODE(channel_energy[index],(value=chan_energy));
        ENCODE(pileup[index],(value=pileup_flag));
        ENCODE(overflow[index],(value=overflow_flag));
      }
      UINT32 future_use NOENCODE
      {
         0_31: 0;
      }
    }
    list(0<=i<16)
    {
      UINT32 header NOENCODE
      {
         0_07: 52;
         8_23: other;
        24_31: ch_id;
      }
      UINT32 tracesize NOENCODE
      {
         0_31: size;
      }
      UINT32 tracehead NOENCODE
      {
         0_23: other;
        24_31: head;
      }
      list(0<=j<((tracesize.size / 4) - 2))
      {
        UINT32 channel_trace NOENCODE
        {
           0_13: data1;
          14_15: stuff1;
          16_29: data2;
          30_31: stuff2;
          ENCODE(traces[header.ch_id][((2 * j) + 0)],(value=data1));
          ENCODE(traces[header.ch_id][((2 * j) + 1)],(value=data2));
        }
      }
      UINT32 trace_trailer NOENCODE
      {
         0_23: notused;
        24_31: id = RANGE(176,191);
      }
    }
  }
  else
  {
    if((sumchannel.trigger_type == 3))
    {
      list(0<=i<16)
      {
        UINT32 header NOENCODE
        {
           0_07: 52;
           8_23: other;
          24_31: ch_id;
        }
        UINT32 tracesize NOENCODE
        {
           0_31: size;
        }
        UINT32 tracehead NOENCODE
        {
           0_23: other;
          24_31: head;
        }
        UINT32 trace_trailer NOENCODE
        {
           0_23: notused;
          24_31: id = RANGE(176,191);
        }
      }
    }
  }
}

FEBEX_PADDING()
{
  UINT32 pads_data NOENCODE
  {
     0_11: counter;
    12_19: index;
    20_31: 0xadd;
  }
}

MAIN_CRATE_DATA()
{
  barrier[0] = BARRIER();
  v830 = VME_CAEN_V830_FRS();
  filler[0] = ZERO_FILLER();
  barrier[1] = BARRIER();
  v792 = VME_CAEN_V792_FRS();
  barrier[2] = BARRIER();
  v1290 = VME_CAEN_V1290_FRS();
}

MESYTEC_MQDC32_FRS()
{
  MEMBER(DATA12_OVERFLOW data[32] ZERO_SUPPRESS);
  UINT32 header NOENCODE
  {
     0_11: word_number;
    12_14: 0;
    16_23: geom;
    24_29: 0;
    30_31: 1;
  }
  several UINT32 ch_data NOENCODE
  {
     0_11: value;
       15: outofrange;
    16_20: channel;
    21_29: 32;
    30_31: 0;
    ENCODE(data[channel],(value=value,overflow=outofrange));
  }
  optional UINT32 zero NOENCODE
  {
     0_31: 0;
  }
  UINT32 end_of_event NOENCODE
  {
     0_29: counter;
    30_31: 3;
  }
}

MESYTEC_MTDC32_FRS()
{
  MEMBER(DATA16 data[34] ZERO_SUPPRESS);
  UINT32 header NOENCODE
  {
     0_11: word_number;
    12_15: tdc_resol;
    16_23: geom;
    24_29: 0;
    30_31: 1;
  }
  list(1<=index<header.word_number)
  {
    optional UINT32 zero NOENCODE
    {
       0_31: ze = MATCH(0);
    }
    if((zero.ze != 0))
    {
      UINT32 ch_data NOENCODE
      {
         0_15: value;
        16_20: channel;
           21: trig;
        22_29: 16;
        30_31: 0;
        ENCODE(data[((trig * 32) + channel)],(value=value));
      }
    }
  }
  UINT32 end_of_event NOENCODE
  {
     0_29: counter;
    30_31: 3;
  }
}

SIS_3820_FRS()
{
  MEMBER(DATA32 data[32] ZERO_SUPPRESS);
  UINT32 custom_header NOENCODE
  {
     0_07: nchs;
     8_21: nevts;
       22: latching;
    23_26: data_format;
    27_31: id;
  }
  list(0<=index<custom_header.nchs)
  {
    if((1 == custom_header.data_format))
    {
      UINT32 event NOENCODE
      {
         0_31: val;
      }
      ENCODE(data[index],(value=event.val));

    }
    if(((0 == custom_header.data_format) || (3 == custom_header.data_format)))
    {
      UINT32 event NOENCODE
      {
         0_23: val;
        24_28: channel;
           29: 0;
        30_31: user_bits;
      }
      ENCODE(data[event.channel],(value=event.val));

    }
  }
}

TAMEX4_EPOCH_DATA(sfp,card,time_coarse,time_fine,time_edge,time_channel,
                  time_epoch)
{
  MEMBER(DATA12 time_coarse[1024] NO_INDEX_LIST);
  MEMBER(DATA12 time_fine[1024] NO_INDEX_LIST);
  MEMBER(DATA12 time_edge[1024] NO_INDEX_LIST);
  MEMBER(DATA12 time_channel[1024] NO_INDEX_LIST);
  MEMBER(DATA32 time_epoch[1024] NO_INDEX_LIST);
  UINT32 data NOENCODE
  {
     0_27: epoch;
    28_31: 6;
    ENCODE(time_coarse APPEND_LIST,(value=0));
    ENCODE(time_fine APPEND_LIST,(value=0));
    ENCODE(time_edge APPEND_LIST,(value=0));
    ENCODE(time_channel APPEND_LIST,(value=0));
    ENCODE(time_epoch APPEND_LIST,(value=epoch));
  }
}

TAMEX4_HEADER()
{
  MEMBER(DATA16 post_trig_ns[64] NO_INDEX_LIST);
  MEMBER(DATA16 pre_trig_ns[64] NO_INDEX_LIST);
  UINT32 trigger_window NOENCODE
  {
     0_15: post_trig_ns;
    16_31: pre_trig_ns;
    ENCODE(post_trig_ns APPEND_LIST,(value=post_trig_ns));
    ENCODE(pre_trig_ns APPEND_LIST,(value=pre_trig_ns));
  }
}

TAMEX4_PADDING()
{
  UINT32 padding NOENCODE
  {
     0_11: counter;
    12_19: index;
    20_31: 0xadd;
  }
}

TAMEX4_SFP(sfp,card)
{
  MEMBER(DATA32 event_size);
  MEMBER(DATA12 time_coarse[1024] NO_INDEX_LIST);
  MEMBER(DATA12 time_fine[1024] NO_INDEX_LIST);
  MEMBER(DATA12 time_edge[1024] NO_INDEX_LIST);
  MEMBER(DATA12 time_channel[1024] NO_INDEX_LIST);
  MEMBER(DATA32 time_epoch[1024] NO_INDEX_LIST);
  UINT32 indicator NOENCODE
  {
     0_07: 52;
     8_11: trigger_type;
    12_15: sfp = MATCH(sfp);
    16_23: card = MATCH(card);
    24_31: 0;
  }
  MATCH_END;
  UINT32 data_size NOENCODE
  {
     0_31: bytes;
    ENCODE(event_size,(value=bytes));
  }
  UINT32 tdc_header NOENCODE
  {
     0_15: lec;
       16: buf_no;
    17_19: reserved;
    20_23: trigger_type;
    24_31: 170;
  }
  list(0<=i<((data_size.bytes / 4) - 3))
  {
    select
    {
      epoch = TAMEX4_EPOCH_DATA(sfp=sfp,card=card,time_coarse=time_coarse,
                                time_fine=time_fine,time_edge=time_edge,
                                time_channel=time_channel,time_epoch=time_epoch);
      time = TAMEX4_TIME_DATA(sfp=sfp,card=card,time_coarse=time_coarse,
                              time_fine=time_fine,time_edge=time_edge,
                              time_channel=time_channel,time_epoch=time_epoch);
    }
  }
  UINT32 error_bits NOENCODE
  {
     0_23: bits;
    24_31: 238;
  }
  UINT32 trailer NOENCODE
  {
     0_15: lec;
       16: buf_no;
    17_19: reserved;
    20_23: trigger_type;
    24_31: 187;
  }
}

TAMEX4_TIME_DATA(sfp,card,time_coarse,time_fine,time_edge,time_channel,
                 time_epoch)
{
  MEMBER(DATA12 time_coarse[1024] NO_INDEX_LIST);
  MEMBER(DATA12 time_fine[1024] NO_INDEX_LIST);
  MEMBER(DATA12 time_edge[1024] NO_INDEX_LIST);
  MEMBER(DATA12 time_channel[1024] NO_INDEX_LIST);
  MEMBER(DATA32 time_epoch[1024] NO_INDEX_LIST);
  UINT32 data NOENCODE
  {
     0_10: coarse;
       11: is_leading;
    12_21: fine;
    22_27: channel;
    28_31: type = CHECK(8);
    ENCODE(time_coarse APPEND_LIST,(value=coarse));
    ENCODE(time_fine APPEND_LIST,(value=fine));
    ENCODE(time_edge APPEND_LIST,(value=is_leading));
    ENCODE(time_channel APPEND_LIST,(value=channel));
    ENCODE(time_epoch APPEND_LIST,(value=0));
  }
}

TDC_DATA_V1190(data,leadOrTrail)
{
  MEMBER(DATA24 data[128] ZERO_SUPPRESS_MULTI(128));
  MEMBER(DATA8 leadOrTrail[128] ZERO_SUPPRESS_MULTI(128));
  UINT32 tdc_data NOENCODE
  {
     0_18: tdc;
    19_25: chn;
       26: lot;
    27_31: 0;
    ENCODE(data[chn],(value=tdc));
    ENCODE(leadOrTrail[chn],(value=lot));
  }
}

TDC_DATA_V1290(data,leadOrTrail)
{
  MEMBER(DATA24 data[128] ZERO_SUPPRESS_MULTI(128));
  MEMBER(DATA8 leadOrTrail[128] ZERO_SUPPRESS_MULTI(128));
  UINT32 tdc_data NOENCODE
  {
     0_20: tdc;
    21_25: chn;
       26: lot;
    27_31: 0;
    ENCODE(data[chn],(value=tdc));
    ENCODE(leadOrTrail[chn],(value=lot));
  }
}

TDC_ERROR()
{
  UINT32 tdc_err NOENCODE
  {
     0_14: error_flags;
    15_23: unused1;
    24_25: tdc;
       26: unused2;
    27_31: 4;
  }
}

TDC_HEADER()
{
  UINT32 tdc_header NOENCODE
  {
     0_11: bunch_id;
    12_23: event_id;
    24_25: tdc;
       26: unused;
    27_31: 1;
  }
}

TDC_TRAILER()
{
  UINT32 tdc_trailer NOENCODE
  {
     0_11: word_count;
    12_23: event_id;
    24_25: tdc;
       26: unused;
    27_31: 3;
  }
}

TIMESTAMP_WHITERABBIT(id)
{
  MEMBER(DATA12 subsystem_id);
  MEMBER(DATA16 t1);
  MEMBER(DATA16 t2);
  MEMBER(DATA16 t3);
  MEMBER(DATA16 t4);
  UINT32 header NOENCODE
  {
     0_11: id = MATCH(id);
    12_15: 0;
       16: error_bit;
    17_31: 0;
    ENCODE(subsystem_id,(value=id));
  }
  UINT32 d1 NOENCODE
  {
     0_15: t1;
    16_31: 0x3e1;
    ENCODE(t1,(value=t1));
  }
  UINT32 d2 NOENCODE
  {
     0_15: t2;
    16_31: 0x4e1;
    ENCODE(t2,(value=t2));
  }
  UINT32 d3 NOENCODE
  {
     0_15: t3;
    16_31: 0x5e1;
    ENCODE(t3,(value=t3));
  }
  UINT32 d4 NOENCODE
  {
     0_15: t4;
    16_31: 0x6e1;
    ENCODE(t4,(value=t4));
  }
}

TIMESTAMP_WHITERABBIT_EXTENDED(id)
{
  MEMBER(DATA16 subsystem_id);
  MEMBER(DATA16 t1);
  MEMBER(DATA16 t2);
  MEMBER(DATA16 t3);
  MEMBER(DATA16 t4);
  UINT32 header NOENCODE
  {
     0_12: id = MATCH(id);
    13_15: 0;
       16: error_bit;
    17_31: 0;
    ENCODE(subsystem_id,(value=id));
  }
  UINT32 d1 NOENCODE
  {
     0_15: t1;
    16_31: 0x3e1;
    ENCODE(t1,(value=t1));
  }
  UINT32 d2 NOENCODE
  {
     0_15: t2;
    16_31: 0x4e1;
    ENCODE(t2,(value=t2));
  }
  UINT32 d3 NOENCODE
  {
     0_15: t3;
    16_31: 0x5e1;
    ENCODE(t3,(value=t3));
  }
  UINT32 d4 NOENCODE
  {
     0_15: t4;
    16_31: 0x6e1;
    ENCODE(t4,(value=t4));
  }
}

TPC_CRATE_DATA()
{
  barrier[0] = BARRIER();
  v775 = VME_CAEN_V7X5_FRS();
  barrier[1] = BARRIER();
  v785 = VME_CAEN_V7X5_FRS();
  barrier[2] = BARRIER();
  v1190 = VME_CAEN_V1190_FRS();
}

TRIG3EVENT()
{
  UINT32 trig3 NOENCODE
  {
     0_31: 0x20202020;
  }
}

USER_CRATE_DATA()
{
  barrier[0] = BARRIER();
  v830 = VME_CAEN_V830_FRS();
  filler[0] = ZERO_FILLER();
  barrier[1] = BARRIER();
  v775[0] = VME_CAEN_V7X5_FRS();
  barrier[2] = BARRIER();
  v775[1] = VME_CAEN_V7X5_FRS();
  barrier[3] = BARRIER();
  v785[0] = VME_CAEN_V7X5_FRS();
  barrier[4] = BARRIER();
  v785[1] = VME_CAEN_V7X5_FRS();
}

VFTX2(id)
{
  MEMBER(DATA12 time_fine[32] ZERO_SUPPRESS_MULTI(100));
  MEMBER(DATA16 time_coarse[32] ZERO_SUPPRESS_MULTI(100));
  MEMBER(DATA16 time_trigger);
  UINT32 custom_header NOENCODE
  {
     0_04: id = MATCH(id);
     5_08: internal_status;
     9_17: count;
    24_31: 171;
  }
  UINT32 trigger_window NOENCODE;
  UINT32 status_register NOENCODE;
  UINT32 mvlc_header NOENCODE
  {
     0_15: words;
    16_31: mh = MATCH(0xf500);
  }
  UINT32 skip_event_header NOENCODE;
  list(1<=index<mvlc_header.words)
  {
    UINT32 event NOENCODE
    {
       0_10: time_fine;
      11_23: time_coarse;
         24: future;
      25_29: channel;
      30_31: meh;
      ENCODE(time_fine[channel],(value=time_fine));
      ENCODE(time_coarse[channel],(value=time_coarse));
    }
  }
}

VFTX_CRATE_DATA()
{
  vftx = VFTX2(id=0);
  barrier[1] = BARRIER();
  mtdc = MESYTEC_MTDC32_FRS();
  barrier[2] = BARRIER();
  select optional
  {
    mqdc0 = MESYTEC_MQDC32_FRS();
  }
  select optional
  {
    mqdc1 = MESYTEC_MQDC32_FRS();
  }
}

VME_CAEN_V1190_FRS()
{
  MEMBER(DATA24 data[128] ZERO_SUPPRESS_MULTI(128));
  MEMBER(DATA8 leadOrTrail[128] ZERO_SUPPRESS_MULTI(128));
  UINT32 header NOENCODE
  {
     0_04: geo;
     5_26: event_count;
    27_31: seven_f;
  }
  if((header.seven_f != 8))
  {
    UINT32 second1 NOENCODE
    {
       0_31: 0xffffffff;
    }
    UINT32 real_header NOENCODE
    {
       0_04: geo;
       5_26: event_count;
      27_31: 8;
    }
  }
  select several
  {
    tdc_header = TDC_HEADER();
    measurement = TDC_DATA_V1190(data=data,leadOrTrail=leadOrTrail);
    tdc_error = TDC_ERROR();
    tdc_trailer = TDC_TRAILER();
  }
  optional UINT32 ext_time_tag NOENCODE
  {
     0_26: time_tag;
    27_31: 17;
  }
  UINT32 trailer NOENCODE
  {
     0_04: geo;
     5_20: word_count;
    21_23: unused;
       24: tdc_error;
       25: overflow;
       26: trigger_lost;
    27_31: 16;
  }
  optional UINT32 eob NOENCODE;
}

VME_CAEN_V1290_FRS()
{
  MEMBER(DATA24 data[128] ZERO_SUPPRESS_MULTI(128));
  MEMBER(DATA8 leadOrTrail[128] ZERO_SUPPRESS_MULTI(128));
  UINT32 header NOENCODE
  {
     0_04: geo;
     5_26: event_count;
    27_31: 8;
  }
  select several
  {
    tdc_header = TDC_HEADER();
    measurement = TDC_DATA_V1290(data=data,leadOrTrail=leadOrTrail);
    tdc_err = TDC_ERROR();
    tdc_trailer = TDC_TRAILER();
  }
  optional UINT32 ext_time_tag NOENCODE
  {
     0_26: time_tag;
    27_31: 17;
  }
  UINT32 trailer NOENCODE
  {
     0_04: geo;
     5_20: word_count;
    21_23: unused;
       24: tdc_error;
       25: overflow;
       26: trigger_lost;
    27_31: 16;
  }
  optional UINT32 eob NOENCODE;
}

VME_CAEN_V792_FRS()
{
  MEMBER(DATA32 data[32] ZERO_SUPPRESS_MULTI(32));
  MEMBER(DATA8 geo);
  UINT32 v792_header NOENCODE
  {
     0_07: unused;
     8_13: cnt;
    14_15: 0;
    16_23: crate;
    24_26: 2;
    27_31: geo;
    ENCODE(geo,(value=geo));
  }
  several UINT32 adc_data NOENCODE
  {
     0_11: adc;
       12: overflow;
       13: underthreshold;
    14_15: unused;
    16_20: channel;
    21_23: unused2;
    24_26: 0;
    27_31: geo;
    ENCODE(data[channel],(value=adc));
  }
  UINT32 eob NOENCODE
  {
     0_23: nothing;
    24_26: 4;
    27_31: geom;
  }
  list(0<=i<2)
  {
    optional UINT32 eob2 NOENCODE
    {
       0_23: nothing;
      24_26: id = MATCH(6);
      27_31: geom;
    }
  }
}

VME_CAEN_V7X5_FRS()
{
  MEMBER(DATA12_OVERFLOW data[32] ZERO_SUPPRESS);
  MEMBER(DATA8 channel[32] ZERO_SUPPRESS);
  MEMBER(DATA8 geo[32] ZERO_SUPPRESS);
  UINT32 header NOENCODE
  {
     0_07: undefined;
     8_13: count;
    16_23: crate;
    24_26: 2;
    27_31: geom;
  }
  list(0<=index<header.count)
  {
    UINT32 ch_data NOENCODE
    {
       0_11: value;
         12: overflow;
         13: underflow;
         14: valid;
         15: undefined;
      16_20: channel;
      21_23: undefined2;
      24_26: 0;
      27_31: geom;
      ENCODE(geo[index],(value=geom));
      ENCODE(channel[index],(value=channel));
      ENCODE(data[index],(value=value,overflow=overflow));
    }
  }
  UINT32 eob NOENCODE
  {
     0_23: nothing;
    24_26: 4;
    27_31: geom;
  }
  list(0<=i<2)
  {
    optional UINT32 eob2 NOENCODE
    {
       0_23: nothing;
      24_26: id = MATCH(6);
      27_31: geom;
    }
  }
}

VME_CAEN_V830_FRS()
{
  MEMBER(DATA32 data[32] ZERO_SUPPRESS);
  UINT32 v830_header NOENCODE
  {
     0_15: trigger_number;
    16_17: ts;
    18_23: nwords;
    24_25: unused;
       26: 1;
    27_31: geo;
  }
  list(0<=i<v830_header.nwords)
  {
    UINT32 data_word NOENCODE
    {
       0_31: value;
      ENCODE(data[i],(value=value));
    }
  }
}

WR_MULTI()
{
  MEMBER(DATA32 time_hi);
  MEMBER(DATA32 time_lo);
  UINT32 hi NOENCODE
  {
     0_31: time;
    ENCODE(time_hi,(value=time));
  }
  UINT32 lo NOENCODE
  {
     0_31: time;
    ENCODE(time_lo,(value=time));
  }
}

ZERO_FILLER()
{
  UINT32 filler NOENCODE
  {
     0_31: zero = MATCH(0);
  }
}

SUBEVENT(aida_subev)
{
  ts = TIMESTAMP_WHITERABBIT(id=0x700);
  external data = EXT_AIDA();
}

SUBEVENT(bplast_subev)
{
  ts = TIMESTAMP_WHITERABBIT(id=0x500);
  trigger_window = TAMEX4_HEADER();
  select several
  {
    padding = TAMEX4_PADDING();
  }
  select several
  {
    tamex[0] = TAMEX4_SFP(sfp=0,card=0);
    tamex[1] = TAMEX4_SFP(sfp=0,card=1);
    tamex[2] = TAMEX4_SFP(sfp=0,card=2);
    tamex[3] = TAMEX4_SFP(sfp=0,card=3);
    tamex[4] = TAMEX4_SFP(sfp=0,card=4);
  }
}

SUBEVENT(fatima_tamex_subev)
{
  ts = TIMESTAMP_WHITERABBIT_EXTENDED(id=0x1600);
  trigger_window = TAMEX4_HEADER();
  select several
  {
    padding = TAMEX4_PADDING();
  }
  select several
  {
    tamex[0] = TAMEX4_SFP(sfp=0,card=0);
    tamex[1] = TAMEX4_SFP(sfp=0,card=1);
  }
}

SUBEVENT(febex_subev)
{
  ts = TIMESTAMP_WHITERABBIT(id=0x400);
  select several
  {
    padding = FEBEX_PADDING();
  }
  select several
  {
    data[0] = FEBEX_EVENT(card=0);
    data[1] = FEBEX_EVENT(card=1);
    data[2] = FEBEX_EVENT(card=2);
    data[3] = FEBEX_EVENT(card=3);
  }
}

SUBEVENT(frs_main_subev)
{
  select several
  {
    wr = TIMESTAMP_WHITERABBIT(id=0x100);
  }
  select several
  {
    trig3 = TRIG3EVENT();
  }
  select several
  {
    data = MAIN_CRATE_DATA();
  }
}

SUBEVENT(frs_tpc_subev)
{
  select several
  {
    trig3 = TRIG3EVENT();
  }
  select several
  {
    data = TPC_CRATE_DATA();
  }
}

SUBEVENT(frs_user_subev)
{
  select several
  {
    trig3 = TRIG3EVENT();
  }
  select several
  {
    data = USER_CRATE_DATA();
  }
}

SUBEVENT(frs_vftx_subev)
{
  select several
  {
    trig3 = TRIG3EVENT();
  }
  select several
  {
    data = VFTX_CRATE_DATA();
  }
}

/**********************************************************
 * The event definition:
 */

EVENT
{
  revisit aida = aida_subev(type=10,subtype=1,procid=90,control=37);
  bplast = bplast_subev(type=10,subtype=1,procid=80,control=20,subcrate=0);
  frsmain = frs_main_subev(procid=10);
  frstpc = frs_tpc_subev(procid=20);
  frsuser = frs_user_subev(procid=30);
  frsvftx = frs_vftx_subev(procid=40);
  ignore_unknown_subevent;
}

/**********************************************************
 * The sticky_event definition:
 */

/**********************************************************
 * Signal name mappings:
 */

/**********************************************************/

/** END_INPUT_DEFINITION **********************************************/

/**********************************************************
 * Generating unpacking code...
 */

//
// Generating code for: BARRIER
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for BARRIER.
 *
 * Do not edit - automatically generated.
 */

// BARRIER()
#if !PACKER_CODE
# define DECLARED_UNPACK_BARRIER
class BARRIER
#else//PACKER_CODE
# define DECLARED_PACKER_BARRIER
class PACKER_BARRIER
#endif//PACKER_CODE

{
public:
  // UINT32 barrier NOENCODE
  // {
    //  0_19: no;
    // 20_31: ba = RANGE(0xf52,0xf58);
  // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(BARRIER);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for BARRIER.
 *
 * Do not edit - automatically generated.
 */

// BARRIER()
template<typename __data_src_t>
void BARRIER::__unpack(__data_src_t &__buffer)
{
  if (__buffer.is_memberdump())
  {
    printf("          %s%s%s: \n", CT_OUT(BOLD_BLUE),  "BARRIER",CT_OUT(NORM));
  }
  // UINT32 barrier NOENCODE
  // {
    //  0_19: no;
    // 20_31: ba = RANGE(0xf52,0xf58);
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 no : 20; // 0..19
      uint32 ba : 12; // 20..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 ba : 12; // 20..31
      uint32 no : 20; // 0..19
#endif
    };
    uint32  u32;
  } barrier;
  READ_FROM_BUFFER_FULL(14,uint32 ,barrier,barrier.u32,0);
  CHECK_BITS_RANGE(13,barrier.ba,0xf52,0xf58);
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: barrier ", CT_OUT(BOLD), barrier.u32, CT_OUT(NORM));
    printf(".no=%s%5" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  barrier.no, CT_OUT(NORM));
    printf(".ba=%s%3" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  barrier.ba, CT_OUT(NORM));
    printf("\n");
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,BARRIER::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for BARRIER.
 *
 * Do not edit - automatically generated.
 */

// BARRIER()
template<typename __data_src_t>
bool BARRIER::__match(__data_src_t &__buffer)
{
  // UINT32 barrier NOENCODE
  // {
    //  0_19: no;
    // 20_31: ba = RANGE(0xf52,0xf58);
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 no : 20; // 0..19
      uint32 ba : 12; // 20..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 ba : 12; // 20..31
      uint32 no : 20; // 0..19
#endif
    };
    uint32  u32;
  } barrier;
  MATCH_READ_FROM_BUFFER_FULL(14,uint32 ,barrier,barrier.u32,1);
  MATCH_BITS_RANGE(13,barrier.ba,0xf52,0xf58);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN(bool,BARRIER::__match);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for BARRIER.
 *
 * Do not edit - automatically generated.
 */

// BARRIER()
template<typename __data_dest_t>
void PACKER_BARRIER::__packer(__data_dest_t &__buffer)
{
  // UINT32 barrier NOENCODE
  // {
    //  0_19: no;
    // 20_31: ba = RANGE(0xf52,0xf58);
  // }
}
FORCE_IMPL_DATA_SRC_FCN(void,BARRIER::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: EXT_AIDA
//

// Structure is external.  Must be provided by the user


/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for EXT_AIDA.
 *
 * Do not edit - automatically generated.
 */


/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for EXT_AIDA.
 *
 * Do not edit - automatically generated.
 */


/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for EXT_AIDA.
 *
 * Do not edit - automatically generated.
 */


/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for EXT_AIDA.
 *
 * Do not edit - automatically generated.
 */


/** END_PACKER ********************************************************/

//
// Generating code for: FEBEX_EVENT
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for FEBEX_EVENT.
 *
 * Do not edit - automatically generated.
 */

// FEBEX_EVENT(card)
#if !PACKER_CODE
# define DECLARED_UNPACK_FEBEX_EVENT
class FEBEX_EVENT
#else//PACKER_CODE
# define DECLARED_PACKER_FEBEX_EVENT
class PACKER_FEBEX_EVENT
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA32 event_trigger_time_hi);
  DATA32 event_trigger_time_hi;
  // MEMBER(DATA32 event_trigger_time_lo);
  DATA32 event_trigger_time_lo;
  // MEMBER(DATA16 hit_pattern);
  DATA16 hit_pattern;
  // MEMBER(DATA16 channel_trigger_time_hi[16] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA16,DATA16,16> channel_trigger_time_hi;
  // MEMBER(DATA32 channel_trigger_time_lo[16] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA32,DATA32,16> channel_trigger_time_lo;
  // MEMBER(DATA8 pileup[16] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA8,DATA8,16> pileup;
  // MEMBER(DATA8 overflow[16] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA8,DATA8,16> overflow;
  // MEMBER(DATA8 channel_cfd[16] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA8,DATA8,16> channel_cfd;
  // MEMBER(DATA32 channel_energy[16] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA32,DATA32,16> channel_energy;
  // UINT32 sumchannel NOENCODE
  // {
    //  0_07: 52;
    //  8_11: trigger_type;
    // 12_15: sfpnr;
    // 16_23: card = MATCH(card);
    // 24_31: 255;
  // }
  // UINT32 channel_size NOENCODE
  // {
    //  0_01: ignore;
    //  2_31: size;
  // }
  // UINT32 event_timestamp_hi NOENCODE
  // {
    //  0_15: timestamp_hi;
    // 16_31: ignore;
    // ENCODE(event_trigger_time_hi,(value=timestamp_hi));
  // }
  // UINT32 event_timestamp_lo NOENCODE
  // {
    //  0_31: timestamp_lo;
    // ENCODE(event_trigger_time_lo,(value=timestamp_lo));
  // }
  // UINT32 hp NOENCODE
  // {
    //  0_15: hp;
    // 16_31: ignore;
    // ENCODE(hit_pattern,(value=hp));
  // }
  // UINT32 deadbeef NOENCODE
  // {
    //  0_31: 0xdeadbeef;
  // }
  // list(0<=index<((channel_size.size / 4) - 1))

    // UINT32 channelids NOENCODE
    // {
      //  0_15: chan_ts_hi;
      // 16_23: channel_id_bits;
      // 24_31: 240;
      // ENCODE(channel_trigger_time_hi[channelids.channel_id_bits],(value=chan_ts_hi));
    // }
    // UINT32 channel_ts NOENCODE
    // {
      //  0_31: chan_ts_lo;
      // ENCODE(channel_trigger_time_lo[channelids.channel_id_bits],(value=chan_ts_lo));
    // }
    // UINT32 chan_enrgy NOENCODE
    // {
      //  0_23: chan_energy;
      // 24_29: TSF;
      //    30: pileup_flag;
      //    31: overflow_flag;
      // ENCODE(channel_cfd[channelids.channel_id_bits],(value=TSF));
      // ENCODE(channel_energy[channelids.channel_id_bits],(value=chan_energy));
      // ENCODE(pileup[channelids.channel_id_bits],(value=pileup_flag));
      // ENCODE(overflow[channelids.channel_id_bits],(value=overflow_flag));
    // }
    // UINT32 future_use NOENCODE
    // {
      //  0_31: 0;
    // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 card);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 card);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 card);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(FEBEX_EVENT);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for FEBEX_EVENT.
 *
 * Do not edit - automatically generated.
 */

// FEBEX_EVENT(card)
template<typename __data_src_t>
void FEBEX_EVENT::__unpack(__data_src_t &__buffer,uint32 card)
{
  if (__buffer.is_memberdump())
  {
    printf("          %s%s%s: \n", CT_OUT(BOLD_BLUE),  "FEBEX_EVENT",CT_OUT(NORM));
  }
  // MEMBER(DATA32 event_trigger_time_hi);
  // MEMBER(DATA32 event_trigger_time_lo);
  // MEMBER(DATA16 hit_pattern);
  // MEMBER(DATA16 channel_trigger_time_hi[16] ZERO_SUPPRESS);
  // MEMBER(DATA32 channel_trigger_time_lo[16] ZERO_SUPPRESS);
  // MEMBER(DATA8 pileup[16] ZERO_SUPPRESS);
  // MEMBER(DATA8 overflow[16] ZERO_SUPPRESS);
  // MEMBER(DATA8 channel_cfd[16] ZERO_SUPPRESS);
  // MEMBER(DATA32 channel_energy[16] ZERO_SUPPRESS);
  // UINT32 sumchannel NOENCODE
  // {
    //  0_07: 52;
    //  8_11: trigger_type;
    // 12_15: sfpnr;
    // 16_23: card = MATCH(card);
    // 24_31: 255;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 unnamed_0_7 : 8; // 0..7
      uint32 trigger_type : 4; // 8..11
      uint32 sfpnr : 4; // 12..15
      uint32 card : 8; // 16..23
      uint32 unnamed_24_31 : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_24_31 : 8; // 24..31
      uint32 card : 8; // 16..23
      uint32 sfpnr : 4; // 12..15
      uint32 trigger_type : 4; // 8..11
      uint32 unnamed_0_7 : 8; // 0..7
#endif
    };
    uint32  u32;
  } sumchannel;
  READ_FROM_BUFFER_FULL(38,uint32 ,sumchannel,sumchannel.u32,2);
  CHECK_BITS_EQUAL(33,sumchannel.unnamed_0_7,52);
  CHECK_BITS_EQUAL(36,sumchannel.card,card);
  CHECK_BITS_EQUAL(37,sumchannel.unnamed_24_31,255);
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: sumchannel ", CT_OUT(BOLD), sumchannel.u32, CT_OUT(NORM));
    printf(".trigger_type=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  sumchannel.trigger_type, CT_OUT(NORM));
    printf(".sfpnr=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  sumchannel.sfpnr, CT_OUT(NORM));
    printf(".card=%s%2" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  sumchannel.card, CT_OUT(NORM));
    printf("\n");
  }
  // UINT32 channel_size NOENCODE
  // {
    //  0_01: ignore;
    //  2_31: size;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 ignore : 2; // 0..1
      uint32 size : 30; // 2..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 size : 30; // 2..31
      uint32 ignore : 2; // 0..1
#endif
    };
    uint32  u32;
  } channel_size;
  READ_FROM_BUFFER_FULL(43,uint32 ,channel_size,channel_size.u32,3);
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: channel_size ", CT_OUT(BOLD), channel_size.u32, CT_OUT(NORM));
    printf(".ignore=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  channel_size.ignore, CT_OUT(NORM));
    printf(".size=%s%8" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  channel_size.size, CT_OUT(NORM));
    printf("\n");
  }
  // UINT32 event_timestamp_hi NOENCODE
  // {
    //  0_15: timestamp_hi;
    // 16_31: ignore;
    // ENCODE(event_trigger_time_hi,(value=timestamp_hi));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 timestamp_hi : 16; // 0..15
      uint32 ignore : 16; // 16..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 ignore : 16; // 16..31
      uint32 timestamp_hi : 16; // 0..15
#endif
    };
    uint32  u32;
  } event_timestamp_hi;
  READ_FROM_BUFFER_FULL(49,uint32 ,event_timestamp_hi,event_timestamp_hi.u32,4);
  {
    event_trigger_time_hi.value = event_timestamp_hi.timestamp_hi;
  }
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: event_timestamp_hi ", CT_OUT(BOLD), event_timestamp_hi.u32, CT_OUT(NORM));
    printf(".timestamp_hi=%s%4" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  event_timestamp_hi.timestamp_hi, CT_OUT(NORM));
    printf(".ignore=%s%4" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  event_timestamp_hi.ignore, CT_OUT(NORM));
    printf("\n");
  }
  // UINT32 event_timestamp_lo NOENCODE
  // {
    //  0_31: timestamp_lo;
    // ENCODE(event_trigger_time_lo,(value=timestamp_lo));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 timestamp_lo : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 timestamp_lo : 32; // 0..31
#endif
    };
    uint32  u32;
  } event_timestamp_lo;
  READ_FROM_BUFFER_FULL(54,uint32 ,event_timestamp_lo,event_timestamp_lo.u32,5);
  {
    event_trigger_time_lo.value = event_timestamp_lo.timestamp_lo;
  }
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: event_timestamp_lo ", CT_OUT(BOLD), event_timestamp_lo.u32, CT_OUT(NORM));
    printf(".timestamp_lo=%s%8" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  event_timestamp_lo.timestamp_lo, CT_OUT(NORM));
    printf("\n");
  }
  // UINT32 hp NOENCODE
  // {
    //  0_15: hp;
    // 16_31: ignore;
    // ENCODE(hit_pattern,(value=hp));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 hp : 16; // 0..15
      uint32 ignore : 16; // 16..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 ignore : 16; // 16..31
      uint32 hp : 16; // 0..15
#endif
    };
    uint32  u32;
  } hp;
  READ_FROM_BUFFER_FULL(60,uint32 ,hp,hp.u32,6);
  {
    hit_pattern.value = hp.hp;
  }
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: hp ", CT_OUT(BOLD), hp.u32, CT_OUT(NORM));
    printf(".hp=%s%4" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  hp.hp, CT_OUT(NORM));
    printf(".ignore=%s%4" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  hp.ignore, CT_OUT(NORM));
    printf("\n");
  }
  // UINT32 deadbeef NOENCODE
  // {
    //  0_31: 0xdeadbeef;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 unnamed_0_31 : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_0_31 : 32; // 0..31
#endif
    };
    uint32  u32;
  } deadbeef;
  READ_FROM_BUFFER_FULL(64,uint32 ,deadbeef,deadbeef.u32,7);
  CHECK_BITS_EQUAL(63,deadbeef.unnamed_0_31,0xdeadbeef);
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: deadbeef ", CT_OUT(BOLD), deadbeef.u32, CT_OUT(NORM));
    printf("\n");
  }
  // list(0<=index<((channel_size.size / 4) - 1))

  for (uint32 index = 0; index < (uint32) (((channel_size.size / 4) - 1)); ++index)
  {
    // UINT32 channelids NOENCODE
    // {
      //  0_15: chan_ts_hi;
      // 16_23: channel_id_bits;
      // 24_31: 240;
      // ENCODE(channel_trigger_time_hi[channelids.channel_id_bits],(value=chan_ts_hi));
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 chan_ts_hi : 16; // 0..15
        uint32 channel_id_bits : 8; // 16..23
        uint32 unnamed_24_31 : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 unnamed_24_31 : 8; // 24..31
        uint32 channel_id_bits : 8; // 16..23
        uint32 chan_ts_hi : 16; // 0..15
#endif
      };
      uint32  u32;
    } channelids;
    READ_FROM_BUFFER_FULL(73,uint32 ,channelids,channelids.u32,8);
    CHECK_BITS_EQUAL(71,channelids.unnamed_24_31,240);
    {
      typedef __typeof__(*(&(channel_trigger_time_hi))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = channel_trigger_time_hi.insert_index(72,channelids.channel_id_bits);
      __item.value = channelids.chan_ts_hi;
    }
    if (__buffer.is_memberdump())
    {
      printf("%s%08" PRIx32 "%s: channelids ", CT_OUT(BOLD), channelids.u32, CT_OUT(NORM));
      printf(".chan_ts_hi=%s%4" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  channelids.chan_ts_hi, CT_OUT(NORM));
      printf(".channel_id_bits=%s%2" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  channelids.channel_id_bits, CT_OUT(NORM));
      printf("\n");
    }
    // UINT32 channel_ts NOENCODE
    // {
      //  0_31: chan_ts_lo;
      // ENCODE(channel_trigger_time_lo[channelids.channel_id_bits],(value=chan_ts_lo));
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 chan_ts_lo : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 chan_ts_lo : 32; // 0..31
#endif
      };
      uint32  u32;
    } channel_ts;
    READ_FROM_BUFFER_FULL(78,uint32 ,channel_ts,channel_ts.u32,9);
    {
      typedef __typeof__(*(&(channel_trigger_time_lo))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = channel_trigger_time_lo.insert_index(77,channelids.channel_id_bits);
      __item.value = channel_ts.chan_ts_lo;
    }
    if (__buffer.is_memberdump())
    {
      printf("%s%08" PRIx32 "%s: channel_ts ", CT_OUT(BOLD), channel_ts.u32, CT_OUT(NORM));
      printf(".chan_ts_lo=%s%8" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  channel_ts.chan_ts_lo, CT_OUT(NORM));
      printf("\n");
    }
    // UINT32 chan_enrgy NOENCODE
    // {
      //  0_23: chan_energy;
      // 24_29: TSF;
      //    30: pileup_flag;
      //    31: overflow_flag;
      // ENCODE(channel_cfd[channelids.channel_id_bits],(value=TSF));
      // ENCODE(channel_energy[channelids.channel_id_bits],(value=chan_energy));
      // ENCODE(pileup[channelids.channel_id_bits],(value=pileup_flag));
      // ENCODE(overflow[channelids.channel_id_bits],(value=overflow_flag));
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 chan_energy : 24; // 0..23
        uint32 TSF : 6; // 24..29
        uint32 pileup_flag : 1; // 30
        uint32 overflow_flag : 1; // 31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 overflow_flag : 1; // 31
        uint32 pileup_flag : 1; // 30
        uint32 TSF : 6; // 24..29
        uint32 chan_energy : 24; // 0..23
#endif
      };
      uint32  u32;
    } chan_enrgy;
    READ_FROM_BUFFER_FULL(89,uint32 ,chan_enrgy,chan_enrgy.u32,10);
    {
      {
        typedef __typeof__(*(&(channel_cfd))) __array_t;
        typedef typename __array_t::item_t __item_t;
        __item_t &__item = channel_cfd.insert_index(85,channelids.channel_id_bits);
        __item.value = chan_enrgy.TSF;
      }
      {
        typedef __typeof__(*(&(channel_energy))) __array_t;
        typedef typename __array_t::item_t __item_t;
        __item_t &__item = channel_energy.insert_index(86,channelids.channel_id_bits);
        __item.value = chan_enrgy.chan_energy;
      }
      {
        typedef __typeof__(*(&(pileup))) __array_t;
        typedef typename __array_t::item_t __item_t;
        __item_t &__item = pileup.insert_index(87,channelids.channel_id_bits);
        __item.value = chan_enrgy.pileup_flag;
      }
      {
        typedef __typeof__(*(&(overflow))) __array_t;
        typedef typename __array_t::item_t __item_t;
        __item_t &__item = overflow.insert_index(88,channelids.channel_id_bits);
        __item.value = chan_enrgy.overflow_flag;
      }
    }
    if (__buffer.is_memberdump())
    {
      printf("%s%08" PRIx32 "%s: chan_enrgy ", CT_OUT(BOLD), chan_enrgy.u32, CT_OUT(NORM));
      printf(".chan_energy=%s%6" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  chan_enrgy.chan_energy, CT_OUT(NORM));
      printf(".TSF=%s%2" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  chan_enrgy.TSF, CT_OUT(NORM));
      printf(".pileup_flag=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  chan_enrgy.pileup_flag, CT_OUT(NORM));
      printf(".overflow_flag=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  chan_enrgy.overflow_flag, CT_OUT(NORM));
      printf("\n");
    }
    // UINT32 future_use NOENCODE
    // {
      //  0_31: 0;
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 unnamed_0_31 : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 unnamed_0_31 : 32; // 0..31
#endif
      };
      uint32  u32;
    } future_use;
    READ_FROM_BUFFER_FULL(93,uint32 ,future_use,future_use.u32,11);
    CHECK_BITS_EQUAL(92,future_use.unnamed_0_31,0);
    if (__buffer.is_memberdump())
    {
      printf("%s%08" PRIx32 "%s: future_use ", CT_OUT(BOLD), future_use.u32, CT_OUT(NORM));
      printf("\n");
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,FEBEX_EVENT::__unpack,uint32 card);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for FEBEX_EVENT.
 *
 * Do not edit - automatically generated.
 */

// FEBEX_EVENT(card)
template<typename __data_src_t>
bool FEBEX_EVENT::__match(__data_src_t &__buffer,uint32 card)
{
  // MEMBER(DATA32 event_trigger_time_hi);
  // MEMBER(DATA32 event_trigger_time_lo);
  // MEMBER(DATA16 hit_pattern);
  // MEMBER(DATA16 channel_trigger_time_hi[16] ZERO_SUPPRESS);
  // MEMBER(DATA32 channel_trigger_time_lo[16] ZERO_SUPPRESS);
  // MEMBER(DATA8 pileup[16] ZERO_SUPPRESS);
  // MEMBER(DATA8 overflow[16] ZERO_SUPPRESS);
  // MEMBER(DATA8 channel_cfd[16] ZERO_SUPPRESS);
  // MEMBER(DATA32 channel_energy[16] ZERO_SUPPRESS);
  // UINT32 sumchannel NOENCODE
  // {
    //  0_07: 52;
    //  8_11: trigger_type;
    // 12_15: sfpnr;
    // 16_23: card = MATCH(card);
    // 24_31: 255;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 unnamed_0_7 : 8; // 0..7
      uint32 trigger_type : 4; // 8..11
      uint32 sfpnr : 4; // 12..15
      uint32 card : 8; // 16..23
      uint32 unnamed_24_31 : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_24_31 : 8; // 24..31
      uint32 card : 8; // 16..23
      uint32 sfpnr : 4; // 12..15
      uint32 trigger_type : 4; // 8..11
      uint32 unnamed_0_7 : 8; // 0..7
#endif
    };
    uint32  u32;
  } sumchannel;
  MATCH_READ_FROM_BUFFER_FULL(38,uint32 ,sumchannel,sumchannel.u32,12);
  MATCH_BITS_EQUAL(33,sumchannel.unnamed_0_7,52);
  MATCH_BITS_EQUAL(36,sumchannel.card,card);
  MATCH_BITS_EQUAL(37,sumchannel.unnamed_24_31,255);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,FEBEX_EVENT::__match,uint32 card);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for FEBEX_EVENT.
 *
 * Do not edit - automatically generated.
 */

// FEBEX_EVENT(card)
template<typename __data_dest_t>
void PACKER_FEBEX_EVENT::__packer(__data_dest_t &__buffer,uint32 card)
{
  // MEMBER(DATA32 event_trigger_time_hi);
  // MEMBER(DATA32 event_trigger_time_lo);
  // MEMBER(DATA16 hit_pattern);
  // MEMBER(DATA16 channel_trigger_time_hi[16] ZERO_SUPPRESS);
  // MEMBER(DATA32 channel_trigger_time_lo[16] ZERO_SUPPRESS);
  // MEMBER(DATA8 pileup[16] ZERO_SUPPRESS);
  // MEMBER(DATA8 overflow[16] ZERO_SUPPRESS);
  // MEMBER(DATA8 channel_cfd[16] ZERO_SUPPRESS);
  // MEMBER(DATA32 channel_energy[16] ZERO_SUPPRESS);
  // UINT32 sumchannel NOENCODE
  // {
    //  0_07: 52;
    //  8_11: trigger_type;
    // 12_15: sfpnr;
    // 16_23: card = MATCH(card);
    // 24_31: 255;
  // }
  // UINT32 channel_size NOENCODE
  // {
    //  0_01: ignore;
    //  2_31: size;
  // }
  // UINT32 event_timestamp_hi NOENCODE
  // {
    //  0_15: timestamp_hi;
    // 16_31: ignore;
    // ENCODE(event_trigger_time_hi,(value=timestamp_hi));
  // }
  // UINT32 event_timestamp_lo NOENCODE
  // {
    //  0_31: timestamp_lo;
    // ENCODE(event_trigger_time_lo,(value=timestamp_lo));
  // }
  // UINT32 hp NOENCODE
  // {
    //  0_15: hp;
    // 16_31: ignore;
    // ENCODE(hit_pattern,(value=hp));
  // }
  // UINT32 deadbeef NOENCODE
  // {
    //  0_31: 0xdeadbeef;
  // }
  // list(0<=index<((channel_size.size / 4) - 1))

  {
    // UINT32 channelids NOENCODE
    // {
      //  0_15: chan_ts_hi;
      // 16_23: channel_id_bits;
      // 24_31: 240;
      // ENCODE(channel_trigger_time_hi[channelids.channel_id_bits],(value=chan_ts_hi));
    // }
    // UINT32 channel_ts NOENCODE
    // {
      //  0_31: chan_ts_lo;
      // ENCODE(channel_trigger_time_lo[channelids.channel_id_bits],(value=chan_ts_lo));
    // }
    // UINT32 chan_enrgy NOENCODE
    // {
      //  0_23: chan_energy;
      // 24_29: TSF;
      //    30: pileup_flag;
      //    31: overflow_flag;
      // ENCODE(channel_cfd[channelids.channel_id_bits],(value=TSF));
      // ENCODE(channel_energy[channelids.channel_id_bits],(value=chan_energy));
      // ENCODE(pileup[channelids.channel_id_bits],(value=pileup_flag));
      // ENCODE(overflow[channelids.channel_id_bits],(value=overflow_flag));
    // }
    // UINT32 future_use NOENCODE
    // {
      //  0_31: 0;
    // }
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,FEBEX_EVENT::__packer,uint32 card);

/** END_PACKER ********************************************************/

//
// Generating code for: FEBEX_EVENT_TRACES
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for FEBEX_EVENT_TRACES.
 *
 * Do not edit - automatically generated.
 */

// FEBEX_EVENT_TRACES(card)
#if !PACKER_CODE
# define DECLARED_UNPACK_FEBEX_EVENT_TRACES
class FEBEX_EVENT_TRACES
#else//PACKER_CODE
# define DECLARED_PACKER_FEBEX_EVENT_TRACES
class PACKER_FEBEX_EVENT_TRACES
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA32 event_trigger_time_hi);
  DATA32 event_trigger_time_hi;
  // MEMBER(DATA32 event_trigger_time_lo);
  DATA32 event_trigger_time_lo;
  // MEMBER(DATA16 hit_pattern);
  DATA16 hit_pattern;
  // MEMBER(DATA32 num_channels_fired);
  DATA32 num_channels_fired;
  // MEMBER(DATA8 channel_id[16] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA8,DATA8,16> channel_id;
  // MEMBER(DATA16 channel_trigger_time_hi[16] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA16,DATA16,16> channel_trigger_time_hi;
  // MEMBER(DATA32 channel_trigger_time_lo[16] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA32,DATA32,16> channel_trigger_time_lo;
  // MEMBER(DATA8 pileup[16]);
  raw_array<DATA8,DATA8,16> pileup;
  // MEMBER(DATA8 overflow[16]);
  raw_array<DATA8,DATA8,16> overflow;
  // MEMBER(DATA8 channel_cfd[16] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA8,DATA8,16> channel_cfd;
  // MEMBER(DATA32 channel_energy[16] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA32,DATA32,16> channel_energy;
  // MEMBER(DATA16 traces[16][10000] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA16,DATA16,10000> traces[16];
  // UINT32 sumchannel NOENCODE
  // {
    //  0_07: 52;
    //  8_11: trigger_type;
    // 12_15: sfpnr;
    // 16_23: board_id = MATCH(card);
    // 24_31: 255;
  // }
  // UINT32 channel_size NOENCODE
  // {
    //  0_01: ignore;
    //  2_31: size;
    // ENCODE(num_channels_fired,(value=((size / 4) - 1)));
  // }
  // UINT32 event_timestamp_hi NOENCODE
  // {
    //  0_15: timestamp_hi;
    // 16_31: ignore;
    // ENCODE(event_trigger_time_hi,(value=timestamp_hi));
  // }
  // UINT32 event_timestamp_lo NOENCODE
  // {
    //  0_31: timestamp_lo;
    // ENCODE(event_trigger_time_lo,(value=timestamp_lo));
  // }
  // UINT32 hp NOENCODE
  // {
    //  0_15: hp;
    // 16_31: ignore;
    // ENCODE(hit_pattern,(value=hp));
  // }
  // UINT32 deadbeef NOENCODE
  // {
    //  0_31: 0xdeadbeef;
  // }
  // if((sumchannel.trigger_type == 1))

  // else

    // list(0<=index<((channel_size.size / 4) - 1))

      // UINT32 channelids NOENCODE
      // {
        //  0_15: chan_ts_hi;
        // 16_23: channel_id_bits;
        // 24_31: 240;
        // ENCODE(channel_id[index],(value=channel_id_bits));
        // ENCODE(channel_trigger_time_hi[index],(value=chan_ts_hi));
      // }
      // UINT32 channel_ts NOENCODE
      // {
        //  0_31: chan_ts_lo;
        // ENCODE(channel_trigger_time_lo[index],(value=chan_ts_lo));
      // }
      // UINT32 chan_enrgy NOENCODE
      // {
        //  0_23: chan_energy;
        // 24_29: TSF;
        //    30: pileup_flag;
        //    31: overflow_flag;
        // ENCODE(channel_cfd[index],(value=TSF));
        // ENCODE(channel_energy[index],(value=chan_energy));
        // ENCODE(pileup[index],(value=pileup_flag));
        // ENCODE(overflow[index],(value=overflow_flag));
      // }
      // UINT32 future_use NOENCODE
      // {
        //  0_31: 0;
      // }
    // list(0<=i<16)

      // UINT32 header NOENCODE
      // {
        //  0_07: 52;
        //  8_23: other;
        // 24_31: ch_id;
      // }
      // UINT32 tracesize NOENCODE
      // {
        //  0_31: size;
      // }
      // UINT32 tracehead NOENCODE
      // {
        //  0_23: other;
        // 24_31: head;
      // }
      // list(0<=j<((tracesize.size / 4) - 2))

        // UINT32 channel_trace NOENCODE
        // {
          //  0_13: data1;
          // 14_15: stuff1;
          // 16_29: data2;
          // 30_31: stuff2;
          // ENCODE(traces[header.ch_id][((2 * j) + 0)],(value=data1));
          // ENCODE(traces[header.ch_id][((2 * j) + 1)],(value=data2));
        // }
      // UINT32 trace_trailer NOENCODE
      // {
        //  0_23: notused;
        // 24_31: id = RANGE(176,191);
      // }
    // if((sumchannel.trigger_type == 3))

      // list(0<=i<16)

        // UINT32 header NOENCODE
        // {
          //  0_07: 52;
          //  8_23: other;
          // 24_31: ch_id;
        // }
        // UINT32 tracesize NOENCODE
        // {
          //  0_31: size;
        // }
        // UINT32 tracehead NOENCODE
        // {
          //  0_23: other;
          // 24_31: head;
        // }
        // UINT32 trace_trailer NOENCODE
        // {
          //  0_23: notused;
          // 24_31: id = RANGE(176,191);
        // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 card);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 card);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 card);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(FEBEX_EVENT_TRACES);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for FEBEX_EVENT_TRACES.
 *
 * Do not edit - automatically generated.
 */

// FEBEX_EVENT_TRACES(card)
template<typename __data_src_t>
void FEBEX_EVENT_TRACES::__unpack(__data_src_t &__buffer,uint32 card)
{
  if (__buffer.is_memberdump())
  {
    printf("          %s%s%s: \n", CT_OUT(BOLD_BLUE),  "FEBEX_EVENT_TRACES",CT_OUT(NORM));
  }
  // MEMBER(DATA32 event_trigger_time_hi);
  // MEMBER(DATA32 event_trigger_time_lo);
  // MEMBER(DATA16 hit_pattern);
  // MEMBER(DATA32 num_channels_fired);
  // MEMBER(DATA8 channel_id[16] ZERO_SUPPRESS);
  // MEMBER(DATA16 channel_trigger_time_hi[16] ZERO_SUPPRESS);
  // MEMBER(DATA32 channel_trigger_time_lo[16] ZERO_SUPPRESS);
  // MEMBER(DATA8 pileup[16]);
  // MEMBER(DATA8 overflow[16]);
  // MEMBER(DATA8 channel_cfd[16] ZERO_SUPPRESS);
  // MEMBER(DATA32 channel_energy[16] ZERO_SUPPRESS);
  // MEMBER(DATA16 traces[16][10000] ZERO_SUPPRESS);
  // UINT32 sumchannel NOENCODE
  // {
    //  0_07: 52;
    //  8_11: trigger_type;
    // 12_15: sfpnr;
    // 16_23: board_id = MATCH(card);
    // 24_31: 255;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 unnamed_0_7 : 8; // 0..7
      uint32 trigger_type : 4; // 8..11
      uint32 sfpnr : 4; // 12..15
      uint32 board_id : 8; // 16..23
      uint32 unnamed_24_31 : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_24_31 : 8; // 24..31
      uint32 board_id : 8; // 16..23
      uint32 sfpnr : 4; // 12..15
      uint32 trigger_type : 4; // 8..11
      uint32 unnamed_0_7 : 8; // 0..7
#endif
    };
    uint32  u32;
  } sumchannel;
  READ_FROM_BUFFER_FULL(118,uint32 ,sumchannel,sumchannel.u32,13);
  CHECK_BITS_EQUAL(113,sumchannel.unnamed_0_7,52);
  CHECK_BITS_EQUAL(116,sumchannel.board_id,card);
  CHECK_BITS_EQUAL(117,sumchannel.unnamed_24_31,255);
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: sumchannel ", CT_OUT(BOLD), sumchannel.u32, CT_OUT(NORM));
    printf(".trigger_type=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  sumchannel.trigger_type, CT_OUT(NORM));
    printf(".sfpnr=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  sumchannel.sfpnr, CT_OUT(NORM));
    printf(".board_id=%s%2" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  sumchannel.board_id, CT_OUT(NORM));
    printf("\n");
  }
  // UINT32 channel_size NOENCODE
  // {
    //  0_01: ignore;
    //  2_31: size;
    // ENCODE(num_channels_fired,(value=((size / 4) - 1)));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 ignore : 2; // 0..1
      uint32 size : 30; // 2..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 size : 30; // 2..31
      uint32 ignore : 2; // 0..1
#endif
    };
    uint32  u32;
  } channel_size;
  READ_FROM_BUFFER_FULL(124,uint32 ,channel_size,channel_size.u32,14);
  {
    num_channels_fired.value = ((channel_size.size / 4) - 1);
  }
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: channel_size ", CT_OUT(BOLD), channel_size.u32, CT_OUT(NORM));
    printf(".ignore=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  channel_size.ignore, CT_OUT(NORM));
    printf(".size=%s%8" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  channel_size.size, CT_OUT(NORM));
    printf("\n");
  }
  // UINT32 event_timestamp_hi NOENCODE
  // {
    //  0_15: timestamp_hi;
    // 16_31: ignore;
    // ENCODE(event_trigger_time_hi,(value=timestamp_hi));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 timestamp_hi : 16; // 0..15
      uint32 ignore : 16; // 16..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 ignore : 16; // 16..31
      uint32 timestamp_hi : 16; // 0..15
#endif
    };
    uint32  u32;
  } event_timestamp_hi;
  READ_FROM_BUFFER_FULL(130,uint32 ,event_timestamp_hi,event_timestamp_hi.u32,15);
  {
    event_trigger_time_hi.value = event_timestamp_hi.timestamp_hi;
  }
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: event_timestamp_hi ", CT_OUT(BOLD), event_timestamp_hi.u32, CT_OUT(NORM));
    printf(".timestamp_hi=%s%4" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  event_timestamp_hi.timestamp_hi, CT_OUT(NORM));
    printf(".ignore=%s%4" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  event_timestamp_hi.ignore, CT_OUT(NORM));
    printf("\n");
  }
  // UINT32 event_timestamp_lo NOENCODE
  // {
    //  0_31: timestamp_lo;
    // ENCODE(event_trigger_time_lo,(value=timestamp_lo));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 timestamp_lo : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 timestamp_lo : 32; // 0..31
#endif
    };
    uint32  u32;
  } event_timestamp_lo;
  READ_FROM_BUFFER_FULL(135,uint32 ,event_timestamp_lo,event_timestamp_lo.u32,16);
  {
    event_trigger_time_lo.value = event_timestamp_lo.timestamp_lo;
  }
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: event_timestamp_lo ", CT_OUT(BOLD), event_timestamp_lo.u32, CT_OUT(NORM));
    printf(".timestamp_lo=%s%8" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  event_timestamp_lo.timestamp_lo, CT_OUT(NORM));
    printf("\n");
  }
  // UINT32 hp NOENCODE
  // {
    //  0_15: hp;
    // 16_31: ignore;
    // ENCODE(hit_pattern,(value=hp));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 hp : 16; // 0..15
      uint32 ignore : 16; // 16..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 ignore : 16; // 16..31
      uint32 hp : 16; // 0..15
#endif
    };
    uint32  u32;
  } hp;
  READ_FROM_BUFFER_FULL(141,uint32 ,hp,hp.u32,17);
  {
    hit_pattern.value = hp.hp;
  }
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: hp ", CT_OUT(BOLD), hp.u32, CT_OUT(NORM));
    printf(".hp=%s%4" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  hp.hp, CT_OUT(NORM));
    printf(".ignore=%s%4" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  hp.ignore, CT_OUT(NORM));
    printf("\n");
  }
  // UINT32 deadbeef NOENCODE
  // {
    //  0_31: 0xdeadbeef;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 unnamed_0_31 : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_0_31 : 32; // 0..31
#endif
    };
    uint32  u32;
  } deadbeef;
  READ_FROM_BUFFER_FULL(145,uint32 ,deadbeef,deadbeef.u32,18);
  CHECK_BITS_EQUAL(144,deadbeef.unnamed_0_31,0xdeadbeef);
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: deadbeef ", CT_OUT(BOLD), deadbeef.u32, CT_OUT(NORM));
    printf("\n");
  }
  // if((sumchannel.trigger_type == 1))

  // else

  if ((sumchannel.trigger_type == 1))
  {
    // list(0<=index<((channel_size.size / 4) - 1))

    for (uint32 index = 0; index < (uint32) (((channel_size.size / 4) - 1)); ++index)
    {
      // UINT32 channelids NOENCODE
      // {
        //  0_15: chan_ts_hi;
        // 16_23: channel_id_bits;
        // 24_31: 240;
        // ENCODE(channel_id[index],(value=channel_id_bits));
        // ENCODE(channel_trigger_time_hi[index],(value=chan_ts_hi));
      // }
      union
      {
        struct
        {
#if __BYTE_ORDER == __LITTLE_ENDIAN
          uint32 chan_ts_hi : 16; // 0..15
          uint32 channel_id_bits : 8; // 16..23
          uint32 unnamed_24_31 : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
          uint32 unnamed_24_31 : 8; // 24..31
          uint32 channel_id_bits : 8; // 16..23
          uint32 chan_ts_hi : 16; // 0..15
#endif
        };
        uint32  u32;
      } channelids;
      READ_FROM_BUFFER_FULL(157,uint32 ,channelids,channelids.u32,19);
      CHECK_BITS_EQUAL(154,channelids.unnamed_24_31,240);
      {
        {
          typedef __typeof__(*(&(channel_id))) __array_t;
          typedef typename __array_t::item_t __item_t;
          __item_t &__item = channel_id.insert_index(155,index);
          __item.value = channelids.channel_id_bits;
        }
        {
          typedef __typeof__(*(&(channel_trigger_time_hi))) __array_t;
          typedef typename __array_t::item_t __item_t;
          __item_t &__item = channel_trigger_time_hi.insert_index(156,index);
          __item.value = channelids.chan_ts_hi;
        }
      }
      if (__buffer.is_memberdump())
      {
        printf("%s%08" PRIx32 "%s: channelids ", CT_OUT(BOLD), channelids.u32, CT_OUT(NORM));
        printf(".chan_ts_hi=%s%4" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  channelids.chan_ts_hi, CT_OUT(NORM));
        printf(".channel_id_bits=%s%2" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  channelids.channel_id_bits, CT_OUT(NORM));
        printf("\n");
      }
      // UINT32 channel_ts NOENCODE
      // {
        //  0_31: chan_ts_lo;
        // ENCODE(channel_trigger_time_lo[index],(value=chan_ts_lo));
      // }
      union
      {
        struct
        {
#if __BYTE_ORDER == __LITTLE_ENDIAN
          uint32 chan_ts_lo : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
          uint32 chan_ts_lo : 32; // 0..31
#endif
        };
        uint32  u32;
      } channel_ts;
      READ_FROM_BUFFER_FULL(162,uint32 ,channel_ts,channel_ts.u32,20);
      {
        typedef __typeof__(*(&(channel_trigger_time_lo))) __array_t;
        typedef typename __array_t::item_t __item_t;
        __item_t &__item = channel_trigger_time_lo.insert_index(161,index);
        __item.value = channel_ts.chan_ts_lo;
      }
      if (__buffer.is_memberdump())
      {
        printf("%s%08" PRIx32 "%s: channel_ts ", CT_OUT(BOLD), channel_ts.u32, CT_OUT(NORM));
        printf(".chan_ts_lo=%s%8" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  channel_ts.chan_ts_lo, CT_OUT(NORM));
        printf("\n");
      }
      // UINT32 chan_enrgy NOENCODE
      // {
        //  0_23: chan_energy;
        // 24_29: TSF;
        //    30: pileup_flag;
        //    31: overflow_flag;
        // ENCODE(channel_cfd[index],(value=TSF));
        // ENCODE(channel_energy[index],(value=chan_energy));
        // ENCODE(pileup[index],(value=pileup_flag));
        // ENCODE(overflow[index],(value=overflow_flag));
      // }
      union
      {
        struct
        {
#if __BYTE_ORDER == __LITTLE_ENDIAN
          uint32 chan_energy : 24; // 0..23
          uint32 TSF : 6; // 24..29
          uint32 pileup_flag : 1; // 30
          uint32 overflow_flag : 1; // 31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
          uint32 overflow_flag : 1; // 31
          uint32 pileup_flag : 1; // 30
          uint32 TSF : 6; // 24..29
          uint32 chan_energy : 24; // 0..23
#endif
        };
        uint32  u32;
      } chan_enrgy;
      READ_FROM_BUFFER_FULL(173,uint32 ,chan_enrgy,chan_enrgy.u32,21);
      {
        {
          typedef __typeof__(*(&(channel_cfd))) __array_t;
          typedef typename __array_t::item_t __item_t;
          __item_t &__item = channel_cfd.insert_index(169,index);
          __item.value = chan_enrgy.TSF;
        }
        {
          typedef __typeof__(*(&(channel_energy))) __array_t;
          typedef typename __array_t::item_t __item_t;
          __item_t &__item = channel_energy.insert_index(170,index);
          __item.value = chan_enrgy.chan_energy;
        }
        {
          typedef __typeof__(*(&(pileup))) __array_t;
          typedef typename __array_t::item_t __item_t;
          __item_t &__item = pileup.insert_index(171,index);
          __item.value = chan_enrgy.pileup_flag;
        }
        {
          typedef __typeof__(*(&(overflow))) __array_t;
          typedef typename __array_t::item_t __item_t;
          __item_t &__item = overflow.insert_index(172,index);
          __item.value = chan_enrgy.overflow_flag;
        }
      }
      if (__buffer.is_memberdump())
      {
        printf("%s%08" PRIx32 "%s: chan_enrgy ", CT_OUT(BOLD), chan_enrgy.u32, CT_OUT(NORM));
        printf(".chan_energy=%s%6" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  chan_enrgy.chan_energy, CT_OUT(NORM));
        printf(".TSF=%s%2" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  chan_enrgy.TSF, CT_OUT(NORM));
        printf(".pileup_flag=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  chan_enrgy.pileup_flag, CT_OUT(NORM));
        printf(".overflow_flag=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  chan_enrgy.overflow_flag, CT_OUT(NORM));
        printf("\n");
      }
      // UINT32 future_use NOENCODE
      // {
        //  0_31: 0;
      // }
      union
      {
        struct
        {
#if __BYTE_ORDER == __LITTLE_ENDIAN
          uint32 unnamed_0_31 : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
          uint32 unnamed_0_31 : 32; // 0..31
#endif
        };
        uint32  u32;
      } future_use;
      READ_FROM_BUFFER_FULL(177,uint32 ,future_use,future_use.u32,22);
      CHECK_BITS_EQUAL(176,future_use.unnamed_0_31,0);
      if (__buffer.is_memberdump())
      {
        printf("%s%08" PRIx32 "%s: future_use ", CT_OUT(BOLD), future_use.u32, CT_OUT(NORM));
        printf("\n");
      }
    }
    // list(0<=i<16)

    for (uint32 i = 0; i < (uint32) (16); ++i)
    {
      // UINT32 header NOENCODE
      // {
        //  0_07: 52;
        //  8_23: other;
        // 24_31: ch_id;
      // }
      union
      {
        struct
        {
#if __BYTE_ORDER == __LITTLE_ENDIAN
          uint32 unnamed_0_7 : 8; // 0..7
          uint32 other : 16; // 8..23
          uint32 ch_id : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
          uint32 ch_id : 8; // 24..31
          uint32 other : 16; // 8..23
          uint32 unnamed_0_7 : 8; // 0..7
#endif
        };
        uint32  u32;
      } header;
      READ_FROM_BUFFER_FULL(186,uint32 ,header,header.u32,23);
      CHECK_BITS_EQUAL(183,header.unnamed_0_7,52);
      if (__buffer.is_memberdump())
      {
        printf("%s%08" PRIx32 "%s: header ", CT_OUT(BOLD), header.u32, CT_OUT(NORM));
        printf(".other=%s%4" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  header.other, CT_OUT(NORM));
        printf(".ch_id=%s%2" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  header.ch_id, CT_OUT(NORM));
        printf("\n");
      }
      // UINT32 tracesize NOENCODE
      // {
        //  0_31: size;
      // }
      union
      {
        struct
        {
#if __BYTE_ORDER == __LITTLE_ENDIAN
          uint32 size : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
          uint32 size : 32; // 0..31
#endif
        };
        uint32  u32;
      } tracesize;
      READ_FROM_BUFFER_FULL(190,uint32 ,tracesize,tracesize.u32,24);
      if (__buffer.is_memberdump())
      {
        printf("%s%08" PRIx32 "%s: tracesize ", CT_OUT(BOLD), tracesize.u32, CT_OUT(NORM));
        printf(".size=%s%8" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  tracesize.size, CT_OUT(NORM));
        printf("\n");
      }
      // UINT32 tracehead NOENCODE
      // {
        //  0_23: other;
        // 24_31: head;
      // }
      union
      {
        struct
        {
#if __BYTE_ORDER == __LITTLE_ENDIAN
          uint32 other : 24; // 0..23
          uint32 head : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
          uint32 head : 8; // 24..31
          uint32 other : 24; // 0..23
#endif
        };
        uint32  u32;
      } tracehead;
      READ_FROM_BUFFER_FULL(195,uint32 ,tracehead,tracehead.u32,25);
      if (__buffer.is_memberdump())
      {
        printf("%s%08" PRIx32 "%s: tracehead ", CT_OUT(BOLD), tracehead.u32, CT_OUT(NORM));
        printf(".other=%s%6" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  tracehead.other, CT_OUT(NORM));
        printf(".head=%s%2" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  tracehead.head, CT_OUT(NORM));
        printf("\n");
      }
      // list(0<=j<((tracesize.size / 4) - 2))

      for (uint32 j = 0; j < (uint32) (((tracesize.size / 4) - 2)); ++j)
      {
        // UINT32 channel_trace NOENCODE
        // {
          //  0_13: data1;
          // 14_15: stuff1;
          // 16_29: data2;
          // 30_31: stuff2;
          // ENCODE(traces[header.ch_id][((2 * j) + 0)],(value=data1));
          // ENCODE(traces[header.ch_id][((2 * j) + 1)],(value=data2));
        // }
        union
        {
          struct
          {
#if __BYTE_ORDER == __LITTLE_ENDIAN
            uint32 data1 : 14; // 0..13
            uint32 stuff1 : 2; // 14..15
            uint32 data2 : 14; // 16..29
            uint32 stuff2 : 2; // 30..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
            uint32 stuff2 : 2; // 30..31
            uint32 data2 : 14; // 16..29
            uint32 stuff1 : 2; // 14..15
            uint32 data1 : 14; // 0..13
#endif
          };
          uint32  u32;
        } channel_trace;
        READ_FROM_BUFFER_FULL(206,uint32 ,channel_trace,channel_trace.u32,26);
        {
          {
            typedef __typeof__(*(&(traces[header.ch_id]))) __array_t;
            typedef typename __array_t::item_t __item_t;
            __item_t &__item = traces[header.ch_id].insert_index(204,((2 * j) + 0));
            __item.value = channel_trace.data1;
          }
          {
            typedef __typeof__(*(&(traces[header.ch_id]))) __array_t;
            typedef typename __array_t::item_t __item_t;
            __item_t &__item = traces[header.ch_id].insert_index(205,((2 * j) + 1));
            __item.value = channel_trace.data2;
          }
        }
        if (__buffer.is_memberdump())
        {
          printf("%s%08" PRIx32 "%s: channel_trace ", CT_OUT(BOLD), channel_trace.u32, CT_OUT(NORM));
          printf(".data1=%s%4" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  channel_trace.data1, CT_OUT(NORM));
          printf(".stuff1=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  channel_trace.stuff1, CT_OUT(NORM));
          printf(".data2=%s%4" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  channel_trace.data2, CT_OUT(NORM));
          printf(".stuff2=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  channel_trace.stuff2, CT_OUT(NORM));
          printf("\n");
        }
      }
      // UINT32 trace_trailer NOENCODE
      // {
        //  0_23: notused;
        // 24_31: id = RANGE(176,191);
      // }
      union
      {
        struct
        {
#if __BYTE_ORDER == __LITTLE_ENDIAN
          uint32 notused : 24; // 0..23
          uint32 id : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
          uint32 id : 8; // 24..31
          uint32 notused : 24; // 0..23
#endif
        };
        uint32  u32;
      } trace_trailer;
      READ_FROM_BUFFER_FULL(212,uint32 ,trace_trailer,trace_trailer.u32,27);
      CHECK_BITS_RANGE(211,trace_trailer.id,176,191);
      if (__buffer.is_memberdump())
      {
        printf("%s%08" PRIx32 "%s: trace_trailer ", CT_OUT(BOLD), trace_trailer.u32, CT_OUT(NORM));
        printf(".notused=%s%6" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  trace_trailer.notused, CT_OUT(NORM));
        printf(".id=%s%2" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  trace_trailer.id, CT_OUT(NORM));
        printf("\n");
      }
    }
  }

  else
  {
    // if((sumchannel.trigger_type == 3))

    if ((sumchannel.trigger_type == 3))
    {
      // list(0<=i<16)

      for (uint32 i = 0; i < (uint32) (16); ++i)
      {
        // UINT32 header NOENCODE
        // {
          //  0_07: 52;
          //  8_23: other;
          // 24_31: ch_id;
        // }
        union
        {
          struct
          {
#if __BYTE_ORDER == __LITTLE_ENDIAN
            uint32 unnamed_0_7 : 8; // 0..7
            uint32 other : 16; // 8..23
            uint32 ch_id : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
            uint32 ch_id : 8; // 24..31
            uint32 other : 16; // 8..23
            uint32 unnamed_0_7 : 8; // 0..7
#endif
          };
          uint32  u32;
        } header;
        READ_FROM_BUFFER_FULL(226,uint32 ,header,header.u32,28);
        CHECK_BITS_EQUAL(223,header.unnamed_0_7,52);
        if (__buffer.is_memberdump())
        {
          printf("%s%08" PRIx32 "%s: header ", CT_OUT(BOLD), header.u32, CT_OUT(NORM));
          printf(".other=%s%4" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  header.other, CT_OUT(NORM));
          printf(".ch_id=%s%2" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  header.ch_id, CT_OUT(NORM));
          printf("\n");
        }
        // UINT32 tracesize NOENCODE
        // {
          //  0_31: size;
        // }
        union
        {
          struct
          {
#if __BYTE_ORDER == __LITTLE_ENDIAN
            uint32 size : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
            uint32 size : 32; // 0..31
#endif
          };
          uint32  u32;
        } tracesize;
        READ_FROM_BUFFER_FULL(230,uint32 ,tracesize,tracesize.u32,29);
        if (__buffer.is_memberdump())
        {
          printf("%s%08" PRIx32 "%s: tracesize ", CT_OUT(BOLD), tracesize.u32, CT_OUT(NORM));
          printf(".size=%s%8" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  tracesize.size, CT_OUT(NORM));
          printf("\n");
        }
        // UINT32 tracehead NOENCODE
        // {
          //  0_23: other;
          // 24_31: head;
        // }
        union
        {
          struct
          {
#if __BYTE_ORDER == __LITTLE_ENDIAN
            uint32 other : 24; // 0..23
            uint32 head : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
            uint32 head : 8; // 24..31
            uint32 other : 24; // 0..23
#endif
          };
          uint32  u32;
        } tracehead;
        READ_FROM_BUFFER_FULL(235,uint32 ,tracehead,tracehead.u32,30);
        if (__buffer.is_memberdump())
        {
          printf("%s%08" PRIx32 "%s: tracehead ", CT_OUT(BOLD), tracehead.u32, CT_OUT(NORM));
          printf(".other=%s%6" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  tracehead.other, CT_OUT(NORM));
          printf(".head=%s%2" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  tracehead.head, CT_OUT(NORM));
          printf("\n");
        }
        // UINT32 trace_trailer NOENCODE
        // {
          //  0_23: notused;
          // 24_31: id = RANGE(176,191);
        // }
        union
        {
          struct
          {
#if __BYTE_ORDER == __LITTLE_ENDIAN
            uint32 notused : 24; // 0..23
            uint32 id : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
            uint32 id : 8; // 24..31
            uint32 notused : 24; // 0..23
#endif
          };
          uint32  u32;
        } trace_trailer;
        READ_FROM_BUFFER_FULL(240,uint32 ,trace_trailer,trace_trailer.u32,31);
        CHECK_BITS_RANGE(239,trace_trailer.id,176,191);
        if (__buffer.is_memberdump())
        {
          printf("%s%08" PRIx32 "%s: trace_trailer ", CT_OUT(BOLD), trace_trailer.u32, CT_OUT(NORM));
          printf(".notused=%s%6" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  trace_trailer.notused, CT_OUT(NORM));
          printf(".id=%s%2" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  trace_trailer.id, CT_OUT(NORM));
          printf("\n");
        }
      }
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,FEBEX_EVENT_TRACES::__unpack,uint32 card);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for FEBEX_EVENT_TRACES.
 *
 * Do not edit - automatically generated.
 */

// FEBEX_EVENT_TRACES(card)
template<typename __data_src_t>
bool FEBEX_EVENT_TRACES::__match(__data_src_t &__buffer,uint32 card)
{
  // MEMBER(DATA32 event_trigger_time_hi);
  // MEMBER(DATA32 event_trigger_time_lo);
  // MEMBER(DATA16 hit_pattern);
  // MEMBER(DATA32 num_channels_fired);
  // MEMBER(DATA8 channel_id[16] ZERO_SUPPRESS);
  // MEMBER(DATA16 channel_trigger_time_hi[16] ZERO_SUPPRESS);
  // MEMBER(DATA32 channel_trigger_time_lo[16] ZERO_SUPPRESS);
  // MEMBER(DATA8 pileup[16]);
  // MEMBER(DATA8 overflow[16]);
  // MEMBER(DATA8 channel_cfd[16] ZERO_SUPPRESS);
  // MEMBER(DATA32 channel_energy[16] ZERO_SUPPRESS);
  // MEMBER(DATA16 traces[16][10000] ZERO_SUPPRESS);
  // UINT32 sumchannel NOENCODE
  // {
    //  0_07: 52;
    //  8_11: trigger_type;
    // 12_15: sfpnr;
    // 16_23: board_id = MATCH(card);
    // 24_31: 255;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 unnamed_0_7 : 8; // 0..7
      uint32 trigger_type : 4; // 8..11
      uint32 sfpnr : 4; // 12..15
      uint32 board_id : 8; // 16..23
      uint32 unnamed_24_31 : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_24_31 : 8; // 24..31
      uint32 board_id : 8; // 16..23
      uint32 sfpnr : 4; // 12..15
      uint32 trigger_type : 4; // 8..11
      uint32 unnamed_0_7 : 8; // 0..7
#endif
    };
    uint32  u32;
  } sumchannel;
  MATCH_READ_FROM_BUFFER_FULL(118,uint32 ,sumchannel,sumchannel.u32,32);
  MATCH_BITS_EQUAL(113,sumchannel.unnamed_0_7,52);
  MATCH_BITS_EQUAL(116,sumchannel.board_id,card);
  MATCH_BITS_EQUAL(117,sumchannel.unnamed_24_31,255);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,FEBEX_EVENT_TRACES::__match,uint32 card);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for FEBEX_EVENT_TRACES.
 *
 * Do not edit - automatically generated.
 */

// FEBEX_EVENT_TRACES(card)
template<typename __data_dest_t>
void PACKER_FEBEX_EVENT_TRACES::__packer(__data_dest_t &__buffer,uint32 card)
{
  // MEMBER(DATA32 event_trigger_time_hi);
  // MEMBER(DATA32 event_trigger_time_lo);
  // MEMBER(DATA16 hit_pattern);
  // MEMBER(DATA32 num_channels_fired);
  // MEMBER(DATA8 channel_id[16] ZERO_SUPPRESS);
  // MEMBER(DATA16 channel_trigger_time_hi[16] ZERO_SUPPRESS);
  // MEMBER(DATA32 channel_trigger_time_lo[16] ZERO_SUPPRESS);
  // MEMBER(DATA8 pileup[16]);
  // MEMBER(DATA8 overflow[16]);
  // MEMBER(DATA8 channel_cfd[16] ZERO_SUPPRESS);
  // MEMBER(DATA32 channel_energy[16] ZERO_SUPPRESS);
  // MEMBER(DATA16 traces[16][10000] ZERO_SUPPRESS);
  // UINT32 sumchannel NOENCODE
  // {
    //  0_07: 52;
    //  8_11: trigger_type;
    // 12_15: sfpnr;
    // 16_23: board_id = MATCH(card);
    // 24_31: 255;
  // }
  // UINT32 channel_size NOENCODE
  // {
    //  0_01: ignore;
    //  2_31: size;
    // ENCODE(num_channels_fired,(value=((size / 4) - 1)));
  // }
  // UINT32 event_timestamp_hi NOENCODE
  // {
    //  0_15: timestamp_hi;
    // 16_31: ignore;
    // ENCODE(event_trigger_time_hi,(value=timestamp_hi));
  // }
  // UINT32 event_timestamp_lo NOENCODE
  // {
    //  0_31: timestamp_lo;
    // ENCODE(event_trigger_time_lo,(value=timestamp_lo));
  // }
  // UINT32 hp NOENCODE
  // {
    //  0_15: hp;
    // 16_31: ignore;
    // ENCODE(hit_pattern,(value=hp));
  // }
  // UINT32 deadbeef NOENCODE
  // {
    //  0_31: 0xdeadbeef;
  // }
  // if((sumchannel.trigger_type == 1))

  // else

  if ((sumchannel.trigger_type == 1))
  {
    // list(0<=index<((channel_size.size / 4) - 1))

    {
      // UINT32 channelids NOENCODE
      // {
        //  0_15: chan_ts_hi;
        // 16_23: channel_id_bits;
        // 24_31: 240;
        // ENCODE(channel_id[index],(value=channel_id_bits));
        // ENCODE(channel_trigger_time_hi[index],(value=chan_ts_hi));
      // }
      // UINT32 channel_ts NOENCODE
      // {
        //  0_31: chan_ts_lo;
        // ENCODE(channel_trigger_time_lo[index],(value=chan_ts_lo));
      // }
      // UINT32 chan_enrgy NOENCODE
      // {
        //  0_23: chan_energy;
        // 24_29: TSF;
        //    30: pileup_flag;
        //    31: overflow_flag;
        // ENCODE(channel_cfd[index],(value=TSF));
        // ENCODE(channel_energy[index],(value=chan_energy));
        // ENCODE(pileup[index],(value=pileup_flag));
        // ENCODE(overflow[index],(value=overflow_flag));
      // }
      // UINT32 future_use NOENCODE
      // {
        //  0_31: 0;
      // }
    }
    // list(0<=i<16)

    {
      // UINT32 header NOENCODE
      // {
        //  0_07: 52;
        //  8_23: other;
        // 24_31: ch_id;
      // }
      // UINT32 tracesize NOENCODE
      // {
        //  0_31: size;
      // }
      // UINT32 tracehead NOENCODE
      // {
        //  0_23: other;
        // 24_31: head;
      // }
      // list(0<=j<((tracesize.size / 4) - 2))

      {
        // UINT32 channel_trace NOENCODE
        // {
          //  0_13: data1;
          // 14_15: stuff1;
          // 16_29: data2;
          // 30_31: stuff2;
          // ENCODE(traces[header.ch_id][((2 * j) + 0)],(value=data1));
          // ENCODE(traces[header.ch_id][((2 * j) + 1)],(value=data2));
        // }
      }
      // UINT32 trace_trailer NOENCODE
      // {
        //  0_23: notused;
        // 24_31: id = RANGE(176,191);
      // }
    }
  }

  else
  {
    // if((sumchannel.trigger_type == 3))

    if ((sumchannel.trigger_type == 3))
    {
      // list(0<=i<16)

      {
        // UINT32 header NOENCODE
        // {
          //  0_07: 52;
          //  8_23: other;
          // 24_31: ch_id;
        // }
        // UINT32 tracesize NOENCODE
        // {
          //  0_31: size;
        // }
        // UINT32 tracehead NOENCODE
        // {
          //  0_23: other;
          // 24_31: head;
        // }
        // UINT32 trace_trailer NOENCODE
        // {
          //  0_23: notused;
          // 24_31: id = RANGE(176,191);
        // }
      }
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,FEBEX_EVENT_TRACES::__packer,uint32 card);

/** END_PACKER ********************************************************/

//
// Generating code for: FEBEX_PADDING
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for FEBEX_PADDING.
 *
 * Do not edit - automatically generated.
 */

// FEBEX_PADDING()
#if !PACKER_CODE
# define DECLARED_UNPACK_FEBEX_PADDING
class FEBEX_PADDING
#else//PACKER_CODE
# define DECLARED_PACKER_FEBEX_PADDING
class PACKER_FEBEX_PADDING
#endif//PACKER_CODE

{
public:
  // UINT32 pads_data NOENCODE
  // {
    //  0_11: counter;
    // 12_19: index;
    // 20_31: 0xadd;
  // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(FEBEX_PADDING);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for FEBEX_PADDING.
 *
 * Do not edit - automatically generated.
 */

// FEBEX_PADDING()
template<typename __data_src_t>
void FEBEX_PADDING::__unpack(__data_src_t &__buffer)
{
  if (__buffer.is_memberdump())
  {
    printf("          %s%s%s: \n", CT_OUT(BOLD_BLUE),  "FEBEX_PADDING",CT_OUT(NORM));
  }
  // UINT32 pads_data NOENCODE
  // {
    //  0_11: counter;
    // 12_19: index;
    // 20_31: 0xadd;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 counter : 12; // 0..11
      uint32 index : 8; // 12..19
      uint32 unnamed_20_31 : 12; // 20..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_20_31 : 12; // 20..31
      uint32 index : 8; // 12..19
      uint32 counter : 12; // 0..11
#endif
    };
    uint32  u32;
  } pads_data;
  READ_FROM_BUFFER_FULL(253,uint32 ,pads_data,pads_data.u32,33);
  CHECK_BITS_EQUAL(252,pads_data.unnamed_20_31,0xadd);
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: pads_data ", CT_OUT(BOLD), pads_data.u32, CT_OUT(NORM));
    printf(".counter=%s%3" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  pads_data.counter, CT_OUT(NORM));
    printf(".index=%s%2" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  pads_data.index, CT_OUT(NORM));
    printf("\n");
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,FEBEX_PADDING::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for FEBEX_PADDING.
 *
 * Do not edit - automatically generated.
 */

// FEBEX_PADDING()
template<typename __data_src_t>
bool FEBEX_PADDING::__match(__data_src_t &__buffer)
{
  // UINT32 pads_data NOENCODE
  // {
    //  0_11: counter;
    // 12_19: index;
    // 20_31: 0xadd;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 counter : 12; // 0..11
      uint32 index : 8; // 12..19
      uint32 unnamed_20_31 : 12; // 20..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_20_31 : 12; // 20..31
      uint32 index : 8; // 12..19
      uint32 counter : 12; // 0..11
#endif
    };
    uint32  u32;
  } pads_data;
  MATCH_READ_FROM_BUFFER_FULL(253,uint32 ,pads_data,pads_data.u32,34);
  MATCH_BITS_EQUAL(252,pads_data.unnamed_20_31,0xadd);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN(bool,FEBEX_PADDING::__match);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for FEBEX_PADDING.
 *
 * Do not edit - automatically generated.
 */

// FEBEX_PADDING()
template<typename __data_dest_t>
void PACKER_FEBEX_PADDING::__packer(__data_dest_t &__buffer)
{
  // UINT32 pads_data NOENCODE
  // {
    //  0_11: counter;
    // 12_19: index;
    // 20_31: 0xadd;
  // }
}
FORCE_IMPL_DATA_SRC_FCN(void,FEBEX_PADDING::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: MAIN_CRATE_DATA
//
//
// Generating code for: VME_CAEN_V830_FRS
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for VME_CAEN_V830_FRS.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V830_FRS()
#if !PACKER_CODE
# define DECLARED_UNPACK_VME_CAEN_V830_FRS
class VME_CAEN_V830_FRS
#else//PACKER_CODE
# define DECLARED_PACKER_VME_CAEN_V830_FRS
class PACKER_VME_CAEN_V830_FRS
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA32 data[32] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA32,DATA32,32> data;
  // UINT32 v830_header NOENCODE
  // {
    //  0_15: trigger_number;
    // 16_17: ts;
    // 18_23: nwords;
    // 24_25: unused;
    //    26: 1;
    // 27_31: geo;
  // }
  // list(0<=i<v830_header.nwords)

    // UINT32 data_word NOENCODE
    // {
      //  0_31: value;
      // ENCODE(data[i],(value=value));
    // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(VME_CAEN_V830_FRS);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for VME_CAEN_V830_FRS.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V830_FRS()
template<typename __data_src_t>
void VME_CAEN_V830_FRS::__unpack(__data_src_t &__buffer)
{
  if (__buffer.is_memberdump())
  {
    printf("          %s%s%s: \n", CT_OUT(BOLD_BLUE),  "VME_CAEN_V830_FRS",CT_OUT(NORM));
  }
  // MEMBER(DATA32 data[32] ZERO_SUPPRESS);
  // UINT32 v830_header NOENCODE
  // {
    //  0_15: trigger_number;
    // 16_17: ts;
    // 18_23: nwords;
    // 24_25: unused;
    //    26: 1;
    // 27_31: geo;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 trigger_number : 16; // 0..15
      uint32 ts : 2; // 16..17
      uint32 nwords : 6; // 18..23
      uint32 unused : 2; // 24..25
      uint32 unnamed_26_26 : 1; // 26
      uint32 geo : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 geo : 5; // 27..31
      uint32 unnamed_26_26 : 1; // 26
      uint32 unused : 2; // 24..25
      uint32 nwords : 6; // 18..23
      uint32 ts : 2; // 16..17
      uint32 trigger_number : 16; // 0..15
#endif
    };
    uint32  u32;
  } v830_header;
  READ_FROM_BUFFER_FULL(912,uint32 ,v830_header,v830_header.u32,35);
  CHECK_BITS_EQUAL(910,v830_header.unnamed_26_26,1);
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: v830_header ", CT_OUT(BOLD), v830_header.u32, CT_OUT(NORM));
    printf(".trigger_number=%s%4" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  v830_header.trigger_number, CT_OUT(NORM));
    printf(".ts=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  v830_header.ts, CT_OUT(NORM));
    printf(".nwords=%s%2" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  v830_header.nwords, CT_OUT(NORM));
    printf(".unused=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  v830_header.unused, CT_OUT(NORM));
    printf(".geo=%s%2" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  v830_header.geo, CT_OUT(NORM));
    printf("\n");
  }
  // list(0<=i<v830_header.nwords)

  for (uint32 i = 0; i < (uint32) (v830_header.nwords); ++i)
  {
    // UINT32 data_word NOENCODE
    // {
      //  0_31: value;
      // ENCODE(data[i],(value=value));
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 value : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 value : 32; // 0..31
#endif
      };
      uint32  u32;
    } data_word;
    READ_FROM_BUFFER_FULL(919,uint32 ,data_word,data_word.u32,36);
    {
      typedef __typeof__(*(&(data))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = data.insert_index(918,i);
      __item.value = data_word.value;
    }
    if (__buffer.is_memberdump())
    {
      printf("%s%08" PRIx32 "%s: data_word ", CT_OUT(BOLD), data_word.u32, CT_OUT(NORM));
      printf(".value=%s%8" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  data_word.value, CT_OUT(NORM));
      printf("\n");
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,VME_CAEN_V830_FRS::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for VME_CAEN_V830_FRS.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V830_FRS()
template<typename __data_src_t>
bool VME_CAEN_V830_FRS::__match(__data_src_t &__buffer)
{
  // MEMBER(DATA32 data[32] ZERO_SUPPRESS);
  // UINT32 v830_header NOENCODE
  // {
    //  0_15: trigger_number;
    // 16_17: ts;
    // 18_23: nwords;
    // 24_25: unused;
    //    26: 1;
    // 27_31: geo;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 trigger_number : 16; // 0..15
      uint32 ts : 2; // 16..17
      uint32 nwords : 6; // 18..23
      uint32 unused : 2; // 24..25
      uint32 unnamed_26_26 : 1; // 26
      uint32 geo : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 geo : 5; // 27..31
      uint32 unnamed_26_26 : 1; // 26
      uint32 unused : 2; // 24..25
      uint32 nwords : 6; // 18..23
      uint32 ts : 2; // 16..17
      uint32 trigger_number : 16; // 0..15
#endif
    };
    uint32  u32;
  } v830_header;
  MATCH_READ_FROM_BUFFER_FULL(912,uint32 ,v830_header,v830_header.u32,37);
  MATCH_BITS_EQUAL(910,v830_header.unnamed_26_26,1);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN(bool,VME_CAEN_V830_FRS::__match);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for VME_CAEN_V830_FRS.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V830_FRS()
template<typename __data_dest_t>
void PACKER_VME_CAEN_V830_FRS::__packer(__data_dest_t &__buffer)
{
  // MEMBER(DATA32 data[32] ZERO_SUPPRESS);
  // UINT32 v830_header NOENCODE
  // {
    //  0_15: trigger_number;
    // 16_17: ts;
    // 18_23: nwords;
    // 24_25: unused;
    //    26: 1;
    // 27_31: geo;
  // }
  // list(0<=i<v830_header.nwords)

  {
    // UINT32 data_word NOENCODE
    // {
      //  0_31: value;
      // ENCODE(data[i],(value=value));
    // }
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,VME_CAEN_V830_FRS::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: ZERO_FILLER
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for ZERO_FILLER.
 *
 * Do not edit - automatically generated.
 */

// ZERO_FILLER()
#if !PACKER_CODE
# define DECLARED_UNPACK_ZERO_FILLER
class ZERO_FILLER
#else//PACKER_CODE
# define DECLARED_PACKER_ZERO_FILLER
class PACKER_ZERO_FILLER
#endif//PACKER_CODE

{
public:
  // UINT32 filler NOENCODE
  // {
    //  0_31: zero = MATCH(0);
  // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(ZERO_FILLER);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for ZERO_FILLER.
 *
 * Do not edit - automatically generated.
 */

// ZERO_FILLER()
template<typename __data_src_t>
void ZERO_FILLER::__unpack(__data_src_t &__buffer)
{
  if (__buffer.is_memberdump())
  {
    printf("          %s%s%s: \n", CT_OUT(BOLD_BLUE),  "ZERO_FILLER",CT_OUT(NORM));
  }
  // UINT32 filler NOENCODE
  // {
    //  0_31: zero = MATCH(0);
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 zero : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 zero : 32; // 0..31
#endif
    };
    uint32  u32;
  } filler;
  READ_FROM_BUFFER_FULL(944,uint32 ,filler,filler.u32,38);
  CHECK_BITS_EQUAL(943,filler.zero,0);
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: filler ", CT_OUT(BOLD), filler.u32, CT_OUT(NORM));
    printf(".zero=%s%8" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  filler.zero, CT_OUT(NORM));
    printf("\n");
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,ZERO_FILLER::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for ZERO_FILLER.
 *
 * Do not edit - automatically generated.
 */

// ZERO_FILLER()
template<typename __data_src_t>
bool ZERO_FILLER::__match(__data_src_t &__buffer)
{
  // UINT32 filler NOENCODE
  // {
    //  0_31: zero = MATCH(0);
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 zero : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 zero : 32; // 0..31
#endif
    };
    uint32  u32;
  } filler;
  MATCH_READ_FROM_BUFFER_FULL(944,uint32 ,filler,filler.u32,39);
  MATCH_BITS_EQUAL(943,filler.zero,0);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN(bool,ZERO_FILLER::__match);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for ZERO_FILLER.
 *
 * Do not edit - automatically generated.
 */

// ZERO_FILLER()
template<typename __data_dest_t>
void PACKER_ZERO_FILLER::__packer(__data_dest_t &__buffer)
{
  // UINT32 filler NOENCODE
  // {
    //  0_31: zero = MATCH(0);
  // }
}
FORCE_IMPL_DATA_SRC_FCN(void,ZERO_FILLER::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: VME_CAEN_V792_FRS
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for VME_CAEN_V792_FRS.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V792_FRS()
#if !PACKER_CODE
# define DECLARED_UNPACK_VME_CAEN_V792_FRS
class VME_CAEN_V792_FRS
#else//PACKER_CODE
# define DECLARED_PACKER_VME_CAEN_V792_FRS
class PACKER_VME_CAEN_V792_FRS
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA32 data[32] ZERO_SUPPRESS_MULTI(32));
  raw_array_multi_zero_suppress<DATA32,DATA32,32,32> data;
  // MEMBER(DATA8 geo);
  DATA8 geo;
  // UINT32 v792_header NOENCODE
  // {
    //  0_07: unused;
    //  8_13: cnt;
    // 14_15: 0;
    // 16_23: crate;
    // 24_26: 2;
    // 27_31: geo;
    // ENCODE(geo,(value=geo));
  // }
  // several UINT32 adc_data NOENCODE
  // {
    //  0_11: adc;
    //    12: overflow;
    //    13: underthreshold;
    // 14_15: unused;
    // 16_20: channel;
    // 21_23: unused2;
    // 24_26: 0;
    // 27_31: geo;
    // ENCODE(data[channel],(value=adc));
  // }
  // UINT32 eob NOENCODE
  // {
    //  0_23: nothing;
    // 24_26: 4;
    // 27_31: geom;
  // }
  // list(0<=i<2)

    // optional UINT32 eob2 NOENCODE
    // {
      //  0_23: nothing;
      // 24_26: id = MATCH(6);
      // 27_31: geom;
    // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(VME_CAEN_V792_FRS);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for VME_CAEN_V792_FRS.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V792_FRS()
template<typename __data_src_t>
void VME_CAEN_V792_FRS::__unpack(__data_src_t &__buffer)
{
  if (__buffer.is_memberdump())
  {
    printf("          %s%s%s: \n", CT_OUT(BOLD_BLUE),  "VME_CAEN_V792_FRS",CT_OUT(NORM));
  }
  // MEMBER(DATA32 data[32] ZERO_SUPPRESS_MULTI(32));
  // MEMBER(DATA8 geo);
  // UINT32 v792_header NOENCODE
  // {
    //  0_07: unused;
    //  8_13: cnt;
    // 14_15: 0;
    // 16_23: crate;
    // 24_26: 2;
    // 27_31: geo;
    // ENCODE(geo,(value=geo));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 unused : 8; // 0..7
      uint32 cnt : 6; // 8..13
      uint32 unnamed_14_15 : 2; // 14..15
      uint32 crate : 8; // 16..23
      uint32 unnamed_24_26 : 3; // 24..26
      uint32 geo : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 geo : 5; // 27..31
      uint32 unnamed_24_26 : 3; // 24..26
      uint32 crate : 8; // 16..23
      uint32 unnamed_14_15 : 2; // 14..15
      uint32 cnt : 6; // 8..13
      uint32 unused : 8; // 0..7
#endif
    };
    uint32  u32;
  } v792_header;
  READ_FROM_BUFFER_FULL(823,uint32 ,v792_header,v792_header.u32,40);
  CHECK_BITS_EQUAL(818,v792_header.unnamed_14_15,0);
  CHECK_BITS_EQUAL(820,v792_header.unnamed_24_26,2);
  {
    geo.value = v792_header.geo;
  }
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: v792_header ", CT_OUT(BOLD), v792_header.u32, CT_OUT(NORM));
    printf(".unused=%s%2" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  v792_header.unused, CT_OUT(NORM));
    printf(".cnt=%s%2" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  v792_header.cnt, CT_OUT(NORM));
    printf(".crate=%s%2" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  v792_header.crate, CT_OUT(NORM));
    printf(".geo=%s%2" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  v792_header.geo, CT_OUT(NORM));
    printf("\n");
  }
  // several UINT32 adc_data NOENCODE
  // {
    //  0_11: adc;
    //    12: overflow;
    //    13: underthreshold;
    // 14_15: unused;
    // 16_20: channel;
    // 21_23: unused2;
    // 24_26: 0;
    // 27_31: geo;
    // ENCODE(data[channel],(value=adc));
  // }
  for ( ; ; ) {
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 adc : 12; // 0..11
      uint32 overflow : 1; // 12
      uint32 underthreshold : 1; // 13
      uint32 unused : 2; // 14..15
      uint32 channel : 5; // 16..20
      uint32 unused2 : 3; // 21..23
      uint32 unnamed_24_26 : 3; // 24..26
      uint32 geo : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 geo : 5; // 27..31
      uint32 unnamed_24_26 : 3; // 24..26
      uint32 unused2 : 3; // 21..23
      uint32 channel : 5; // 16..20
      uint32 unused : 2; // 14..15
      uint32 underthreshold : 1; // 13
      uint32 overflow : 1; // 12
      uint32 adc : 12; // 0..11
#endif
    };
    uint32  u32;
  } adc_data;
  if (__buffer.empty()) goto data_done_0;
  PEEK_FROM_BUFFER_FULL(835,uint32 ,adc_data,adc_data.u32,41);
  CHECK_JUMP_BITS_EQUAL(832,adc_data.unnamed_24_26,0,data_done_0);
  __buffer.advance(sizeof(adc_data.u32));
  {
    typedef __typeof__(*(&(data))) __array_t;
    typedef typename __array_t::item_t __item_t;
    __item_t &__item = data.insert_index(834,adc_data.channel);
    __item.value = adc_data.adc;
  }
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: adc_data ", CT_OUT(BOLD), adc_data.u32, CT_OUT(NORM));
    printf(".adc=%s%3" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  adc_data.adc, CT_OUT(NORM));
    printf(".overflow=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  adc_data.overflow, CT_OUT(NORM));
    printf(".underthreshold=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  adc_data.underthreshold, CT_OUT(NORM));
    printf(".unused=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  adc_data.unused, CT_OUT(NORM));
    printf(".channel=%s%2" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  adc_data.channel, CT_OUT(NORM));
    printf(".unused2=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  adc_data.unused2, CT_OUT(NORM));
    printf(".geo=%s%2" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  adc_data.geo, CT_OUT(NORM));
    printf("\n");
  }
  }
  data_done_0:;
  // UINT32 eob NOENCODE
  // {
    //  0_23: nothing;
    // 24_26: 4;
    // 27_31: geom;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 nothing : 24; // 0..23
      uint32 unnamed_24_26 : 3; // 24..26
      uint32 geom : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 geom : 5; // 27..31
      uint32 unnamed_24_26 : 3; // 24..26
      uint32 nothing : 24; // 0..23
#endif
    };
    uint32  u32;
  } eob;
  READ_FROM_BUFFER_FULL(841,uint32 ,eob,eob.u32,42);
  CHECK_BITS_EQUAL(839,eob.unnamed_24_26,4);
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: eob ", CT_OUT(BOLD), eob.u32, CT_OUT(NORM));
    printf(".nothing=%s%6" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  eob.nothing, CT_OUT(NORM));
    printf(".geom=%s%2" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  eob.geom, CT_OUT(NORM));
    printf("\n");
  }
  // list(0<=i<2)

  for (uint32 i = 0; i < (uint32) (2); ++i)
  {
    // optional UINT32 eob2 NOENCODE
    // {
      //  0_23: nothing;
      // 24_26: id = MATCH(6);
      // 27_31: geom;
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 nothing : 24; // 0..23
        uint32 id : 3; // 24..26
        uint32 geom : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 geom : 5; // 27..31
        uint32 id : 3; // 24..26
        uint32 nothing : 24; // 0..23
#endif
      };
      uint32  u32;
    } eob2;
    if (__buffer.empty()) goto data_done_1;
    PEEK_FROM_BUFFER_FULL(849,uint32 ,eob2,eob2.u32,43);
    CHECK_JUMP_BITS_EQUAL(847,eob2.id,6,data_done_1);
    __buffer.advance(sizeof(eob2.u32));
    if (__buffer.is_memberdump())
    {
      printf("%s%08" PRIx32 "%s: eob2 ", CT_OUT(BOLD), eob2.u32, CT_OUT(NORM));
      printf(".nothing=%s%6" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  eob2.nothing, CT_OUT(NORM));
      printf(".id=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  eob2.id, CT_OUT(NORM));
      printf(".geom=%s%2" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  eob2.geom, CT_OUT(NORM));
      printf("\n");
    }
    data_done_1:;
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,VME_CAEN_V792_FRS::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for VME_CAEN_V792_FRS.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V792_FRS()
template<typename __data_src_t>
bool VME_CAEN_V792_FRS::__match(__data_src_t &__buffer)
{
  // MEMBER(DATA32 data[32] ZERO_SUPPRESS_MULTI(32));
  // MEMBER(DATA8 geo);
  // UINT32 v792_header NOENCODE
  // {
    //  0_07: unused;
    //  8_13: cnt;
    // 14_15: 0;
    // 16_23: crate;
    // 24_26: 2;
    // 27_31: geo;
    // ENCODE(geo,(value=geo));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 unused : 8; // 0..7
      uint32 cnt : 6; // 8..13
      uint32 unnamed_14_15 : 2; // 14..15
      uint32 crate : 8; // 16..23
      uint32 unnamed_24_26 : 3; // 24..26
      uint32 geo : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 geo : 5; // 27..31
      uint32 unnamed_24_26 : 3; // 24..26
      uint32 crate : 8; // 16..23
      uint32 unnamed_14_15 : 2; // 14..15
      uint32 cnt : 6; // 8..13
      uint32 unused : 8; // 0..7
#endif
    };
    uint32  u32;
  } v792_header;
  MATCH_READ_FROM_BUFFER_FULL(823,uint32 ,v792_header,v792_header.u32,44);
  MATCH_BITS_EQUAL(818,v792_header.unnamed_14_15,0);
  MATCH_BITS_EQUAL(820,v792_header.unnamed_24_26,2);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN(bool,VME_CAEN_V792_FRS::__match);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for VME_CAEN_V792_FRS.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V792_FRS()
template<typename __data_dest_t>
void PACKER_VME_CAEN_V792_FRS::__packer(__data_dest_t &__buffer)
{
  // MEMBER(DATA32 data[32] ZERO_SUPPRESS_MULTI(32));
  // MEMBER(DATA8 geo);
  // UINT32 v792_header NOENCODE
  // {
    //  0_07: unused;
    //  8_13: cnt;
    // 14_15: 0;
    // 16_23: crate;
    // 24_26: 2;
    // 27_31: geo;
    // ENCODE(geo,(value=geo));
  // }
  // several UINT32 adc_data NOENCODE
  // {
    //  0_11: adc;
    //    12: overflow;
    //    13: underthreshold;
    // 14_15: unused;
    // 16_20: channel;
    // 21_23: unused2;
    // 24_26: 0;
    // 27_31: geo;
    // ENCODE(data[channel],(value=adc));
  // }
  // UINT32 eob NOENCODE
  // {
    //  0_23: nothing;
    // 24_26: 4;
    // 27_31: geom;
  // }
  // list(0<=i<2)

  {
    // optional UINT32 eob2 NOENCODE
    // {
      //  0_23: nothing;
      // 24_26: id = MATCH(6);
      // 27_31: geom;
    // }
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,VME_CAEN_V792_FRS::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: VME_CAEN_V1290_FRS
//
//
// Generating code for: TDC_HEADER
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for TDC_HEADER.
 *
 * Do not edit - automatically generated.
 */

// TDC_HEADER()
#if !PACKER_CODE
# define DECLARED_UNPACK_TDC_HEADER
class TDC_HEADER
#else//PACKER_CODE
# define DECLARED_PACKER_TDC_HEADER
class PACKER_TDC_HEADER
#endif//PACKER_CODE

{
public:
  // UINT32 tdc_header NOENCODE
  // {
    //  0_11: bunch_id;
    // 12_23: event_id;
    // 24_25: tdc;
    //    26: unused;
    // 27_31: 1;
  // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(TDC_HEADER);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for TDC_HEADER.
 *
 * Do not edit - automatically generated.
 */

// TDC_HEADER()
template<typename __data_src_t>
void TDC_HEADER::__unpack(__data_src_t &__buffer)
{
  if (__buffer.is_memberdump())
  {
    printf("          %s%s%s: \n", CT_OUT(BOLD_BLUE),  "TDC_HEADER",CT_OUT(NORM));
  }
  // UINT32 tdc_header NOENCODE
  // {
    //  0_11: bunch_id;
    // 12_23: event_id;
    // 24_25: tdc;
    //    26: unused;
    // 27_31: 1;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 bunch_id : 12; // 0..11
      uint32 event_id : 12; // 12..23
      uint32 tdc : 2; // 24..25
      uint32 unused : 1; // 26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 unused : 1; // 26
      uint32 tdc : 2; // 24..25
      uint32 event_id : 12; // 12..23
      uint32 bunch_id : 12; // 0..11
#endif
    };
    uint32  u32;
  } tdc_header;
  READ_FROM_BUFFER_FULL(546,uint32 ,tdc_header,tdc_header.u32,45);
  CHECK_BITS_EQUAL(545,tdc_header.unnamed_27_31,1);
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: tdc_header ", CT_OUT(BOLD), tdc_header.u32, CT_OUT(NORM));
    printf(".bunch_id=%s%3" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  tdc_header.bunch_id, CT_OUT(NORM));
    printf(".event_id=%s%3" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  tdc_header.event_id, CT_OUT(NORM));
    printf(".tdc=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  tdc_header.tdc, CT_OUT(NORM));
    printf(".unused=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  tdc_header.unused, CT_OUT(NORM));
    printf("\n");
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,TDC_HEADER::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for TDC_HEADER.
 *
 * Do not edit - automatically generated.
 */

// TDC_HEADER()
template<typename __data_src_t>
bool TDC_HEADER::__match(__data_src_t &__buffer)
{
  // UINT32 tdc_header NOENCODE
  // {
    //  0_11: bunch_id;
    // 12_23: event_id;
    // 24_25: tdc;
    //    26: unused;
    // 27_31: 1;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 bunch_id : 12; // 0..11
      uint32 event_id : 12; // 12..23
      uint32 tdc : 2; // 24..25
      uint32 unused : 1; // 26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 unused : 1; // 26
      uint32 tdc : 2; // 24..25
      uint32 event_id : 12; // 12..23
      uint32 bunch_id : 12; // 0..11
#endif
    };
    uint32  u32;
  } tdc_header;
  MATCH_READ_FROM_BUFFER_FULL(546,uint32 ,tdc_header,tdc_header.u32,46);
  MATCH_BITS_EQUAL(545,tdc_header.unnamed_27_31,1);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN(bool,TDC_HEADER::__match);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for TDC_HEADER.
 *
 * Do not edit - automatically generated.
 */

// TDC_HEADER()
template<typename __data_dest_t>
void PACKER_TDC_HEADER::__packer(__data_dest_t &__buffer)
{
  // UINT32 tdc_header NOENCODE
  // {
    //  0_11: bunch_id;
    // 12_23: event_id;
    // 24_25: tdc;
    //    26: unused;
    // 27_31: 1;
  // }
}
FORCE_IMPL_DATA_SRC_FCN(void,TDC_HEADER::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: TDC_DATA_V1290
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for TDC_DATA_V1290.
 *
 * Do not edit - automatically generated.
 */

// TDC_DATA_V1290(data,leadOrTrail)
#if !PACKER_CODE
# define DECLARED_UNPACK_TDC_DATA_V1290
class TDC_DATA_V1290
#else//PACKER_CODE
# define DECLARED_PACKER_TDC_DATA_V1290
class PACKER_TDC_DATA_V1290
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA24 data[128] ZERO_SUPPRESS_MULTI(128));
  // MEMBER(DATA8 leadOrTrail[128] ZERO_SUPPRESS_MULTI(128));
  // UINT32 tdc_data NOENCODE
  // {
    //  0_20: tdc;
    // 21_25: chn;
    //    26: lot;
    // 27_31: 0;
    // ENCODE(data[chn],(value=tdc));
    // ENCODE(leadOrTrail[chn],(value=lot));
  // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,raw_array_multi_zero_suppress<DATA24,DATA24,128,128> &data
                                      ,raw_array_multi_zero_suppress<DATA8,DATA8,128,128> &leadOrTrail);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,raw_array_multi_zero_suppress<DATA24,DATA24,128,128> &data
                                       ,raw_array_multi_zero_suppress<DATA8,DATA8,128,128> &leadOrTrail);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(TDC_DATA_V1290);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for TDC_DATA_V1290.
 *
 * Do not edit - automatically generated.
 */

// TDC_DATA_V1290(data,leadOrTrail)
template<typename __data_src_t>
void TDC_DATA_V1290::__unpack(__data_src_t &__buffer,raw_array_multi_zero_suppress<DATA24,DATA24,128,128> &data
                                                    ,raw_array_multi_zero_suppress<DATA8,DATA8,128,128> &leadOrTrail)
{
  if (__buffer.is_memberdump())
  {
    printf("          %s%s%s: \n", CT_OUT(BOLD_BLUE),  "TDC_DATA_V1290",CT_OUT(NORM));
  }
  // MEMBER(DATA24 data[128] ZERO_SUPPRESS_MULTI(128));
  // MEMBER(DATA8 leadOrTrail[128] ZERO_SUPPRESS_MULTI(128));
  // UINT32 tdc_data NOENCODE
  // {
    //  0_20: tdc;
    // 21_25: chn;
    //    26: lot;
    // 27_31: 0;
    // ENCODE(data[chn],(value=tdc));
    // ENCODE(leadOrTrail[chn],(value=lot));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 tdc : 21; // 0..20
      uint32 chn : 5; // 21..25
      uint32 lot : 1; // 26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 lot : 1; // 26
      uint32 chn : 5; // 21..25
      uint32 tdc : 21; // 0..20
#endif
    };
    uint32  u32;
  } tdc_data;
  READ_FROM_BUFFER_FULL(522,uint32 ,tdc_data,tdc_data.u32,47);
  CHECK_BITS_EQUAL(519,tdc_data.unnamed_27_31,0);
  {
    {
      typedef __typeof__(*(&(data))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = data.insert_index(520,tdc_data.chn);
      __item.value = tdc_data.tdc;
    }
    {
      typedef __typeof__(*(&(leadOrTrail))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = leadOrTrail.insert_index(521,tdc_data.chn);
      __item.value = tdc_data.lot;
    }
  }
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: tdc_data ", CT_OUT(BOLD), tdc_data.u32, CT_OUT(NORM));
    printf(".tdc=%s%6" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  tdc_data.tdc, CT_OUT(NORM));
    printf(".chn=%s%2" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  tdc_data.chn, CT_OUT(NORM));
    printf(".lot=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  tdc_data.lot, CT_OUT(NORM));
    printf("\n");
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,TDC_DATA_V1290::__unpack,raw_array_multi_zero_suppress<DATA24,DATA24,128,128> &data
                                                         ,raw_array_multi_zero_suppress<DATA8,DATA8,128,128> &leadOrTrail);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for TDC_DATA_V1290.
 *
 * Do not edit - automatically generated.
 */

// TDC_DATA_V1290(data,leadOrTrail)
template<typename __data_src_t>
bool TDC_DATA_V1290::__match(__data_src_t &__buffer)
{
  // MEMBER(DATA24 data[128] ZERO_SUPPRESS_MULTI(128));
  // MEMBER(DATA8 leadOrTrail[128] ZERO_SUPPRESS_MULTI(128));
  // UINT32 tdc_data NOENCODE
  // {
    //  0_20: tdc;
    // 21_25: chn;
    //    26: lot;
    // 27_31: 0;
    // ENCODE(data[chn],(value=tdc));
    // ENCODE(leadOrTrail[chn],(value=lot));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 tdc : 21; // 0..20
      uint32 chn : 5; // 21..25
      uint32 lot : 1; // 26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 lot : 1; // 26
      uint32 chn : 5; // 21..25
      uint32 tdc : 21; // 0..20
#endif
    };
    uint32  u32;
  } tdc_data;
  MATCH_READ_FROM_BUFFER_FULL(522,uint32 ,tdc_data,tdc_data.u32,48);
  MATCH_BITS_EQUAL(519,tdc_data.unnamed_27_31,0);
  {
  }
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN(bool,TDC_DATA_V1290::__match);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for TDC_DATA_V1290.
 *
 * Do not edit - automatically generated.
 */

// TDC_DATA_V1290(data,leadOrTrail)
template<typename __data_dest_t>
void PACKER_TDC_DATA_V1290::__packer(__data_dest_t &__buffer,raw_array_multi_zero_suppress<DATA24,DATA24,128,128> &data
                                                            ,raw_array_multi_zero_suppress<DATA8,DATA8,128,128> &leadOrTrail)
{
  // MEMBER(DATA24 data[128] ZERO_SUPPRESS_MULTI(128));
  // MEMBER(DATA8 leadOrTrail[128] ZERO_SUPPRESS_MULTI(128));
  // UINT32 tdc_data NOENCODE
  // {
    //  0_20: tdc;
    // 21_25: chn;
    //    26: lot;
    // 27_31: 0;
    // ENCODE(data[chn],(value=tdc));
    // ENCODE(leadOrTrail[chn],(value=lot));
  // }
}
FORCE_IMPL_DATA_SRC_FCN(void,TDC_DATA_V1290::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: TDC_ERROR
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for TDC_ERROR.
 *
 * Do not edit - automatically generated.
 */

// TDC_ERROR()
#if !PACKER_CODE
# define DECLARED_UNPACK_TDC_ERROR
class TDC_ERROR
#else//PACKER_CODE
# define DECLARED_PACKER_TDC_ERROR
class PACKER_TDC_ERROR
#endif//PACKER_CODE

{
public:
  // UINT32 tdc_err NOENCODE
  // {
    //  0_14: error_flags;
    // 15_23: unused1;
    // 24_25: tdc;
    //    26: unused2;
    // 27_31: 4;
  // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(TDC_ERROR);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for TDC_ERROR.
 *
 * Do not edit - automatically generated.
 */

// TDC_ERROR()
template<typename __data_src_t>
void TDC_ERROR::__unpack(__data_src_t &__buffer)
{
  if (__buffer.is_memberdump())
  {
    printf("          %s%s%s: \n", CT_OUT(BOLD_BLUE),  "TDC_ERROR",CT_OUT(NORM));
  }
  // UINT32 tdc_err NOENCODE
  // {
    //  0_14: error_flags;
    // 15_23: unused1;
    // 24_25: tdc;
    //    26: unused2;
    // 27_31: 4;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 error_flags : 15; // 0..14
      uint32 unused1 : 9; // 15..23
      uint32 tdc : 2; // 24..25
      uint32 unused2 : 1; // 26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 unused2 : 1; // 26
      uint32 tdc : 2; // 24..25
      uint32 unused1 : 9; // 15..23
      uint32 error_flags : 15; // 0..14
#endif
    };
    uint32  u32;
  } tdc_err;
  READ_FROM_BUFFER_FULL(534,uint32 ,tdc_err,tdc_err.u32,49);
  CHECK_BITS_EQUAL(533,tdc_err.unnamed_27_31,4);
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: tdc_err ", CT_OUT(BOLD), tdc_err.u32, CT_OUT(NORM));
    printf(".error_flags=%s%4" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  tdc_err.error_flags, CT_OUT(NORM));
    printf(".unused1=%s%3" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  tdc_err.unused1, CT_OUT(NORM));
    printf(".tdc=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  tdc_err.tdc, CT_OUT(NORM));
    printf(".unused2=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  tdc_err.unused2, CT_OUT(NORM));
    printf("\n");
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,TDC_ERROR::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for TDC_ERROR.
 *
 * Do not edit - automatically generated.
 */

// TDC_ERROR()
template<typename __data_src_t>
bool TDC_ERROR::__match(__data_src_t &__buffer)
{
  // UINT32 tdc_err NOENCODE
  // {
    //  0_14: error_flags;
    // 15_23: unused1;
    // 24_25: tdc;
    //    26: unused2;
    // 27_31: 4;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 error_flags : 15; // 0..14
      uint32 unused1 : 9; // 15..23
      uint32 tdc : 2; // 24..25
      uint32 unused2 : 1; // 26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 unused2 : 1; // 26
      uint32 tdc : 2; // 24..25
      uint32 unused1 : 9; // 15..23
      uint32 error_flags : 15; // 0..14
#endif
    };
    uint32  u32;
  } tdc_err;
  MATCH_READ_FROM_BUFFER_FULL(534,uint32 ,tdc_err,tdc_err.u32,50);
  MATCH_BITS_EQUAL(533,tdc_err.unnamed_27_31,4);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN(bool,TDC_ERROR::__match);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for TDC_ERROR.
 *
 * Do not edit - automatically generated.
 */

// TDC_ERROR()
template<typename __data_dest_t>
void PACKER_TDC_ERROR::__packer(__data_dest_t &__buffer)
{
  // UINT32 tdc_err NOENCODE
  // {
    //  0_14: error_flags;
    // 15_23: unused1;
    // 24_25: tdc;
    //    26: unused2;
    // 27_31: 4;
  // }
}
FORCE_IMPL_DATA_SRC_FCN(void,TDC_ERROR::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: TDC_TRAILER
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for TDC_TRAILER.
 *
 * Do not edit - automatically generated.
 */

// TDC_TRAILER()
#if !PACKER_CODE
# define DECLARED_UNPACK_TDC_TRAILER
class TDC_TRAILER
#else//PACKER_CODE
# define DECLARED_PACKER_TDC_TRAILER
class PACKER_TDC_TRAILER
#endif//PACKER_CODE

{
public:
  // UINT32 tdc_trailer NOENCODE
  // {
    //  0_11: word_count;
    // 12_23: event_id;
    // 24_25: tdc;
    //    26: unused;
    // 27_31: 3;
  // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(TDC_TRAILER);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for TDC_TRAILER.
 *
 * Do not edit - automatically generated.
 */

// TDC_TRAILER()
template<typename __data_src_t>
void TDC_TRAILER::__unpack(__data_src_t &__buffer)
{
  if (__buffer.is_memberdump())
  {
    printf("          %s%s%s: \n", CT_OUT(BOLD_BLUE),  "TDC_TRAILER",CT_OUT(NORM));
  }
  // UINT32 tdc_trailer NOENCODE
  // {
    //  0_11: word_count;
    // 12_23: event_id;
    // 24_25: tdc;
    //    26: unused;
    // 27_31: 3;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 word_count : 12; // 0..11
      uint32 event_id : 12; // 12..23
      uint32 tdc : 2; // 24..25
      uint32 unused : 1; // 26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 unused : 1; // 26
      uint32 tdc : 2; // 24..25
      uint32 event_id : 12; // 12..23
      uint32 word_count : 12; // 0..11
#endif
    };
    uint32  u32;
  } tdc_trailer;
  READ_FROM_BUFFER_FULL(558,uint32 ,tdc_trailer,tdc_trailer.u32,51);
  CHECK_BITS_EQUAL(557,tdc_trailer.unnamed_27_31,3);
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: tdc_trailer ", CT_OUT(BOLD), tdc_trailer.u32, CT_OUT(NORM));
    printf(".word_count=%s%3" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  tdc_trailer.word_count, CT_OUT(NORM));
    printf(".event_id=%s%3" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  tdc_trailer.event_id, CT_OUT(NORM));
    printf(".tdc=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  tdc_trailer.tdc, CT_OUT(NORM));
    printf(".unused=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  tdc_trailer.unused, CT_OUT(NORM));
    printf("\n");
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,TDC_TRAILER::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for TDC_TRAILER.
 *
 * Do not edit - automatically generated.
 */

// TDC_TRAILER()
template<typename __data_src_t>
bool TDC_TRAILER::__match(__data_src_t &__buffer)
{
  // UINT32 tdc_trailer NOENCODE
  // {
    //  0_11: word_count;
    // 12_23: event_id;
    // 24_25: tdc;
    //    26: unused;
    // 27_31: 3;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 word_count : 12; // 0..11
      uint32 event_id : 12; // 12..23
      uint32 tdc : 2; // 24..25
      uint32 unused : 1; // 26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 unused : 1; // 26
      uint32 tdc : 2; // 24..25
      uint32 event_id : 12; // 12..23
      uint32 word_count : 12; // 0..11
#endif
    };
    uint32  u32;
  } tdc_trailer;
  MATCH_READ_FROM_BUFFER_FULL(558,uint32 ,tdc_trailer,tdc_trailer.u32,52);
  MATCH_BITS_EQUAL(557,tdc_trailer.unnamed_27_31,3);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN(bool,TDC_TRAILER::__match);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for TDC_TRAILER.
 *
 * Do not edit - automatically generated.
 */

// TDC_TRAILER()
template<typename __data_dest_t>
void PACKER_TDC_TRAILER::__packer(__data_dest_t &__buffer)
{
  // UINT32 tdc_trailer NOENCODE
  // {
    //  0_11: word_count;
    // 12_23: event_id;
    // 24_25: tdc;
    //    26: unused;
    // 27_31: 3;
  // }
}
FORCE_IMPL_DATA_SRC_FCN(void,TDC_TRAILER::__packer);

/** END_PACKER ********************************************************/


/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for VME_CAEN_V1290_FRS.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1290_FRS()
#if !PACKER_CODE
# define DECLARED_UNPACK_VME_CAEN_V1290_FRS
class VME_CAEN_V1290_FRS
#else//PACKER_CODE
# define DECLARED_PACKER_VME_CAEN_V1290_FRS
class PACKER_VME_CAEN_V1290_FRS
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA24 data[128] ZERO_SUPPRESS_MULTI(128));
  raw_array_multi_zero_suppress<DATA24,DATA24,128,128> data;
  // MEMBER(DATA8 leadOrTrail[128] ZERO_SUPPRESS_MULTI(128));
  raw_array_multi_zero_suppress<DATA8,DATA8,128,128> leadOrTrail;
  // UINT32 header NOENCODE
  // {
    //  0_04: geo;
    //  5_26: event_count;
    // 27_31: 8;
  // }
  // select several

    // tdc_header = TDC_HEADER();
    // measurement = TDC_DATA_V1290(data=data,leadOrTrail=leadOrTrail);
    // tdc_err = TDC_ERROR();
    // tdc_trailer = TDC_TRAILER();
  SINGLE(TDC_HEADER,tdc_header);
  SINGLE(TDC_DATA_V1290,measurement);
  SINGLE(TDC_ERROR,tdc_err);
  SINGLE(TDC_TRAILER,tdc_trailer);
  // optional UINT32 ext_time_tag NOENCODE
  // {
    //  0_26: time_tag;
    // 27_31: 17;
  // }
  // UINT32 trailer NOENCODE
  // {
    //  0_04: geo;
    //  5_20: word_count;
    // 21_23: unused;
    //    24: tdc_error;
    //    25: overflow;
    //    26: trigger_lost;
    // 27_31: 16;
  // }
  // optional UINT32 eob NOENCODE;

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(VME_CAEN_V1290_FRS);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for VME_CAEN_V1290_FRS.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1290_FRS()
template<typename __data_src_t>
void VME_CAEN_V1290_FRS::__unpack(__data_src_t &__buffer)
{
  if (__buffer.is_memberdump())
  {
    printf("          %s%s%s: \n", CT_OUT(BOLD_BLUE),  "VME_CAEN_V1290_FRS",CT_OUT(NORM));
  }
  // MEMBER(DATA24 data[128] ZERO_SUPPRESS_MULTI(128));
  // MEMBER(DATA8 leadOrTrail[128] ZERO_SUPPRESS_MULTI(128));
  // UINT32 header NOENCODE
  // {
    //  0_04: geo;
    //  5_26: event_count;
    // 27_31: 8;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 geo : 5; // 0..4
      uint32 event_count : 22; // 5..26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 event_count : 22; // 5..26
      uint32 geo : 5; // 0..4
#endif
    };
    uint32  u32;
  } header;
  READ_FROM_BUFFER_FULL(784,uint32 ,header,header.u32,53);
  CHECK_BITS_EQUAL(783,header.unnamed_27_31,8);
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: header ", CT_OUT(BOLD), header.u32, CT_OUT(NORM));
    printf(".geo=%s%2" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  header.geo, CT_OUT(NORM));
    printf(".event_count=%s%6" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  header.event_count, CT_OUT(NORM));
    printf("\n");
  }
  // select several

    // tdc_header = TDC_HEADER();
    // measurement = TDC_DATA_V1290(data=data,leadOrTrail=leadOrTrail);
    // tdc_err = TDC_ERROR();
    // tdc_trailer = TDC_TRAILER();
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: TDC_HEADER tdc_header: (s32) => (0xf8000000,0x08000000)
    // optimized match 2: TDC_DATA_V1290 measurement: (s32) => (0xf8000000,0x00000000)
    // optimized match 3: TDC_ERROR tdc_err: (s32) => (0xf8000000,0x20000000)
    // optimized match 4: TDC_TRAILER tdc_trailer: (s32) => (0xf8000000,0x18000000)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(791,uint32,__match_peek);
    // differ = 38000000 : 27 28 29
    uint32 __match_index = 0 | /* 27,29 */ ((__match_peek >> 27) & 0x00000007);
    static const sint8 __match_index_array[8] = { 2, 1, 0, 4, 3, 0, 0, 0, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 0
    }
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        CHECK_SPURIOUS_MATCH_DECL(787,spurious_match_abort_loop_0,TDC_HEADER);
        UNPACK_DECL(787,TDC_HEADER,tdc_header);
        break;
      case 2:
        CHECK_SPURIOUS_MATCH_DECL(788,spurious_match_abort_loop_0,TDC_DATA_V1290/*,data:member*//*,leadOrTrail:member*/);
        UNPACK_DECL(788,TDC_DATA_V1290,measurement,/*data*/data,/*leadOrTrail*/leadOrTrail);
        break;
      case 3:
        CHECK_SPURIOUS_MATCH_DECL(789,spurious_match_abort_loop_0,TDC_ERROR);
        UNPACK_DECL(789,TDC_ERROR,tdc_err);
        break;
      case 4:
        CHECK_SPURIOUS_MATCH_DECL(790,spurious_match_abort_loop_0,TDC_TRAILER);
        UNPACK_DECL(790,TDC_TRAILER,tdc_trailer);
        break;
    }
  }
  spurious_match_abort_loop_0:;
  // optional UINT32 ext_time_tag NOENCODE
  // {
    //  0_26: time_tag;
    // 27_31: 17;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 time_tag : 27; // 0..26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 time_tag : 27; // 0..26
#endif
    };
    uint32  u32;
  } ext_time_tag;
  if (__buffer.empty()) goto data_done_2;
  PEEK_FROM_BUFFER_FULL(796,uint32 ,ext_time_tag,ext_time_tag.u32,54);
  CHECK_JUMP_BITS_EQUAL(795,ext_time_tag.unnamed_27_31,17,data_done_2);
  __buffer.advance(sizeof(ext_time_tag.u32));
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: ext_time_tag ", CT_OUT(BOLD), ext_time_tag.u32, CT_OUT(NORM));
    printf(".time_tag=%s%7" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  ext_time_tag.time_tag, CT_OUT(NORM));
    printf("\n");
  }
  data_done_2:;
  // UINT32 trailer NOENCODE
  // {
    //  0_04: geo;
    //  5_20: word_count;
    // 21_23: unused;
    //    24: tdc_error;
    //    25: overflow;
    //    26: trigger_lost;
    // 27_31: 16;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 geo : 5; // 0..4
      uint32 word_count : 16; // 5..20
      uint32 unused : 3; // 21..23
      uint32 tdc_error : 1; // 24
      uint32 overflow : 1; // 25
      uint32 trigger_lost : 1; // 26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 trigger_lost : 1; // 26
      uint32 overflow : 1; // 25
      uint32 tdc_error : 1; // 24
      uint32 unused : 3; // 21..23
      uint32 word_count : 16; // 5..20
      uint32 geo : 5; // 0..4
#endif
    };
    uint32  u32;
  } trailer;
  READ_FROM_BUFFER_FULL(806,uint32 ,trailer,trailer.u32,55);
  CHECK_BITS_EQUAL(805,trailer.unnamed_27_31,16);
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: trailer ", CT_OUT(BOLD), trailer.u32, CT_OUT(NORM));
    printf(".geo=%s%2" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  trailer.geo, CT_OUT(NORM));
    printf(".word_count=%s%4" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  trailer.word_count, CT_OUT(NORM));
    printf(".unused=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  trailer.unused, CT_OUT(NORM));
    printf(".tdc_error=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  trailer.tdc_error, CT_OUT(NORM));
    printf(".overflow=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  trailer.overflow, CT_OUT(NORM));
    printf(".trigger_lost=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  trailer.trigger_lost, CT_OUT(NORM));
    printf("\n");
  }
  // optional UINT32 eob NOENCODE;
  uint32  eob;if (__buffer.empty()) goto data_done_3;
  READ_FROM_BUFFER(807,uint32 ,eob,56);
  data_done_3:;
}
FORCE_IMPL_DATA_SRC_FCN(void,VME_CAEN_V1290_FRS::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for VME_CAEN_V1290_FRS.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1290_FRS()
template<typename __data_src_t>
bool VME_CAEN_V1290_FRS::__match(__data_src_t &__buffer)
{
  // MEMBER(DATA24 data[128] ZERO_SUPPRESS_MULTI(128));
  // MEMBER(DATA8 leadOrTrail[128] ZERO_SUPPRESS_MULTI(128));
  // UINT32 header NOENCODE
  // {
    //  0_04: geo;
    //  5_26: event_count;
    // 27_31: 8;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 geo : 5; // 0..4
      uint32 event_count : 22; // 5..26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 event_count : 22; // 5..26
      uint32 geo : 5; // 0..4
#endif
    };
    uint32  u32;
  } header;
  MATCH_READ_FROM_BUFFER_FULL(784,uint32 ,header,header.u32,57);
  MATCH_BITS_EQUAL(783,header.unnamed_27_31,8);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN(bool,VME_CAEN_V1290_FRS::__match);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for VME_CAEN_V1290_FRS.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1290_FRS()
template<typename __data_dest_t>
void PACKER_VME_CAEN_V1290_FRS::__packer(__data_dest_t &__buffer)
{
  // MEMBER(DATA24 data[128] ZERO_SUPPRESS_MULTI(128));
  // MEMBER(DATA8 leadOrTrail[128] ZERO_SUPPRESS_MULTI(128));
  // UINT32 header NOENCODE
  // {
    //  0_04: geo;
    //  5_26: event_count;
    // 27_31: 8;
  // }
  // select several

    // tdc_header = TDC_HEADER();
    // measurement = TDC_DATA_V1290(data=data,leadOrTrail=leadOrTrail);
    // tdc_err = TDC_ERROR();
    // tdc_trailer = TDC_TRAILER();
  {
    PACK_DECL(787,TDC_HEADER,tdc_header);
    PACK_DECL(788,TDC_DATA_V1290,measurement,/*data*/data,/*leadOrTrail*/leadOrTrail);
    PACK_DECL(789,TDC_ERROR,tdc_err);
    PACK_DECL(790,TDC_TRAILER,tdc_trailer);
  }
  // optional UINT32 ext_time_tag NOENCODE
  // {
    //  0_26: time_tag;
    // 27_31: 17;
  // }
  // UINT32 trailer NOENCODE
  // {
    //  0_04: geo;
    //  5_20: word_count;
    // 21_23: unused;
    //    24: tdc_error;
    //    25: overflow;
    //    26: trigger_lost;
    // 27_31: 16;
  // }
  // optional UINT32 eob NOENCODE;
}
FORCE_IMPL_DATA_SRC_FCN(void,VME_CAEN_V1290_FRS::__packer);

/** END_PACKER ********************************************************/


/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for MAIN_CRATE_DATA.
 *
 * Do not edit - automatically generated.
 */

// MAIN_CRATE_DATA()
#if !PACKER_CODE
# define DECLARED_UNPACK_MAIN_CRATE_DATA
class MAIN_CRATE_DATA
#else//PACKER_CODE
# define DECLARED_PACKER_MAIN_CRATE_DATA
class PACKER_MAIN_CRATE_DATA
#endif//PACKER_CODE

{
public:
  // barrier[0] = BARRIER();
  // v830 = VME_CAEN_V830_FRS();
  // filler[0] = ZERO_FILLER();
  // barrier[1] = BARRIER();
  // v792 = VME_CAEN_V792_FRS();
  // barrier[2] = BARRIER();
  // v1290 = VME_CAEN_V1290_FRS();
  SINGLE(BARRIER,barrier[3]);
  SINGLE(VME_CAEN_V830_FRS,v830);
  SINGLE(ZERO_FILLER,filler[1]);
  SINGLE(VME_CAEN_V792_FRS,v792);
  SINGLE(VME_CAEN_V1290_FRS,v1290);

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(MAIN_CRATE_DATA);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for MAIN_CRATE_DATA.
 *
 * Do not edit - automatically generated.
 */

// MAIN_CRATE_DATA()
template<typename __data_src_t>
void MAIN_CRATE_DATA::__unpack(__data_src_t &__buffer)
{
  if (__buffer.is_memberdump())
  {
    printf("          %s%s%s: \n", CT_OUT(BOLD_BLUE),  "MAIN_CRATE_DATA",CT_OUT(NORM));
  }
  // barrier[0] = BARRIER();
  UNPACK_DECL(258,BARRIER,barrier[0]);
  // v830 = VME_CAEN_V830_FRS();
  UNPACK_DECL(259,VME_CAEN_V830_FRS,v830);
  // filler[0] = ZERO_FILLER();
  UNPACK_DECL(260,ZERO_FILLER,filler[0]);
  // barrier[1] = BARRIER();
  UNPACK_DECL(261,BARRIER,barrier[1]);
  // v792 = VME_CAEN_V792_FRS();
  UNPACK_DECL(262,VME_CAEN_V792_FRS,v792);
  // barrier[2] = BARRIER();
  UNPACK_DECL(263,BARRIER,barrier[2]);
  // v1290 = VME_CAEN_V1290_FRS();
  UNPACK_DECL(264,VME_CAEN_V1290_FRS,v1290);
}
FORCE_IMPL_DATA_SRC_FCN(void,MAIN_CRATE_DATA::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for MAIN_CRATE_DATA.
 *
 * Do not edit - automatically generated.
 */

// MAIN_CRATE_DATA()
template<typename __data_src_t>
bool MAIN_CRATE_DATA::__match(__data_src_t &__buffer)
{
  // barrier[0] = BARRIER();
  CHECK_MATCH_DECL(258,BARRIER,barrier[0]);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN(bool,MAIN_CRATE_DATA::__match);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for MAIN_CRATE_DATA.
 *
 * Do not edit - automatically generated.
 */

// MAIN_CRATE_DATA()
template<typename __data_dest_t>
void PACKER_MAIN_CRATE_DATA::__packer(__data_dest_t &__buffer)
{
  // barrier[0] = BARRIER();
  PACK_DECL(258,BARRIER,barrier[0]);
  // v830 = VME_CAEN_V830_FRS();
  PACK_DECL(259,VME_CAEN_V830_FRS,v830);
  // filler[0] = ZERO_FILLER();
  PACK_DECL(260,ZERO_FILLER,filler[0]);
  // barrier[1] = BARRIER();
  PACK_DECL(261,BARRIER,barrier[1]);
  // v792 = VME_CAEN_V792_FRS();
  PACK_DECL(262,VME_CAEN_V792_FRS,v792);
  // barrier[2] = BARRIER();
  PACK_DECL(263,BARRIER,barrier[2]);
  // v1290 = VME_CAEN_V1290_FRS();
  PACK_DECL(264,VME_CAEN_V1290_FRS,v1290);
}
FORCE_IMPL_DATA_SRC_FCN(void,MAIN_CRATE_DATA::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: MESYTEC_MQDC32_FRS
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for MESYTEC_MQDC32_FRS.
 *
 * Do not edit - automatically generated.
 */

// MESYTEC_MQDC32_FRS()
#if !PACKER_CODE
# define DECLARED_UNPACK_MESYTEC_MQDC32_FRS
class MESYTEC_MQDC32_FRS
#else//PACKER_CODE
# define DECLARED_PACKER_MESYTEC_MQDC32_FRS
class PACKER_MESYTEC_MQDC32_FRS
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA12_OVERFLOW data[32] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA12_OVERFLOW,DATA12_OVERFLOW,32> data;
  // UINT32 header NOENCODE
  // {
    //  0_11: word_number;
    // 12_14: 0;
    // 16_23: geom;
    // 24_29: 0;
    // 30_31: 1;
  // }
  // several UINT32 ch_data NOENCODE
  // {
    //  0_11: value;
    //    15: outofrange;
    // 16_20: channel;
    // 21_29: 32;
    // 30_31: 0;
    // ENCODE(data[channel],(value=value,overflow=outofrange));
  // }
  // optional UINT32 zero NOENCODE
  // {
    //  0_31: 0;
  // }
  // UINT32 end_of_event NOENCODE
  // {
    //  0_29: counter;
    // 30_31: 3;
  // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(MESYTEC_MQDC32_FRS);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for MESYTEC_MQDC32_FRS.
 *
 * Do not edit - automatically generated.
 */

// MESYTEC_MQDC32_FRS()
template<typename __data_src_t>
void MESYTEC_MQDC32_FRS::__unpack(__data_src_t &__buffer)
{
  if (__buffer.is_memberdump())
  {
    printf("          %s%s%s: \n", CT_OUT(BOLD_BLUE),  "MESYTEC_MQDC32_FRS",CT_OUT(NORM));
  }
  // MEMBER(DATA12_OVERFLOW data[32] ZERO_SUPPRESS);
  // UINT32 header NOENCODE
  // {
    //  0_11: word_number;
    // 12_14: 0;
    // 16_23: geom;
    // 24_29: 0;
    // 30_31: 1;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 word_number : 12; // 0..11
      uint32 unnamed_12_14 : 3; // 12..14
      uint32 dummy_15 : 1;
      uint32 geom : 8; // 16..23
      uint32 unnamed_24_29 : 6; // 24..29
      uint32 unnamed_30_31 : 2; // 30..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_30_31 : 2; // 30..31
      uint32 unnamed_24_29 : 6; // 24..29
      uint32 geom : 8; // 16..23
      uint32 dummy_15 : 1;
      uint32 unnamed_12_14 : 3; // 12..14
      uint32 word_number : 12; // 0..11
#endif
    };
    uint32  u32;
  } header;
  READ_FROM_BUFFER_FULL(277,uint32 ,header,header.u32,58);
  CHECK_BITS_EQUAL(273,header.unnamed_12_14,0);
  CHECK_BITS_EQUAL(275,header.unnamed_24_29,0);
  CHECK_BITS_EQUAL(276,header.unnamed_30_31,1);
  CHECK_UNNAMED_BITS_ZERO(277,header.u32,0x00008000);
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: header ", CT_OUT(BOLD), header.u32, CT_OUT(NORM));
    printf(".word_number=%s%3" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  header.word_number, CT_OUT(NORM));
    printf(".geom=%s%2" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  header.geom, CT_OUT(NORM));
    printf("\n");
  }
  // several UINT32 ch_data NOENCODE
  // {
    //  0_11: value;
    //    15: outofrange;
    // 16_20: channel;
    // 21_29: 32;
    // 30_31: 0;
    // ENCODE(data[channel],(value=value,overflow=outofrange));
  // }
  for ( ; ; ) {
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 value : 12; // 0..11
      uint32 dummy_12_14 : 3;
      uint32 outofrange : 1; // 15
      uint32 channel : 5; // 16..20
      uint32 unnamed_21_29 : 9; // 21..29
      uint32 unnamed_30_31 : 2; // 30..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_30_31 : 2; // 30..31
      uint32 unnamed_21_29 : 9; // 21..29
      uint32 channel : 5; // 16..20
      uint32 outofrange : 1; // 15
      uint32 dummy_12_14 : 3;
      uint32 value : 12; // 0..11
#endif
    };
    uint32  u32;
  } ch_data;
  if (__buffer.empty()) goto data_done_4;
  PEEK_FROM_BUFFER_FULL(286,uint32 ,ch_data,ch_data.u32,59);
  CHECK_JUMP_BITS_EQUAL(283,ch_data.unnamed_21_29,32,data_done_4);
  CHECK_JUMP_BITS_EQUAL(284,ch_data.unnamed_30_31,0,data_done_4);
  CHECK_JUMP_UNNAMED_BITS_ZERO(286,ch_data.u32,0x00007000,data_done_4);
  __buffer.advance(sizeof(ch_data.u32));
  {
    typedef __typeof__(*(&(data))) __array_t;
    typedef typename __array_t::item_t __item_t;
    __item_t &__item = data.insert_index(285,ch_data.channel);
    __item.value = ch_data.value;
    __item.overflow = ch_data.outofrange;
  }
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: ch_data ", CT_OUT(BOLD), ch_data.u32, CT_OUT(NORM));
    printf(".value=%s%3" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  ch_data.value, CT_OUT(NORM));
    printf(".outofrange=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  ch_data.outofrange, CT_OUT(NORM));
    printf(".channel=%s%2" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  ch_data.channel, CT_OUT(NORM));
    printf("\n");
  }
  }
  data_done_4:;
  // optional UINT32 zero NOENCODE
  // {
    //  0_31: 0;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 unnamed_0_31 : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_0_31 : 32; // 0..31
#endif
    };
    uint32  u32;
  } zero;
  if (__buffer.empty()) goto data_done_5;
  PEEK_FROM_BUFFER_FULL(290,uint32 ,zero,zero.u32,60);
  CHECK_JUMP_BITS_EQUAL(289,zero.unnamed_0_31,0,data_done_5);
  __buffer.advance(sizeof(zero.u32));
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: zero ", CT_OUT(BOLD), zero.u32, CT_OUT(NORM));
    printf("\n");
  }
  data_done_5:;
  // UINT32 end_of_event NOENCODE
  // {
    //  0_29: counter;
    // 30_31: 3;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 counter : 30; // 0..29
      uint32 unnamed_30_31 : 2; // 30..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_30_31 : 2; // 30..31
      uint32 counter : 30; // 0..29
#endif
    };
    uint32  u32;
  } end_of_event;
  READ_FROM_BUFFER_FULL(295,uint32 ,end_of_event,end_of_event.u32,61);
  CHECK_BITS_EQUAL(294,end_of_event.unnamed_30_31,3);
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: end_of_event ", CT_OUT(BOLD), end_of_event.u32, CT_OUT(NORM));
    printf(".counter=%s%8" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  end_of_event.counter, CT_OUT(NORM));
    printf("\n");
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,MESYTEC_MQDC32_FRS::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for MESYTEC_MQDC32_FRS.
 *
 * Do not edit - automatically generated.
 */

// MESYTEC_MQDC32_FRS()
template<typename __data_src_t>
bool MESYTEC_MQDC32_FRS::__match(__data_src_t &__buffer)
{
  // MEMBER(DATA12_OVERFLOW data[32] ZERO_SUPPRESS);
  // UINT32 header NOENCODE
  // {
    //  0_11: word_number;
    // 12_14: 0;
    // 16_23: geom;
    // 24_29: 0;
    // 30_31: 1;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 word_number : 12; // 0..11
      uint32 unnamed_12_14 : 3; // 12..14
      uint32 dummy_15 : 1;
      uint32 geom : 8; // 16..23
      uint32 unnamed_24_29 : 6; // 24..29
      uint32 unnamed_30_31 : 2; // 30..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_30_31 : 2; // 30..31
      uint32 unnamed_24_29 : 6; // 24..29
      uint32 geom : 8; // 16..23
      uint32 dummy_15 : 1;
      uint32 unnamed_12_14 : 3; // 12..14
      uint32 word_number : 12; // 0..11
#endif
    };
    uint32  u32;
  } header;
  MATCH_READ_FROM_BUFFER_FULL(277,uint32 ,header,header.u32,62);
  MATCH_BITS_EQUAL(273,header.unnamed_12_14,0);
  MATCH_BITS_EQUAL(275,header.unnamed_24_29,0);
  MATCH_BITS_EQUAL(276,header.unnamed_30_31,1);
  MATCH_UNNAMED_BITS_ZERO(277,header.u32,0x00008000);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN(bool,MESYTEC_MQDC32_FRS::__match);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for MESYTEC_MQDC32_FRS.
 *
 * Do not edit - automatically generated.
 */

// MESYTEC_MQDC32_FRS()
template<typename __data_dest_t>
void PACKER_MESYTEC_MQDC32_FRS::__packer(__data_dest_t &__buffer)
{
  // MEMBER(DATA12_OVERFLOW data[32] ZERO_SUPPRESS);
  // UINT32 header NOENCODE
  // {
    //  0_11: word_number;
    // 12_14: 0;
    // 16_23: geom;
    // 24_29: 0;
    // 30_31: 1;
  // }
  // several UINT32 ch_data NOENCODE
  // {
    //  0_11: value;
    //    15: outofrange;
    // 16_20: channel;
    // 21_29: 32;
    // 30_31: 0;
    // ENCODE(data[channel],(value=value,overflow=outofrange));
  // }
  // optional UINT32 zero NOENCODE
  // {
    //  0_31: 0;
  // }
  // UINT32 end_of_event NOENCODE
  // {
    //  0_29: counter;
    // 30_31: 3;
  // }
}
FORCE_IMPL_DATA_SRC_FCN(void,MESYTEC_MQDC32_FRS::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: MESYTEC_MTDC32_FRS
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for MESYTEC_MTDC32_FRS.
 *
 * Do not edit - automatically generated.
 */

// MESYTEC_MTDC32_FRS()
#if !PACKER_CODE
# define DECLARED_UNPACK_MESYTEC_MTDC32_FRS
class MESYTEC_MTDC32_FRS
#else//PACKER_CODE
# define DECLARED_PACKER_MESYTEC_MTDC32_FRS
class PACKER_MESYTEC_MTDC32_FRS
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA16 data[34] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA16,DATA16,34> data;
  // UINT32 header NOENCODE
  // {
    //  0_11: word_number;
    // 12_15: tdc_resol;
    // 16_23: geom;
    // 24_29: 0;
    // 30_31: 1;
  // }
  // list(1<=index<header.word_number)

    // optional UINT32 zero NOENCODE
    // {
      //  0_31: ze = MATCH(0);
    // }
    // if((zero.ze != 0))

      // UINT32 ch_data NOENCODE
      // {
        //  0_15: value;
        // 16_20: channel;
        //    21: trig;
        // 22_29: 16;
        // 30_31: 0;
        // ENCODE(data[((trig * 32) + channel)],(value=value));
      // }
  // UINT32 end_of_event NOENCODE
  // {
    //  0_29: counter;
    // 30_31: 3;
  // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(MESYTEC_MTDC32_FRS);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for MESYTEC_MTDC32_FRS.
 *
 * Do not edit - automatically generated.
 */

// MESYTEC_MTDC32_FRS()
template<typename __data_src_t>
void MESYTEC_MTDC32_FRS::__unpack(__data_src_t &__buffer)
{
  if (__buffer.is_memberdump())
  {
    printf("          %s%s%s: \n", CT_OUT(BOLD_BLUE),  "MESYTEC_MTDC32_FRS",CT_OUT(NORM));
  }
  // MEMBER(DATA16 data[34] ZERO_SUPPRESS);
  // UINT32 header NOENCODE
  // {
    //  0_11: word_number;
    // 12_15: tdc_resol;
    // 16_23: geom;
    // 24_29: 0;
    // 30_31: 1;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 word_number : 12; // 0..11
      uint32 tdc_resol : 4; // 12..15
      uint32 geom : 8; // 16..23
      uint32 unnamed_24_29 : 6; // 24..29
      uint32 unnamed_30_31 : 2; // 30..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_30_31 : 2; // 30..31
      uint32 unnamed_24_29 : 6; // 24..29
      uint32 geom : 8; // 16..23
      uint32 tdc_resol : 4; // 12..15
      uint32 word_number : 12; // 0..11
#endif
    };
    uint32  u32;
  } header;
  READ_FROM_BUFFER_FULL(308,uint32 ,header,header.u32,63);
  CHECK_BITS_EQUAL(306,header.unnamed_24_29,0);
  CHECK_BITS_EQUAL(307,header.unnamed_30_31,1);
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: header ", CT_OUT(BOLD), header.u32, CT_OUT(NORM));
    printf(".word_number=%s%3" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  header.word_number, CT_OUT(NORM));
    printf(".tdc_resol=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  header.tdc_resol, CT_OUT(NORM));
    printf(".geom=%s%2" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  header.geom, CT_OUT(NORM));
    printf("\n");
  }
  // list(1<=index<header.word_number)

  for (uint32 index = 1; index < (uint32) (header.word_number); ++index)
  {
    // optional UINT32 zero NOENCODE
    // {
      //  0_31: ze = MATCH(0);
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 ze : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 ze : 32; // 0..31
#endif
      };
      uint32  u32;
    } zero;
    if (__buffer.empty()) goto data_done_6;
    PEEK_FROM_BUFFER_FULL(314,uint32 ,zero,zero.u32,64);
    CHECK_JUMP_BITS_EQUAL(313,zero.ze,0,data_done_6);
    __buffer.advance(sizeof(zero.u32));
    if (__buffer.is_memberdump())
    {
      printf("%s%08" PRIx32 "%s: zero ", CT_OUT(BOLD), zero.u32, CT_OUT(NORM));
      printf(".ze=%s%8" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  zero.ze, CT_OUT(NORM));
      printf("\n");
    }
    data_done_6:;
    // if((zero.ze != 0))

    if ((zero.ze != 0))
    {
      // UINT32 ch_data NOENCODE
      // {
        //  0_15: value;
        // 16_20: channel;
        //    21: trig;
        // 22_29: 16;
        // 30_31: 0;
        // ENCODE(data[((trig * 32) + channel)],(value=value));
      // }
      union
      {
        struct
        {
#if __BYTE_ORDER == __LITTLE_ENDIAN
          uint32 value : 16; // 0..15
          uint32 channel : 5; // 16..20
          uint32 trig : 1; // 21
          uint32 unnamed_22_29 : 8; // 22..29
          uint32 unnamed_30_31 : 2; // 30..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
          uint32 unnamed_30_31 : 2; // 30..31
          uint32 unnamed_22_29 : 8; // 22..29
          uint32 trig : 1; // 21
          uint32 channel : 5; // 16..20
          uint32 value : 16; // 0..15
#endif
        };
        uint32  u32;
      } ch_data;
      READ_FROM_BUFFER_FULL(325,uint32 ,ch_data,ch_data.u32,65);
      CHECK_BITS_EQUAL(322,ch_data.unnamed_22_29,16);
      CHECK_BITS_EQUAL(323,ch_data.unnamed_30_31,0);
      {
        typedef __typeof__(*(&(data))) __array_t;
        typedef typename __array_t::item_t __item_t;
        __item_t &__item = data.insert_index(324,((ch_data.trig * 32) + ch_data.channel));
        __item.value = ch_data.value;
      }
      if (__buffer.is_memberdump())
      {
        printf("%s%08" PRIx32 "%s: ch_data ", CT_OUT(BOLD), ch_data.u32, CT_OUT(NORM));
        printf(".value=%s%4" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  ch_data.value, CT_OUT(NORM));
        printf(".channel=%s%2" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  ch_data.channel, CT_OUT(NORM));
        printf(".trig=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  ch_data.trig, CT_OUT(NORM));
        printf("\n");
      }
    }
  }
  // UINT32 end_of_event NOENCODE
  // {
    //  0_29: counter;
    // 30_31: 3;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 counter : 30; // 0..29
      uint32 unnamed_30_31 : 2; // 30..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_30_31 : 2; // 30..31
      uint32 counter : 30; // 0..29
#endif
    };
    uint32  u32;
  } end_of_event;
  READ_FROM_BUFFER_FULL(332,uint32 ,end_of_event,end_of_event.u32,66);
  CHECK_BITS_EQUAL(331,end_of_event.unnamed_30_31,3);
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: end_of_event ", CT_OUT(BOLD), end_of_event.u32, CT_OUT(NORM));
    printf(".counter=%s%8" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  end_of_event.counter, CT_OUT(NORM));
    printf("\n");
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,MESYTEC_MTDC32_FRS::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for MESYTEC_MTDC32_FRS.
 *
 * Do not edit - automatically generated.
 */

// MESYTEC_MTDC32_FRS()
template<typename __data_src_t>
bool MESYTEC_MTDC32_FRS::__match(__data_src_t &__buffer)
{
  // MEMBER(DATA16 data[34] ZERO_SUPPRESS);
  // UINT32 header NOENCODE
  // {
    //  0_11: word_number;
    // 12_15: tdc_resol;
    // 16_23: geom;
    // 24_29: 0;
    // 30_31: 1;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 word_number : 12; // 0..11
      uint32 tdc_resol : 4; // 12..15
      uint32 geom : 8; // 16..23
      uint32 unnamed_24_29 : 6; // 24..29
      uint32 unnamed_30_31 : 2; // 30..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_30_31 : 2; // 30..31
      uint32 unnamed_24_29 : 6; // 24..29
      uint32 geom : 8; // 16..23
      uint32 tdc_resol : 4; // 12..15
      uint32 word_number : 12; // 0..11
#endif
    };
    uint32  u32;
  } header;
  MATCH_READ_FROM_BUFFER_FULL(308,uint32 ,header,header.u32,67);
  MATCH_BITS_EQUAL(306,header.unnamed_24_29,0);
  MATCH_BITS_EQUAL(307,header.unnamed_30_31,1);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN(bool,MESYTEC_MTDC32_FRS::__match);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for MESYTEC_MTDC32_FRS.
 *
 * Do not edit - automatically generated.
 */

// MESYTEC_MTDC32_FRS()
template<typename __data_dest_t>
void PACKER_MESYTEC_MTDC32_FRS::__packer(__data_dest_t &__buffer)
{
  // MEMBER(DATA16 data[34] ZERO_SUPPRESS);
  // UINT32 header NOENCODE
  // {
    //  0_11: word_number;
    // 12_15: tdc_resol;
    // 16_23: geom;
    // 24_29: 0;
    // 30_31: 1;
  // }
  // list(1<=index<header.word_number)

  {
    // optional UINT32 zero NOENCODE
    // {
      //  0_31: ze = MATCH(0);
    // }
    // if((zero.ze != 0))

    if ((zero.ze != 0))
    {
      // UINT32 ch_data NOENCODE
      // {
        //  0_15: value;
        // 16_20: channel;
        //    21: trig;
        // 22_29: 16;
        // 30_31: 0;
        // ENCODE(data[((trig * 32) + channel)],(value=value));
      // }
    }
  }
  // UINT32 end_of_event NOENCODE
  // {
    //  0_29: counter;
    // 30_31: 3;
  // }
}
FORCE_IMPL_DATA_SRC_FCN(void,MESYTEC_MTDC32_FRS::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: SIS_3820_FRS
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for SIS_3820_FRS.
 *
 * Do not edit - automatically generated.
 */

// SIS_3820_FRS()
#if !PACKER_CODE
# define DECLARED_UNPACK_SIS_3820_FRS
class SIS_3820_FRS
#else//PACKER_CODE
# define DECLARED_PACKER_SIS_3820_FRS
class PACKER_SIS_3820_FRS
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA32 data[32] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA32,DATA32,32> data;
  // UINT32 custom_header NOENCODE
  // {
    //  0_07: nchs;
    //  8_21: nevts;
    //    22: latching;
    // 23_26: data_format;
    // 27_31: id;
  // }
  // list(0<=index<custom_header.nchs)

    // if((1 == custom_header.data_format))

      // UINT32 event NOENCODE
      // {
        //  0_31: val;
      // }
      // ENCODE(data[index],(value=event.val));

    // if(((0 == custom_header.data_format) || (3 == custom_header.data_format)))

      // UINT32 event NOENCODE
      // {
        //  0_23: val;
        // 24_28: channel;
        //    29: 0;
        // 30_31: user_bits;
      // }
      // ENCODE(data[event.channel],(value=event.val));


public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(SIS_3820_FRS);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for SIS_3820_FRS.
 *
 * Do not edit - automatically generated.
 */

// SIS_3820_FRS()
template<typename __data_src_t>
void SIS_3820_FRS::__unpack(__data_src_t &__buffer)
{
  if (__buffer.is_memberdump())
  {
    printf("          %s%s%s: \n", CT_OUT(BOLD_BLUE),  "SIS_3820_FRS",CT_OUT(NORM));
  }
  // MEMBER(DATA32 data[32] ZERO_SUPPRESS);
  // UINT32 custom_header NOENCODE
  // {
    //  0_07: nchs;
    //  8_21: nevts;
    //    22: latching;
    // 23_26: data_format;
    // 27_31: id;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 nchs : 8; // 0..7
      uint32 nevts : 14; // 8..21
      uint32 latching : 1; // 22
      uint32 data_format : 4; // 23..26
      uint32 id : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 id : 5; // 27..31
      uint32 data_format : 4; // 23..26
      uint32 latching : 1; // 22
      uint32 nevts : 14; // 8..21
      uint32 nchs : 8; // 0..7
#endif
    };
    uint32  u32;
  } custom_header;
  READ_FROM_BUFFER_FULL(345,uint32 ,custom_header,custom_header.u32,68);
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: custom_header ", CT_OUT(BOLD), custom_header.u32, CT_OUT(NORM));
    printf(".nchs=%s%2" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  custom_header.nchs, CT_OUT(NORM));
    printf(".nevts=%s%4" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  custom_header.nevts, CT_OUT(NORM));
    printf(".latching=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  custom_header.latching, CT_OUT(NORM));
    printf(".data_format=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  custom_header.data_format, CT_OUT(NORM));
    printf(".id=%s%2" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  custom_header.id, CT_OUT(NORM));
    printf("\n");
  }
  // list(0<=index<custom_header.nchs)

  for (uint32 index = 0; index < (uint32) (custom_header.nchs); ++index)
  {
    // if((1 == custom_header.data_format))

    if ((1 == custom_header.data_format))
    {
      // UINT32 event NOENCODE
      // {
        //  0_31: val;
      // }
      union
      {
        struct
        {
#if __BYTE_ORDER == __LITTLE_ENDIAN
          uint32 val : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
          uint32 val : 32; // 0..31
#endif
        };
        uint32  u32;
      } event;
      READ_FROM_BUFFER_FULL(353,uint32 ,event,event.u32,69);
      if (__buffer.is_memberdump())
      {
        printf("%s%08" PRIx32 "%s: event ", CT_OUT(BOLD), event.u32, CT_OUT(NORM));
        printf(".val=%s%8" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  event.val, CT_OUT(NORM));
        printf("\n");
      }
      // ENCODE(data[index],(value=event.val));

      {
        typedef __typeof__(*(&(data))) __array_t;
        typedef typename __array_t::item_t __item_t;
        __item_t &__item = data.insert_index(354,index);
        __item.value = event.val;
      }
    }
    // if(((0 == custom_header.data_format) || (3 == custom_header.data_format)))

    if (((0 == custom_header.data_format) || (3 == custom_header.data_format)))
    {
      // UINT32 event NOENCODE
      // {
        //  0_23: val;
        // 24_28: channel;
        //    29: 0;
        // 30_31: user_bits;
      // }
      union
      {
        struct
        {
#if __BYTE_ORDER == __LITTLE_ENDIAN
          uint32 val : 24; // 0..23
          uint32 channel : 5; // 24..28
          uint32 unnamed_29_29 : 1; // 29
          uint32 user_bits : 2; // 30..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
          uint32 user_bits : 2; // 30..31
          uint32 unnamed_29_29 : 1; // 29
          uint32 channel : 5; // 24..28
          uint32 val : 24; // 0..23
#endif
        };
        uint32  u32;
      } event;
      READ_FROM_BUFFER_FULL(365,uint32 ,event,event.u32,70);
      CHECK_BITS_EQUAL(363,event.unnamed_29_29,0);
      if (__buffer.is_memberdump())
      {
        printf("%s%08" PRIx32 "%s: event ", CT_OUT(BOLD), event.u32, CT_OUT(NORM));
        printf(".val=%s%6" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  event.val, CT_OUT(NORM));
        printf(".channel=%s%2" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  event.channel, CT_OUT(NORM));
        printf(".user_bits=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  event.user_bits, CT_OUT(NORM));
        printf("\n");
      }
      // ENCODE(data[event.channel],(value=event.val));

      {
        typedef __typeof__(*(&(data))) __array_t;
        typedef typename __array_t::item_t __item_t;
        __item_t &__item = data.insert_index(366,event.channel);
        __item.value = event.val;
      }
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,SIS_3820_FRS::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for SIS_3820_FRS.
 *
 * Do not edit - automatically generated.
 */

// SIS_3820_FRS()
template<typename __data_src_t>
bool SIS_3820_FRS::__match(__data_src_t &__buffer)
{
  // MEMBER(DATA32 data[32] ZERO_SUPPRESS);
  // UINT32 custom_header NOENCODE
  // {
    //  0_07: nchs;
    //  8_21: nevts;
    //    22: latching;
    // 23_26: data_format;
    // 27_31: id;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 nchs : 8; // 0..7
      uint32 nevts : 14; // 8..21
      uint32 latching : 1; // 22
      uint32 data_format : 4; // 23..26
      uint32 id : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 id : 5; // 27..31
      uint32 data_format : 4; // 23..26
      uint32 latching : 1; // 22
      uint32 nevts : 14; // 8..21
      uint32 nchs : 8; // 0..7
#endif
    };
    uint32  u32;
  } custom_header;
  MATCH_READ_FROM_BUFFER_FULL(345,uint32 ,custom_header,custom_header.u32,71);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN(bool,SIS_3820_FRS::__match);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for SIS_3820_FRS.
 *
 * Do not edit - automatically generated.
 */

// SIS_3820_FRS()
template<typename __data_dest_t>
void PACKER_SIS_3820_FRS::__packer(__data_dest_t &__buffer)
{
  // MEMBER(DATA32 data[32] ZERO_SUPPRESS);
  // UINT32 custom_header NOENCODE
  // {
    //  0_07: nchs;
    //  8_21: nevts;
    //    22: latching;
    // 23_26: data_format;
    // 27_31: id;
  // }
  // list(0<=index<custom_header.nchs)

  {
    // if((1 == custom_header.data_format))

    if ((1 == custom_header.data_format))
    {
      // UINT32 event NOENCODE
      // {
        //  0_31: val;
      // }
      // ENCODE(data[index],(value=event.val));

    }
    // if(((0 == custom_header.data_format) || (3 == custom_header.data_format)))

    if (((0 == custom_header.data_format) || (3 == custom_header.data_format)))
    {
      // UINT32 event NOENCODE
      // {
        //  0_23: val;
        // 24_28: channel;
        //    29: 0;
        // 30_31: user_bits;
      // }
      // ENCODE(data[event.channel],(value=event.val));

    }
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,SIS_3820_FRS::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: TAMEX4_EPOCH_DATA
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for TAMEX4_EPOCH_DATA.
 *
 * Do not edit - automatically generated.
 */

// TAMEX4_EPOCH_DATA(sfp,card,time_coarse,time_fine,time_edge,time_channel,
                  // time_epoch)
#if !PACKER_CODE
# define DECLARED_UNPACK_TAMEX4_EPOCH_DATA
class TAMEX4_EPOCH_DATA
#else//PACKER_CODE
# define DECLARED_PACKER_TAMEX4_EPOCH_DATA
class PACKER_TAMEX4_EPOCH_DATA
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA12 time_coarse[1024] NO_INDEX_LIST);
  // MEMBER(DATA12 time_fine[1024] NO_INDEX_LIST);
  // MEMBER(DATA12 time_edge[1024] NO_INDEX_LIST);
  // MEMBER(DATA12 time_channel[1024] NO_INDEX_LIST);
  // MEMBER(DATA32 time_epoch[1024] NO_INDEX_LIST);
  // UINT32 data NOENCODE
  // {
    //  0_27: epoch;
    // 28_31: 6;
    // ENCODE(time_coarse APPEND_LIST,(value=0));
    // ENCODE(time_fine APPEND_LIST,(value=0));
    // ENCODE(time_edge APPEND_LIST,(value=0));
    // ENCODE(time_channel APPEND_LIST,(value=0));
    // ENCODE(time_epoch APPEND_LIST,(value=epoch));
  // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 sfp,uint32 card,raw_list_ii_zero_suppress<DATA12,DATA12,1024> &time_coarse
                                      ,raw_list_ii_zero_suppress<DATA12,DATA12,1024> &time_fine
                                      ,raw_list_ii_zero_suppress<DATA12,DATA12,1024> &time_edge
                                      ,raw_list_ii_zero_suppress<DATA12,DATA12,1024> &time_channel
                                      ,raw_list_ii_zero_suppress<DATA32,DATA32,1024> &time_epoch);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 sfp,uint32 card);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 sfp,uint32 card,raw_list_ii_zero_suppress<DATA12,DATA12,1024> &time_coarse
                                       ,raw_list_ii_zero_suppress<DATA12,DATA12,1024> &time_fine
                                       ,raw_list_ii_zero_suppress<DATA12,DATA12,1024> &time_edge
                                       ,raw_list_ii_zero_suppress<DATA12,DATA12,1024> &time_channel
                                       ,raw_list_ii_zero_suppress<DATA32,DATA32,1024> &time_epoch);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(TAMEX4_EPOCH_DATA);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for TAMEX4_EPOCH_DATA.
 *
 * Do not edit - automatically generated.
 */

// TAMEX4_EPOCH_DATA(sfp,card,time_coarse,time_fine,time_edge,time_channel,
                  // time_epoch)
template<typename __data_src_t>
void TAMEX4_EPOCH_DATA::__unpack(__data_src_t &__buffer,uint32 sfp,uint32 card
                                                       ,raw_list_ii_zero_suppress<DATA12,DATA12,1024> &time_coarse
                                                       ,raw_list_ii_zero_suppress<DATA12,DATA12,1024> &time_fine
                                                       ,raw_list_ii_zero_suppress<DATA12,DATA12,1024> &time_edge
                                                       ,raw_list_ii_zero_suppress<DATA12,DATA12,1024> &time_channel
                                                       ,raw_list_ii_zero_suppress<DATA32,DATA32,1024> &time_epoch)
{
  if (__buffer.is_memberdump())
  {
    printf("          %s%s%s: \n", CT_OUT(BOLD_BLUE),  "TAMEX4_EPOCH_DATA",CT_OUT(NORM));
  }
  // MEMBER(DATA12 time_coarse[1024] NO_INDEX_LIST);
  // MEMBER(DATA12 time_fine[1024] NO_INDEX_LIST);
  // MEMBER(DATA12 time_edge[1024] NO_INDEX_LIST);
  // MEMBER(DATA12 time_channel[1024] NO_INDEX_LIST);
  // MEMBER(DATA32 time_epoch[1024] NO_INDEX_LIST);
  // UINT32 data NOENCODE
  // {
    //  0_27: epoch;
    // 28_31: 6;
    // ENCODE(time_coarse APPEND_LIST,(value=0));
    // ENCODE(time_fine APPEND_LIST,(value=0));
    // ENCODE(time_edge APPEND_LIST,(value=0));
    // ENCODE(time_channel APPEND_LIST,(value=0));
    // ENCODE(time_epoch APPEND_LIST,(value=epoch));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 epoch : 28; // 0..27
      uint32 unnamed_28_31 : 4; // 28..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_28_31 : 4; // 28..31
      uint32 epoch : 28; // 0..27
#endif
    };
    uint32  u32;
  } data;
  READ_FROM_BUFFER_FULL(389,uint32 ,data,data.u32,72);
  CHECK_BITS_EQUAL(383,data.unnamed_28_31,6);
  {
    {
      typedef __typeof__(*(&(time_coarse))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = time_coarse.append_item(384);
      __item.value = 0;
    }
    {
      typedef __typeof__(*(&(time_fine))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = time_fine.append_item(385);
      __item.value = 0;
    }
    {
      typedef __typeof__(*(&(time_edge))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = time_edge.append_item(386);
      __item.value = 0;
    }
    {
      typedef __typeof__(*(&(time_channel))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = time_channel.append_item(387);
      __item.value = 0;
    }
    {
      typedef __typeof__(*(&(time_epoch))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = time_epoch.append_item(388);
      __item.value = data.epoch;
    }
  }
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: data ", CT_OUT(BOLD), data.u32, CT_OUT(NORM));
    printf(".epoch=%s%7" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  data.epoch, CT_OUT(NORM));
    printf("\n");
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,TAMEX4_EPOCH_DATA::__unpack,uint32 sfp,uint32 card
                                                            ,raw_list_ii_zero_suppress<DATA12,DATA12,1024> &time_coarse
                                                            ,raw_list_ii_zero_suppress<DATA12,DATA12,1024> &time_fine
                                                            ,raw_list_ii_zero_suppress<DATA12,DATA12,1024> &time_edge
                                                            ,raw_list_ii_zero_suppress<DATA12,DATA12,1024> &time_channel
                                                            ,raw_list_ii_zero_suppress<DATA32,DATA32,1024> &time_epoch);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for TAMEX4_EPOCH_DATA.
 *
 * Do not edit - automatically generated.
 */

// TAMEX4_EPOCH_DATA(sfp,card,time_coarse,time_fine,time_edge,time_channel,
                  // time_epoch)
template<typename __data_src_t>
bool TAMEX4_EPOCH_DATA::__match(__data_src_t &__buffer,uint32 sfp,uint32 card)
{
  // MEMBER(DATA12 time_coarse[1024] NO_INDEX_LIST);
  // MEMBER(DATA12 time_fine[1024] NO_INDEX_LIST);
  // MEMBER(DATA12 time_edge[1024] NO_INDEX_LIST);
  // MEMBER(DATA12 time_channel[1024] NO_INDEX_LIST);
  // MEMBER(DATA32 time_epoch[1024] NO_INDEX_LIST);
  // UINT32 data NOENCODE
  // {
    //  0_27: epoch;
    // 28_31: 6;
    // ENCODE(time_coarse APPEND_LIST,(value=0));
    // ENCODE(time_fine APPEND_LIST,(value=0));
    // ENCODE(time_edge APPEND_LIST,(value=0));
    // ENCODE(time_channel APPEND_LIST,(value=0));
    // ENCODE(time_epoch APPEND_LIST,(value=epoch));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 epoch : 28; // 0..27
      uint32 unnamed_28_31 : 4; // 28..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_28_31 : 4; // 28..31
      uint32 epoch : 28; // 0..27
#endif
    };
    uint32  u32;
  } data;
  MATCH_READ_FROM_BUFFER_FULL(389,uint32 ,data,data.u32,73);
  MATCH_BITS_EQUAL(383,data.unnamed_28_31,6);
  {
  }
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,TAMEX4_EPOCH_DATA::__match,uint32 sfp,uint32 card);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for TAMEX4_EPOCH_DATA.
 *
 * Do not edit - automatically generated.
 */

// TAMEX4_EPOCH_DATA(sfp,card,time_coarse,time_fine,time_edge,time_channel,
                  // time_epoch)
template<typename __data_dest_t>
void PACKER_TAMEX4_EPOCH_DATA::__packer(__data_dest_t &__buffer,uint32 sfp
                                                               ,uint32 card
                                                               ,raw_list_ii_zero_suppress<DATA12,DATA12,1024> &time_coarse
                                                               ,raw_list_ii_zero_suppress<DATA12,DATA12,1024> &time_fine
                                                               ,raw_list_ii_zero_suppress<DATA12,DATA12,1024> &time_edge
                                                               ,raw_list_ii_zero_suppress<DATA12,DATA12,1024> &time_channel
                                                               ,raw_list_ii_zero_suppress<DATA32,DATA32,1024> &time_epoch)
{
  // MEMBER(DATA12 time_coarse[1024] NO_INDEX_LIST);
  // MEMBER(DATA12 time_fine[1024] NO_INDEX_LIST);
  // MEMBER(DATA12 time_edge[1024] NO_INDEX_LIST);
  // MEMBER(DATA12 time_channel[1024] NO_INDEX_LIST);
  // MEMBER(DATA32 time_epoch[1024] NO_INDEX_LIST);
  // UINT32 data NOENCODE
  // {
    //  0_27: epoch;
    // 28_31: 6;
    // ENCODE(time_coarse APPEND_LIST,(value=0));
    // ENCODE(time_fine APPEND_LIST,(value=0));
    // ENCODE(time_edge APPEND_LIST,(value=0));
    // ENCODE(time_channel APPEND_LIST,(value=0));
    // ENCODE(time_epoch APPEND_LIST,(value=epoch));
  // }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,TAMEX4_EPOCH_DATA::__packer,uint32 sfp,uint32 card);

/** END_PACKER ********************************************************/

//
// Generating code for: TAMEX4_HEADER
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for TAMEX4_HEADER.
 *
 * Do not edit - automatically generated.
 */

// TAMEX4_HEADER()
#if !PACKER_CODE
# define DECLARED_UNPACK_TAMEX4_HEADER
class TAMEX4_HEADER
#else//PACKER_CODE
# define DECLARED_PACKER_TAMEX4_HEADER
class PACKER_TAMEX4_HEADER
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA16 post_trig_ns[64] NO_INDEX_LIST);
  raw_list_ii_zero_suppress<DATA16,DATA16,64> post_trig_ns;
  // MEMBER(DATA16 pre_trig_ns[64] NO_INDEX_LIST);
  raw_list_ii_zero_suppress<DATA16,DATA16,64> pre_trig_ns;
  // UINT32 trigger_window NOENCODE
  // {
    //  0_15: post_trig_ns;
    // 16_31: pre_trig_ns;
    // ENCODE(post_trig_ns APPEND_LIST,(value=post_trig_ns));
    // ENCODE(pre_trig_ns APPEND_LIST,(value=pre_trig_ns));
  // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(TAMEX4_HEADER);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for TAMEX4_HEADER.
 *
 * Do not edit - automatically generated.
 */

// TAMEX4_HEADER()
template<typename __data_src_t>
void TAMEX4_HEADER::__unpack(__data_src_t &__buffer)
{
  if (__buffer.is_memberdump())
  {
    printf("          %s%s%s: \n", CT_OUT(BOLD_BLUE),  "TAMEX4_HEADER",CT_OUT(NORM));
  }
  // MEMBER(DATA16 post_trig_ns[64] NO_INDEX_LIST);
  // MEMBER(DATA16 pre_trig_ns[64] NO_INDEX_LIST);
  // UINT32 trigger_window NOENCODE
  // {
    //  0_15: post_trig_ns;
    // 16_31: pre_trig_ns;
    // ENCODE(post_trig_ns APPEND_LIST,(value=post_trig_ns));
    // ENCODE(pre_trig_ns APPEND_LIST,(value=pre_trig_ns));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 post_trig_ns : 16; // 0..15
      uint32 pre_trig_ns : 16; // 16..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 pre_trig_ns : 16; // 16..31
      uint32 post_trig_ns : 16; // 0..15
#endif
    };
    uint32  u32;
  } trigger_window;
  READ_FROM_BUFFER_FULL(402,uint32 ,trigger_window,trigger_window.u32,74);
  {
    {
      typedef __typeof__(*(&(post_trig_ns))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = post_trig_ns.append_item(400);
      __item.value = trigger_window.post_trig_ns;
    }
    {
      typedef __typeof__(*(&(pre_trig_ns))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = pre_trig_ns.append_item(401);
      __item.value = trigger_window.pre_trig_ns;
    }
  }
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: trigger_window ", CT_OUT(BOLD), trigger_window.u32, CT_OUT(NORM));
    printf(".post_trig_ns=%s%4" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  trigger_window.post_trig_ns, CT_OUT(NORM));
    printf(".pre_trig_ns=%s%4" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  trigger_window.pre_trig_ns, CT_OUT(NORM));
    printf("\n");
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,TAMEX4_HEADER::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for TAMEX4_HEADER.
 *
 * Do not edit - automatically generated.
 */

// TAMEX4_HEADER()
template<typename __data_src_t>
bool TAMEX4_HEADER::__match(__data_src_t &__buffer)
{
  // MEMBER(DATA16 post_trig_ns[64] NO_INDEX_LIST);
  // MEMBER(DATA16 pre_trig_ns[64] NO_INDEX_LIST);
  // UINT32 trigger_window NOENCODE
  // {
    //  0_15: post_trig_ns;
    // 16_31: pre_trig_ns;
    // ENCODE(post_trig_ns APPEND_LIST,(value=post_trig_ns));
    // ENCODE(pre_trig_ns APPEND_LIST,(value=pre_trig_ns));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 post_trig_ns : 16; // 0..15
      uint32 pre_trig_ns : 16; // 16..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 pre_trig_ns : 16; // 16..31
      uint32 post_trig_ns : 16; // 0..15
#endif
    };
    uint32  u32;
  } trigger_window;
  MATCH_READ_FROM_BUFFER_FULL(402,uint32 ,trigger_window,trigger_window.u32,75);
  {
  }
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN(bool,TAMEX4_HEADER::__match);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for TAMEX4_HEADER.
 *
 * Do not edit - automatically generated.
 */

// TAMEX4_HEADER()
template<typename __data_dest_t>
void PACKER_TAMEX4_HEADER::__packer(__data_dest_t &__buffer)
{
  // MEMBER(DATA16 post_trig_ns[64] NO_INDEX_LIST);
  // MEMBER(DATA16 pre_trig_ns[64] NO_INDEX_LIST);
  // UINT32 trigger_window NOENCODE
  // {
    //  0_15: post_trig_ns;
    // 16_31: pre_trig_ns;
    // ENCODE(post_trig_ns APPEND_LIST,(value=post_trig_ns));
    // ENCODE(pre_trig_ns APPEND_LIST,(value=pre_trig_ns));
  // }
}
FORCE_IMPL_DATA_SRC_FCN(void,TAMEX4_HEADER::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: TAMEX4_PADDING
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for TAMEX4_PADDING.
 *
 * Do not edit - automatically generated.
 */

// TAMEX4_PADDING()
#if !PACKER_CODE
# define DECLARED_UNPACK_TAMEX4_PADDING
class TAMEX4_PADDING
#else//PACKER_CODE
# define DECLARED_PACKER_TAMEX4_PADDING
class PACKER_TAMEX4_PADDING
#endif//PACKER_CODE

{
public:
  // UINT32 padding NOENCODE
  // {
    //  0_11: counter;
    // 12_19: index;
    // 20_31: 0xadd;
  // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(TAMEX4_PADDING);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for TAMEX4_PADDING.
 *
 * Do not edit - automatically generated.
 */

// TAMEX4_PADDING()
template<typename __data_src_t>
void TAMEX4_PADDING::__unpack(__data_src_t &__buffer)
{
  if (__buffer.is_memberdump())
  {
    printf("          %s%s%s: \n", CT_OUT(BOLD_BLUE),  "TAMEX4_PADDING",CT_OUT(NORM));
  }
  // UINT32 padding NOENCODE
  // {
    //  0_11: counter;
    // 12_19: index;
    // 20_31: 0xadd;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 counter : 12; // 0..11
      uint32 index : 8; // 12..19
      uint32 unnamed_20_31 : 12; // 20..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_20_31 : 12; // 20..31
      uint32 index : 8; // 12..19
      uint32 counter : 12; // 0..11
#endif
    };
    uint32  u32;
  } padding;
  READ_FROM_BUFFER_FULL(412,uint32 ,padding,padding.u32,76);
  CHECK_BITS_EQUAL(411,padding.unnamed_20_31,0xadd);
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: padding ", CT_OUT(BOLD), padding.u32, CT_OUT(NORM));
    printf(".counter=%s%3" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  padding.counter, CT_OUT(NORM));
    printf(".index=%s%2" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  padding.index, CT_OUT(NORM));
    printf("\n");
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,TAMEX4_PADDING::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for TAMEX4_PADDING.
 *
 * Do not edit - automatically generated.
 */

// TAMEX4_PADDING()
template<typename __data_src_t>
bool TAMEX4_PADDING::__match(__data_src_t &__buffer)
{
  // UINT32 padding NOENCODE
  // {
    //  0_11: counter;
    // 12_19: index;
    // 20_31: 0xadd;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 counter : 12; // 0..11
      uint32 index : 8; // 12..19
      uint32 unnamed_20_31 : 12; // 20..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_20_31 : 12; // 20..31
      uint32 index : 8; // 12..19
      uint32 counter : 12; // 0..11
#endif
    };
    uint32  u32;
  } padding;
  MATCH_READ_FROM_BUFFER_FULL(412,uint32 ,padding,padding.u32,77);
  MATCH_BITS_EQUAL(411,padding.unnamed_20_31,0xadd);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN(bool,TAMEX4_PADDING::__match);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for TAMEX4_PADDING.
 *
 * Do not edit - automatically generated.
 */

// TAMEX4_PADDING()
template<typename __data_dest_t>
void PACKER_TAMEX4_PADDING::__packer(__data_dest_t &__buffer)
{
  // UINT32 padding NOENCODE
  // {
    //  0_11: counter;
    // 12_19: index;
    // 20_31: 0xadd;
  // }
}
FORCE_IMPL_DATA_SRC_FCN(void,TAMEX4_PADDING::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: TAMEX4_SFP
//
//
// Generating code for: TAMEX4_TIME_DATA
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for TAMEX4_TIME_DATA.
 *
 * Do not edit - automatically generated.
 */

// TAMEX4_TIME_DATA(sfp,card,time_coarse,time_fine,time_edge,time_channel,
                 // time_epoch)
#if !PACKER_CODE
# define DECLARED_UNPACK_TAMEX4_TIME_DATA
class TAMEX4_TIME_DATA
#else//PACKER_CODE
# define DECLARED_PACKER_TAMEX4_TIME_DATA
class PACKER_TAMEX4_TIME_DATA
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA12 time_coarse[1024] NO_INDEX_LIST);
  // MEMBER(DATA12 time_fine[1024] NO_INDEX_LIST);
  // MEMBER(DATA12 time_edge[1024] NO_INDEX_LIST);
  // MEMBER(DATA12 time_channel[1024] NO_INDEX_LIST);
  // MEMBER(DATA32 time_epoch[1024] NO_INDEX_LIST);
  // UINT32 data NOENCODE
  // {
    //  0_10: coarse;
    //    11: is_leading;
    // 12_21: fine;
    // 22_27: channel;
    // 28_31: type = CHECK(8);
    // ENCODE(time_coarse APPEND_LIST,(value=coarse));
    // ENCODE(time_fine APPEND_LIST,(value=fine));
    // ENCODE(time_edge APPEND_LIST,(value=is_leading));
    // ENCODE(time_channel APPEND_LIST,(value=channel));
    // ENCODE(time_epoch APPEND_LIST,(value=0));
  // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 sfp,uint32 card,raw_list_ii_zero_suppress<DATA12,DATA12,1024> &time_coarse
                                      ,raw_list_ii_zero_suppress<DATA12,DATA12,1024> &time_fine
                                      ,raw_list_ii_zero_suppress<DATA12,DATA12,1024> &time_edge
                                      ,raw_list_ii_zero_suppress<DATA12,DATA12,1024> &time_channel
                                      ,raw_list_ii_zero_suppress<DATA32,DATA32,1024> &time_epoch);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 sfp,uint32 card);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 sfp,uint32 card,raw_list_ii_zero_suppress<DATA12,DATA12,1024> &time_coarse
                                       ,raw_list_ii_zero_suppress<DATA12,DATA12,1024> &time_fine
                                       ,raw_list_ii_zero_suppress<DATA12,DATA12,1024> &time_edge
                                       ,raw_list_ii_zero_suppress<DATA12,DATA12,1024> &time_channel
                                       ,raw_list_ii_zero_suppress<DATA32,DATA32,1024> &time_epoch);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(TAMEX4_TIME_DATA);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for TAMEX4_TIME_DATA.
 *
 * Do not edit - automatically generated.
 */

// TAMEX4_TIME_DATA(sfp,card,time_coarse,time_fine,time_edge,time_channel,
                 // time_epoch)
template<typename __data_src_t>
void TAMEX4_TIME_DATA::__unpack(__data_src_t &__buffer,uint32 sfp,uint32 card
                                                      ,raw_list_ii_zero_suppress<DATA12,DATA12,1024> &time_coarse
                                                      ,raw_list_ii_zero_suppress<DATA12,DATA12,1024> &time_fine
                                                      ,raw_list_ii_zero_suppress<DATA12,DATA12,1024> &time_edge
                                                      ,raw_list_ii_zero_suppress<DATA12,DATA12,1024> &time_channel
                                                      ,raw_list_ii_zero_suppress<DATA32,DATA32,1024> &time_epoch)
{
  if (__buffer.is_memberdump())
  {
    printf("          %s%s%s: \n", CT_OUT(BOLD_BLUE),  "TAMEX4_TIME_DATA",CT_OUT(NORM));
  }
  // MEMBER(DATA12 time_coarse[1024] NO_INDEX_LIST);
  // MEMBER(DATA12 time_fine[1024] NO_INDEX_LIST);
  // MEMBER(DATA12 time_edge[1024] NO_INDEX_LIST);
  // MEMBER(DATA12 time_channel[1024] NO_INDEX_LIST);
  // MEMBER(DATA32 time_epoch[1024] NO_INDEX_LIST);
  // UINT32 data NOENCODE
  // {
    //  0_10: coarse;
    //    11: is_leading;
    // 12_21: fine;
    // 22_27: channel;
    // 28_31: type = CHECK(8);
    // ENCODE(time_coarse APPEND_LIST,(value=coarse));
    // ENCODE(time_fine APPEND_LIST,(value=fine));
    // ENCODE(time_edge APPEND_LIST,(value=is_leading));
    // ENCODE(time_channel APPEND_LIST,(value=channel));
    // ENCODE(time_epoch APPEND_LIST,(value=0));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 coarse : 11; // 0..10
      uint32 is_leading : 1; // 11
      uint32 fine : 10; // 12..21
      uint32 channel : 6; // 22..27
      uint32 type : 4; // 28..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 type : 4; // 28..31
      uint32 channel : 6; // 22..27
      uint32 fine : 10; // 12..21
      uint32 is_leading : 1; // 11
      uint32 coarse : 11; // 0..10
#endif
    };
    uint32  u32;
  } data;
  READ_FROM_BUFFER_FULL(492,uint32 ,data,data.u32,78);
  CHECK_BITS_EQUAL(486,data.type,8);
  {
    {
      typedef __typeof__(*(&(time_coarse))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = time_coarse.append_item(487);
      __item.value = data.coarse;
    }
    {
      typedef __typeof__(*(&(time_fine))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = time_fine.append_item(488);
      __item.value = data.fine;
    }
    {
      typedef __typeof__(*(&(time_edge))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = time_edge.append_item(489);
      __item.value = data.is_leading;
    }
    {
      typedef __typeof__(*(&(time_channel))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = time_channel.append_item(490);
      __item.value = data.channel;
    }
    {
      typedef __typeof__(*(&(time_epoch))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = time_epoch.append_item(491);
      __item.value = 0;
    }
  }
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: data ", CT_OUT(BOLD), data.u32, CT_OUT(NORM));
    printf(".coarse=%s%3" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  data.coarse, CT_OUT(NORM));
    printf(".is_leading=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  data.is_leading, CT_OUT(NORM));
    printf(".fine=%s%3" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  data.fine, CT_OUT(NORM));
    printf(".channel=%s%2" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  data.channel, CT_OUT(NORM));
    printf(".type=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  data.type, CT_OUT(NORM));
    printf("\n");
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,TAMEX4_TIME_DATA::__unpack,uint32 sfp,uint32 card
                                                           ,raw_list_ii_zero_suppress<DATA12,DATA12,1024> &time_coarse
                                                           ,raw_list_ii_zero_suppress<DATA12,DATA12,1024> &time_fine
                                                           ,raw_list_ii_zero_suppress<DATA12,DATA12,1024> &time_edge
                                                           ,raw_list_ii_zero_suppress<DATA12,DATA12,1024> &time_channel
                                                           ,raw_list_ii_zero_suppress<DATA32,DATA32,1024> &time_epoch);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for TAMEX4_TIME_DATA.
 *
 * Do not edit - automatically generated.
 */

// TAMEX4_TIME_DATA(sfp,card,time_coarse,time_fine,time_edge,time_channel,
                 // time_epoch)
template<typename __data_src_t>
bool TAMEX4_TIME_DATA::__match(__data_src_t &__buffer,uint32 sfp,uint32 card)
{
  // MEMBER(DATA12 time_coarse[1024] NO_INDEX_LIST);
  // MEMBER(DATA12 time_fine[1024] NO_INDEX_LIST);
  // MEMBER(DATA12 time_edge[1024] NO_INDEX_LIST);
  // MEMBER(DATA12 time_channel[1024] NO_INDEX_LIST);
  // MEMBER(DATA32 time_epoch[1024] NO_INDEX_LIST);
  // UINT32 data NOENCODE
  // {
    //  0_10: coarse;
    //    11: is_leading;
    // 12_21: fine;
    // 22_27: channel;
    // 28_31: type = CHECK(8);
    // ENCODE(time_coarse APPEND_LIST,(value=coarse));
    // ENCODE(time_fine APPEND_LIST,(value=fine));
    // ENCODE(time_edge APPEND_LIST,(value=is_leading));
    // ENCODE(time_channel APPEND_LIST,(value=channel));
    // ENCODE(time_epoch APPEND_LIST,(value=0));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 coarse : 11; // 0..10
      uint32 is_leading : 1; // 11
      uint32 fine : 10; // 12..21
      uint32 channel : 6; // 22..27
      uint32 type : 4; // 28..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 type : 4; // 28..31
      uint32 channel : 6; // 22..27
      uint32 fine : 10; // 12..21
      uint32 is_leading : 1; // 11
      uint32 coarse : 11; // 0..10
#endif
    };
    uint32  u32;
  } data;
  MATCH_READ_FROM_BUFFER_FULL(492,uint32 ,data,data.u32,79);
  MATCH_BITS_EQUAL(486,data.type,8);
  {
  }
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,TAMEX4_TIME_DATA::__match,uint32 sfp,uint32 card);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for TAMEX4_TIME_DATA.
 *
 * Do not edit - automatically generated.
 */

// TAMEX4_TIME_DATA(sfp,card,time_coarse,time_fine,time_edge,time_channel,
                 // time_epoch)
template<typename __data_dest_t>
void PACKER_TAMEX4_TIME_DATA::__packer(__data_dest_t &__buffer,uint32 sfp
                                                              ,uint32 card
                                                              ,raw_list_ii_zero_suppress<DATA12,DATA12,1024> &time_coarse
                                                              ,raw_list_ii_zero_suppress<DATA12,DATA12,1024> &time_fine
                                                              ,raw_list_ii_zero_suppress<DATA12,DATA12,1024> &time_edge
                                                              ,raw_list_ii_zero_suppress<DATA12,DATA12,1024> &time_channel
                                                              ,raw_list_ii_zero_suppress<DATA32,DATA32,1024> &time_epoch)
{
  // MEMBER(DATA12 time_coarse[1024] NO_INDEX_LIST);
  // MEMBER(DATA12 time_fine[1024] NO_INDEX_LIST);
  // MEMBER(DATA12 time_edge[1024] NO_INDEX_LIST);
  // MEMBER(DATA12 time_channel[1024] NO_INDEX_LIST);
  // MEMBER(DATA32 time_epoch[1024] NO_INDEX_LIST);
  // UINT32 data NOENCODE
  // {
    //  0_10: coarse;
    //    11: is_leading;
    // 12_21: fine;
    // 22_27: channel;
    // 28_31: type = CHECK(8);
    // ENCODE(time_coarse APPEND_LIST,(value=coarse));
    // ENCODE(time_fine APPEND_LIST,(value=fine));
    // ENCODE(time_edge APPEND_LIST,(value=is_leading));
    // ENCODE(time_channel APPEND_LIST,(value=channel));
    // ENCODE(time_epoch APPEND_LIST,(value=0));
  // }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,TAMEX4_TIME_DATA::__packer,uint32 sfp,uint32 card);

/** END_PACKER ********************************************************/


/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for TAMEX4_SFP.
 *
 * Do not edit - automatically generated.
 */

// TAMEX4_SFP(sfp,card)
#if !PACKER_CODE
# define DECLARED_UNPACK_TAMEX4_SFP
class TAMEX4_SFP
#else//PACKER_CODE
# define DECLARED_PACKER_TAMEX4_SFP
class PACKER_TAMEX4_SFP
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA32 event_size);
  DATA32 event_size;
  // MEMBER(DATA12 time_coarse[1024] NO_INDEX_LIST);
  raw_list_ii_zero_suppress<DATA12,DATA12,1024> time_coarse;
  // MEMBER(DATA12 time_fine[1024] NO_INDEX_LIST);
  raw_list_ii_zero_suppress<DATA12,DATA12,1024> time_fine;
  // MEMBER(DATA12 time_edge[1024] NO_INDEX_LIST);
  raw_list_ii_zero_suppress<DATA12,DATA12,1024> time_edge;
  // MEMBER(DATA12 time_channel[1024] NO_INDEX_LIST);
  raw_list_ii_zero_suppress<DATA12,DATA12,1024> time_channel;
  // MEMBER(DATA32 time_epoch[1024] NO_INDEX_LIST);
  raw_list_ii_zero_suppress<DATA32,DATA32,1024> time_epoch;
  // UINT32 indicator NOENCODE
  // {
    //  0_07: 52;
    //  8_11: trigger_type;
    // 12_15: sfp = MATCH(sfp);
    // 16_23: card = MATCH(card);
    // 24_31: 0;
  // }
  // MATCH_END;
  // UINT32 data_size NOENCODE
  // {
    //  0_31: bytes;
    // ENCODE(event_size,(value=bytes));
  // }
  // UINT32 tdc_header NOENCODE
  // {
    //  0_15: lec;
    //    16: buf_no;
    // 17_19: reserved;
    // 20_23: trigger_type;
    // 24_31: 170;
  // }
  // list(0<=i<((data_size.bytes / 4) - 3))

    // select

      // epoch = TAMEX4_EPOCH_DATA(sfp=sfp,card=card,time_coarse=time_coarse,
                                // time_fine=time_fine,time_edge=time_edge,
                                // time_channel=time_channel,time_epoch=time_epoch);
      // time = TAMEX4_TIME_DATA(sfp=sfp,card=card,time_coarse=time_coarse,
                              // time_fine=time_fine,time_edge=time_edge,
                              // time_channel=time_channel,time_epoch=time_epoch);
    SINGLE(TAMEX4_EPOCH_DATA,epoch);
    SINGLE(TAMEX4_TIME_DATA,time);
  // UINT32 error_bits NOENCODE
  // {
    //  0_23: bits;
    // 24_31: 238;
  // }
  // UINT32 trailer NOENCODE
  // {
    //  0_15: lec;
    //    16: buf_no;
    // 17_19: reserved;
    // 20_23: trigger_type;
    // 24_31: 187;
  // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 sfp,uint32 card);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 sfp,uint32 card);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 sfp,uint32 card);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(TAMEX4_SFP);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for TAMEX4_SFP.
 *
 * Do not edit - automatically generated.
 */

// TAMEX4_SFP(sfp,card)
template<typename __data_src_t>
void TAMEX4_SFP::__unpack(__data_src_t &__buffer,uint32 sfp,uint32 card)
{
  if (__buffer.is_memberdump())
  {
    printf("          %s%s%s: \n", CT_OUT(BOLD_BLUE),  "TAMEX4_SFP",CT_OUT(NORM));
  }
  // MEMBER(DATA32 event_size);
  // MEMBER(DATA12 time_coarse[1024] NO_INDEX_LIST);
  // MEMBER(DATA12 time_fine[1024] NO_INDEX_LIST);
  // MEMBER(DATA12 time_edge[1024] NO_INDEX_LIST);
  // MEMBER(DATA12 time_channel[1024] NO_INDEX_LIST);
  // MEMBER(DATA32 time_epoch[1024] NO_INDEX_LIST);
  // UINT32 indicator NOENCODE
  // {
    //  0_07: 52;
    //  8_11: trigger_type;
    // 12_15: sfp = MATCH(sfp);
    // 16_23: card = MATCH(card);
    // 24_31: 0;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 unnamed_0_7 : 8; // 0..7
      uint32 trigger_type : 4; // 8..11
      uint32 sfp : 4; // 12..15
      uint32 card : 8; // 16..23
      uint32 unnamed_24_31 : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_24_31 : 8; // 24..31
      uint32 card : 8; // 16..23
      uint32 sfp : 4; // 12..15
      uint32 trigger_type : 4; // 8..11
      uint32 unnamed_0_7 : 8; // 0..7
#endif
    };
    uint32  u32;
  } indicator;
  READ_FROM_BUFFER_FULL(430,uint32 ,indicator,indicator.u32,80);
  CHECK_BITS_EQUAL(425,indicator.unnamed_0_7,52);
  CHECK_BITS_EQUAL(427,indicator.sfp,sfp);
  CHECK_BITS_EQUAL(428,indicator.card,card);
  CHECK_BITS_EQUAL(429,indicator.unnamed_24_31,0);
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: indicator ", CT_OUT(BOLD), indicator.u32, CT_OUT(NORM));
    printf(".trigger_type=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  indicator.trigger_type, CT_OUT(NORM));
    printf(".sfp=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  indicator.sfp, CT_OUT(NORM));
    printf(".card=%s%2" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  indicator.card, CT_OUT(NORM));
    printf("\n");
  }
  // MATCH_END;
  // UINT32 data_size NOENCODE
  // {
    //  0_31: bytes;
    // ENCODE(event_size,(value=bytes));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 bytes : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 bytes : 32; // 0..31
#endif
    };
    uint32  u32;
  } data_size;
  READ_FROM_BUFFER_FULL(436,uint32 ,data_size,data_size.u32,81);
  {
    event_size.value = data_size.bytes;
  }
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: data_size ", CT_OUT(BOLD), data_size.u32, CT_OUT(NORM));
    printf(".bytes=%s%8" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  data_size.bytes, CT_OUT(NORM));
    printf("\n");
  }
  // UINT32 tdc_header NOENCODE
  // {
    //  0_15: lec;
    //    16: buf_no;
    // 17_19: reserved;
    // 20_23: trigger_type;
    // 24_31: 170;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 lec : 16; // 0..15
      uint32 buf_no : 1; // 16
      uint32 reserved : 3; // 17..19
      uint32 trigger_type : 4; // 20..23
      uint32 unnamed_24_31 : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_24_31 : 8; // 24..31
      uint32 trigger_type : 4; // 20..23
      uint32 reserved : 3; // 17..19
      uint32 buf_no : 1; // 16
      uint32 lec : 16; // 0..15
#endif
    };
    uint32  u32;
  } tdc_header;
  READ_FROM_BUFFER_FULL(444,uint32 ,tdc_header,tdc_header.u32,82);
  CHECK_BITS_EQUAL(443,tdc_header.unnamed_24_31,170);
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: tdc_header ", CT_OUT(BOLD), tdc_header.u32, CT_OUT(NORM));
    printf(".lec=%s%4" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  tdc_header.lec, CT_OUT(NORM));
    printf(".buf_no=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  tdc_header.buf_no, CT_OUT(NORM));
    printf(".reserved=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  tdc_header.reserved, CT_OUT(NORM));
    printf(".trigger_type=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  tdc_header.trigger_type, CT_OUT(NORM));
    printf("\n");
  }
  // list(0<=i<((data_size.bytes / 4) - 3))

  for (uint32 i = 0; i < (uint32) (((data_size.bytes / 4) - 3)); ++i)
  {
    // select

      // epoch = TAMEX4_EPOCH_DATA(sfp=sfp,card=card,time_coarse=time_coarse,
                                // time_fine=time_fine,time_edge=time_edge,
                                // time_channel=time_channel,time_epoch=time_epoch);
      // time = TAMEX4_TIME_DATA(sfp=sfp,card=card,time_coarse=time_coarse,
                              // time_fine=time_fine,time_edge=time_edge,
                              // time_channel=time_channel,time_epoch=time_epoch);
    do
    {
      int __match_no = 0;
      // optimized match 1: TAMEX4_EPOCH_DATA epoch: (s32) => (0xf0000000,0x60000000)
      // optimized match 2: TAMEX4_TIME_DATA time: (s32) => (0xf0000000,0x80000000)
      {
      uint32 __match_peek;
      PEEK_FROM_BUFFER(455,uint32,__match_peek);
      // differ = e0000000 : 29 30 31
      uint32 __match_index = 0 | /* 29,31 */ ((__match_peek >> 29) & 0x00000007);
      static const sint8 __match_index_array[8] = { 0, 0, 0, 1, 2, 0, 0, 0, };
      __match_no = __match_index_array[__match_index];
      // last_subevent_item = 0
      }
      if (!__match_no) ERROR_U_LOC(455,"No match for select statement.");
      switch (__match_no)
      {
        case 1:
          CHECK_SPURIOUS_MATCH_DECL(451,spurious_match_abort_loop_1,TAMEX4_EPOCH_DATA,/*sfp*/sfp,/*card*/card/*,time_coarse:member*//*,time_fine:member*//*,time_edge:member*//*,time_channel:member*//*,time_epoch:member*/);
          UNPACK_DECL(451,TAMEX4_EPOCH_DATA,epoch,/*sfp*/sfp,/*card*/card,/*time_coarse*/time_coarse,/*time_fine*/time_fine,/*time_edge*/time_edge,/*time_channel*/time_channel,/*time_epoch*/time_epoch);
          break;
        case 2:
          CHECK_SPURIOUS_MATCH_DECL(454,spurious_match_abort_loop_1,TAMEX4_TIME_DATA,/*sfp*/sfp,/*card*/card/*,time_coarse:member*//*,time_fine:member*//*,time_edge:member*//*,time_channel:member*//*,time_epoch:member*/);
          UNPACK_DECL(454,TAMEX4_TIME_DATA,time,/*sfp*/sfp,/*card*/card,/*time_coarse*/time_coarse,/*time_fine*/time_fine,/*time_edge*/time_edge,/*time_channel*/time_channel,/*time_epoch*/time_epoch);
          break;
      }
    }
    while (0);
    spurious_match_abort_loop_1:;
  }
  // UINT32 error_bits NOENCODE
  // {
    //  0_23: bits;
    // 24_31: 238;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 bits : 24; // 0..23
      uint32 unnamed_24_31 : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_24_31 : 8; // 24..31
      uint32 bits : 24; // 0..23
#endif
    };
    uint32  u32;
  } error_bits;
  READ_FROM_BUFFER_FULL(461,uint32 ,error_bits,error_bits.u32,83);
  CHECK_BITS_EQUAL(460,error_bits.unnamed_24_31,238);
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: error_bits ", CT_OUT(BOLD), error_bits.u32, CT_OUT(NORM));
    printf(".bits=%s%6" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  error_bits.bits, CT_OUT(NORM));
    printf("\n");
  }
  // UINT32 trailer NOENCODE
  // {
    //  0_15: lec;
    //    16: buf_no;
    // 17_19: reserved;
    // 20_23: trigger_type;
    // 24_31: 187;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 lec : 16; // 0..15
      uint32 buf_no : 1; // 16
      uint32 reserved : 3; // 17..19
      uint32 trigger_type : 4; // 20..23
      uint32 unnamed_24_31 : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_24_31 : 8; // 24..31
      uint32 trigger_type : 4; // 20..23
      uint32 reserved : 3; // 17..19
      uint32 buf_no : 1; // 16
      uint32 lec : 16; // 0..15
#endif
    };
    uint32  u32;
  } trailer;
  READ_FROM_BUFFER_FULL(469,uint32 ,trailer,trailer.u32,84);
  CHECK_BITS_EQUAL(468,trailer.unnamed_24_31,187);
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: trailer ", CT_OUT(BOLD), trailer.u32, CT_OUT(NORM));
    printf(".lec=%s%4" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  trailer.lec, CT_OUT(NORM));
    printf(".buf_no=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  trailer.buf_no, CT_OUT(NORM));
    printf(".reserved=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  trailer.reserved, CT_OUT(NORM));
    printf(".trigger_type=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  trailer.trigger_type, CT_OUT(NORM));
    printf("\n");
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,TAMEX4_SFP::__unpack,uint32 sfp,uint32 card);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for TAMEX4_SFP.
 *
 * Do not edit - automatically generated.
 */

// TAMEX4_SFP(sfp,card)
template<typename __data_src_t>
bool TAMEX4_SFP::__match(__data_src_t &__buffer,uint32 sfp,uint32 card)
{
  // MEMBER(DATA32 event_size);
  // MEMBER(DATA12 time_coarse[1024] NO_INDEX_LIST);
  // MEMBER(DATA12 time_fine[1024] NO_INDEX_LIST);
  // MEMBER(DATA12 time_edge[1024] NO_INDEX_LIST);
  // MEMBER(DATA12 time_channel[1024] NO_INDEX_LIST);
  // MEMBER(DATA32 time_epoch[1024] NO_INDEX_LIST);
  // UINT32 indicator NOENCODE
  // {
    //  0_07: 52;
    //  8_11: trigger_type;
    // 12_15: sfp = MATCH(sfp);
    // 16_23: card = MATCH(card);
    // 24_31: 0;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 unnamed_0_7 : 8; // 0..7
      uint32 trigger_type : 4; // 8..11
      uint32 sfp : 4; // 12..15
      uint32 card : 8; // 16..23
      uint32 unnamed_24_31 : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_24_31 : 8; // 24..31
      uint32 card : 8; // 16..23
      uint32 sfp : 4; // 12..15
      uint32 trigger_type : 4; // 8..11
      uint32 unnamed_0_7 : 8; // 0..7
#endif
    };
    uint32  u32;
  } indicator;
  MATCH_READ_FROM_BUFFER_FULL(430,uint32 ,indicator,indicator.u32,85);
  MATCH_BITS_EQUAL(425,indicator.unnamed_0_7,52);
  MATCH_BITS_EQUAL(427,indicator.sfp,sfp);
  MATCH_BITS_EQUAL(428,indicator.card,card);
  MATCH_BITS_EQUAL(429,indicator.unnamed_24_31,0);
  // MATCH_END;
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,TAMEX4_SFP::__match,uint32 sfp,uint32 card);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for TAMEX4_SFP.
 *
 * Do not edit - automatically generated.
 */

// TAMEX4_SFP(sfp,card)
template<typename __data_dest_t>
void PACKER_TAMEX4_SFP::__packer(__data_dest_t &__buffer,uint32 sfp,uint32 card)
{
  // MEMBER(DATA32 event_size);
  // MEMBER(DATA12 time_coarse[1024] NO_INDEX_LIST);
  // MEMBER(DATA12 time_fine[1024] NO_INDEX_LIST);
  // MEMBER(DATA12 time_edge[1024] NO_INDEX_LIST);
  // MEMBER(DATA12 time_channel[1024] NO_INDEX_LIST);
  // MEMBER(DATA32 time_epoch[1024] NO_INDEX_LIST);
  // UINT32 indicator NOENCODE
  // {
    //  0_07: 52;
    //  8_11: trigger_type;
    // 12_15: sfp = MATCH(sfp);
    // 16_23: card = MATCH(card);
    // 24_31: 0;
  // }
  // MATCH_END;
  // UINT32 data_size NOENCODE
  // {
    //  0_31: bytes;
    // ENCODE(event_size,(value=bytes));
  // }
  // UINT32 tdc_header NOENCODE
  // {
    //  0_15: lec;
    //    16: buf_no;
    // 17_19: reserved;
    // 20_23: trigger_type;
    // 24_31: 170;
  // }
  // list(0<=i<((data_size.bytes / 4) - 3))

  {
    // select

      // epoch = TAMEX4_EPOCH_DATA(sfp=sfp,card=card,time_coarse=time_coarse,
                                // time_fine=time_fine,time_edge=time_edge,
                                // time_channel=time_channel,time_epoch=time_epoch);
      // time = TAMEX4_TIME_DATA(sfp=sfp,card=card,time_coarse=time_coarse,
                              // time_fine=time_fine,time_edge=time_edge,
                              // time_channel=time_channel,time_epoch=time_epoch);
    {
      PACK_DECL(451,TAMEX4_EPOCH_DATA,epoch,/*sfp*/sfp,/*card*/card,/*time_coarse*/time_coarse,/*time_fine*/time_fine,/*time_edge*/time_edge,/*time_channel*/time_channel,/*time_epoch*/time_epoch);
      PACK_DECL(454,TAMEX4_TIME_DATA,time,/*sfp*/sfp,/*card*/card,/*time_coarse*/time_coarse,/*time_fine*/time_fine,/*time_edge*/time_edge,/*time_channel*/time_channel,/*time_epoch*/time_epoch);
    }
  }
  // UINT32 error_bits NOENCODE
  // {
    //  0_23: bits;
    // 24_31: 238;
  // }
  // UINT32 trailer NOENCODE
  // {
    //  0_15: lec;
    //    16: buf_no;
    // 17_19: reserved;
    // 20_23: trigger_type;
    // 24_31: 187;
  // }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,TAMEX4_SFP::__packer,uint32 sfp,uint32 card);

/** END_PACKER ********************************************************/

//
// Generating code for: TDC_DATA_V1190
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for TDC_DATA_V1190.
 *
 * Do not edit - automatically generated.
 */

// TDC_DATA_V1190(data,leadOrTrail)
#if !PACKER_CODE
# define DECLARED_UNPACK_TDC_DATA_V1190
class TDC_DATA_V1190
#else//PACKER_CODE
# define DECLARED_PACKER_TDC_DATA_V1190
class PACKER_TDC_DATA_V1190
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA24 data[128] ZERO_SUPPRESS_MULTI(128));
  // MEMBER(DATA8 leadOrTrail[128] ZERO_SUPPRESS_MULTI(128));
  // UINT32 tdc_data NOENCODE
  // {
    //  0_18: tdc;
    // 19_25: chn;
    //    26: lot;
    // 27_31: 0;
    // ENCODE(data[chn],(value=tdc));
    // ENCODE(leadOrTrail[chn],(value=lot));
  // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,raw_array_multi_zero_suppress<DATA24,DATA24,128,128> &data
                                      ,raw_array_multi_zero_suppress<DATA8,DATA8,128,128> &leadOrTrail);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,raw_array_multi_zero_suppress<DATA24,DATA24,128,128> &data
                                       ,raw_array_multi_zero_suppress<DATA8,DATA8,128,128> &leadOrTrail);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(TDC_DATA_V1190);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for TDC_DATA_V1190.
 *
 * Do not edit - automatically generated.
 */

// TDC_DATA_V1190(data,leadOrTrail)
template<typename __data_src_t>
void TDC_DATA_V1190::__unpack(__data_src_t &__buffer,raw_array_multi_zero_suppress<DATA24,DATA24,128,128> &data
                                                    ,raw_array_multi_zero_suppress<DATA8,DATA8,128,128> &leadOrTrail)
{
  if (__buffer.is_memberdump())
  {
    printf("          %s%s%s: \n", CT_OUT(BOLD_BLUE),  "TDC_DATA_V1190",CT_OUT(NORM));
  }
  // MEMBER(DATA24 data[128] ZERO_SUPPRESS_MULTI(128));
  // MEMBER(DATA8 leadOrTrail[128] ZERO_SUPPRESS_MULTI(128));
  // UINT32 tdc_data NOENCODE
  // {
    //  0_18: tdc;
    // 19_25: chn;
    //    26: lot;
    // 27_31: 0;
    // ENCODE(data[chn],(value=tdc));
    // ENCODE(leadOrTrail[chn],(value=lot));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 tdc : 19; // 0..18
      uint32 chn : 7; // 19..25
      uint32 lot : 1; // 26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 lot : 1; // 26
      uint32 chn : 7; // 19..25
      uint32 tdc : 19; // 0..18
#endif
    };
    uint32  u32;
  } tdc_data;
  READ_FROM_BUFFER_FULL(507,uint32 ,tdc_data,tdc_data.u32,86);
  CHECK_BITS_EQUAL(504,tdc_data.unnamed_27_31,0);
  {
    {
      typedef __typeof__(*(&(data))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = data.insert_index(505,tdc_data.chn);
      __item.value = tdc_data.tdc;
    }
    {
      typedef __typeof__(*(&(leadOrTrail))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = leadOrTrail.insert_index(506,tdc_data.chn);
      __item.value = tdc_data.lot;
    }
  }
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: tdc_data ", CT_OUT(BOLD), tdc_data.u32, CT_OUT(NORM));
    printf(".tdc=%s%5" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  tdc_data.tdc, CT_OUT(NORM));
    printf(".chn=%s%2" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  tdc_data.chn, CT_OUT(NORM));
    printf(".lot=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  tdc_data.lot, CT_OUT(NORM));
    printf("\n");
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,TDC_DATA_V1190::__unpack,raw_array_multi_zero_suppress<DATA24,DATA24,128,128> &data
                                                         ,raw_array_multi_zero_suppress<DATA8,DATA8,128,128> &leadOrTrail);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for TDC_DATA_V1190.
 *
 * Do not edit - automatically generated.
 */

// TDC_DATA_V1190(data,leadOrTrail)
template<typename __data_src_t>
bool TDC_DATA_V1190::__match(__data_src_t &__buffer)
{
  // MEMBER(DATA24 data[128] ZERO_SUPPRESS_MULTI(128));
  // MEMBER(DATA8 leadOrTrail[128] ZERO_SUPPRESS_MULTI(128));
  // UINT32 tdc_data NOENCODE
  // {
    //  0_18: tdc;
    // 19_25: chn;
    //    26: lot;
    // 27_31: 0;
    // ENCODE(data[chn],(value=tdc));
    // ENCODE(leadOrTrail[chn],(value=lot));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 tdc : 19; // 0..18
      uint32 chn : 7; // 19..25
      uint32 lot : 1; // 26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 lot : 1; // 26
      uint32 chn : 7; // 19..25
      uint32 tdc : 19; // 0..18
#endif
    };
    uint32  u32;
  } tdc_data;
  MATCH_READ_FROM_BUFFER_FULL(507,uint32 ,tdc_data,tdc_data.u32,87);
  MATCH_BITS_EQUAL(504,tdc_data.unnamed_27_31,0);
  {
  }
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN(bool,TDC_DATA_V1190::__match);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for TDC_DATA_V1190.
 *
 * Do not edit - automatically generated.
 */

// TDC_DATA_V1190(data,leadOrTrail)
template<typename __data_dest_t>
void PACKER_TDC_DATA_V1190::__packer(__data_dest_t &__buffer,raw_array_multi_zero_suppress<DATA24,DATA24,128,128> &data
                                                            ,raw_array_multi_zero_suppress<DATA8,DATA8,128,128> &leadOrTrail)
{
  // MEMBER(DATA24 data[128] ZERO_SUPPRESS_MULTI(128));
  // MEMBER(DATA8 leadOrTrail[128] ZERO_SUPPRESS_MULTI(128));
  // UINT32 tdc_data NOENCODE
  // {
    //  0_18: tdc;
    // 19_25: chn;
    //    26: lot;
    // 27_31: 0;
    // ENCODE(data[chn],(value=tdc));
    // ENCODE(leadOrTrail[chn],(value=lot));
  // }
}
FORCE_IMPL_DATA_SRC_FCN(void,TDC_DATA_V1190::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: TIMESTAMP_WHITERABBIT
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for TIMESTAMP_WHITERABBIT.
 *
 * Do not edit - automatically generated.
 */

// TIMESTAMP_WHITERABBIT(id)
#if !PACKER_CODE
# define DECLARED_UNPACK_TIMESTAMP_WHITERABBIT
class TIMESTAMP_WHITERABBIT
#else//PACKER_CODE
# define DECLARED_PACKER_TIMESTAMP_WHITERABBIT
class PACKER_TIMESTAMP_WHITERABBIT
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA12 subsystem_id);
  DATA12 subsystem_id;
  // MEMBER(DATA16 t1);
  DATA16 t1;
  // MEMBER(DATA16 t2);
  DATA16 t2;
  // MEMBER(DATA16 t3);
  DATA16 t3;
  // MEMBER(DATA16 t4);
  DATA16 t4;
  // UINT32 header NOENCODE
  // {
    //  0_11: id = MATCH(id);
    // 12_15: 0;
    //    16: error_bit;
    // 17_31: 0;
    // ENCODE(subsystem_id,(value=id));
  // }
  // UINT32 d1 NOENCODE
  // {
    //  0_15: t1;
    // 16_31: 0x3e1;
    // ENCODE(t1,(value=t1));
  // }
  // UINT32 d2 NOENCODE
  // {
    //  0_15: t2;
    // 16_31: 0x4e1;
    // ENCODE(t2,(value=t2));
  // }
  // UINT32 d3 NOENCODE
  // {
    //  0_15: t3;
    // 16_31: 0x5e1;
    // ENCODE(t3,(value=t3));
  // }
  // UINT32 d4 NOENCODE
  // {
    //  0_15: t4;
    // 16_31: 0x6e1;
    // ENCODE(t4,(value=t4));
  // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 id);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 id);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 id);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(TIMESTAMP_WHITERABBIT);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for TIMESTAMP_WHITERABBIT.
 *
 * Do not edit - automatically generated.
 */

// TIMESTAMP_WHITERABBIT(id)
template<typename __data_src_t>
void TIMESTAMP_WHITERABBIT::__unpack(__data_src_t &__buffer,uint32 id)
{
  if (__buffer.is_memberdump())
  {
    printf("          %s%s%s: \n", CT_OUT(BOLD_BLUE),  "TIMESTAMP_WHITERABBIT",CT_OUT(NORM));
  }
  // MEMBER(DATA12 subsystem_id);
  // MEMBER(DATA16 t1);
  // MEMBER(DATA16 t2);
  // MEMBER(DATA16 t3);
  // MEMBER(DATA16 t4);
  // UINT32 header NOENCODE
  // {
    //  0_11: id = MATCH(id);
    // 12_15: 0;
    //    16: error_bit;
    // 17_31: 0;
    // ENCODE(subsystem_id,(value=id));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 id : 12; // 0..11
      uint32 unnamed_12_15 : 4; // 12..15
      uint32 error_bit : 1; // 16
      uint32 unnamed_17_31 : 15; // 17..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_17_31 : 15; // 17..31
      uint32 error_bit : 1; // 16
      uint32 unnamed_12_15 : 4; // 12..15
      uint32 id : 12; // 0..11
#endif
    };
    uint32  u32;
  } header;
  READ_FROM_BUFFER_FULL(575,uint32 ,header,header.u32,88);
  CHECK_BITS_EQUAL(570,header.id,id);
  CHECK_BITS_EQUAL(571,header.unnamed_12_15,0);
  CHECK_BITS_EQUAL(573,header.unnamed_17_31,0);
  {
    subsystem_id.value = header.id;
  }
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: header ", CT_OUT(BOLD), header.u32, CT_OUT(NORM));
    printf(".id=%s%3" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  header.id, CT_OUT(NORM));
    printf(".error_bit=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  header.error_bit, CT_OUT(NORM));
    printf("\n");
  }
  // UINT32 d1 NOENCODE
  // {
    //  0_15: t1;
    // 16_31: 0x3e1;
    // ENCODE(t1,(value=t1));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 t1 : 16; // 0..15
      uint32 unnamed_16_31 : 16; // 16..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_16_31 : 16; // 16..31
      uint32 t1 : 16; // 0..15
#endif
    };
    uint32  u32;
  } d1;
  READ_FROM_BUFFER_FULL(581,uint32 ,d1,d1.u32,89);
  CHECK_BITS_EQUAL(579,d1.unnamed_16_31,0x3e1);
  {
    t1.value = d1.t1;
  }
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: d1 ", CT_OUT(BOLD), d1.u32, CT_OUT(NORM));
    printf(".t1=%s%4" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  d1.t1, CT_OUT(NORM));
    printf("\n");
  }
  // UINT32 d2 NOENCODE
  // {
    //  0_15: t2;
    // 16_31: 0x4e1;
    // ENCODE(t2,(value=t2));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 t2 : 16; // 0..15
      uint32 unnamed_16_31 : 16; // 16..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_16_31 : 16; // 16..31
      uint32 t2 : 16; // 0..15
#endif
    };
    uint32  u32;
  } d2;
  READ_FROM_BUFFER_FULL(587,uint32 ,d2,d2.u32,90);
  CHECK_BITS_EQUAL(585,d2.unnamed_16_31,0x4e1);
  {
    t2.value = d2.t2;
  }
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: d2 ", CT_OUT(BOLD), d2.u32, CT_OUT(NORM));
    printf(".t2=%s%4" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  d2.t2, CT_OUT(NORM));
    printf("\n");
  }
  // UINT32 d3 NOENCODE
  // {
    //  0_15: t3;
    // 16_31: 0x5e1;
    // ENCODE(t3,(value=t3));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 t3 : 16; // 0..15
      uint32 unnamed_16_31 : 16; // 16..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_16_31 : 16; // 16..31
      uint32 t3 : 16; // 0..15
#endif
    };
    uint32  u32;
  } d3;
  READ_FROM_BUFFER_FULL(593,uint32 ,d3,d3.u32,91);
  CHECK_BITS_EQUAL(591,d3.unnamed_16_31,0x5e1);
  {
    t3.value = d3.t3;
  }
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: d3 ", CT_OUT(BOLD), d3.u32, CT_OUT(NORM));
    printf(".t3=%s%4" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  d3.t3, CT_OUT(NORM));
    printf("\n");
  }
  // UINT32 d4 NOENCODE
  // {
    //  0_15: t4;
    // 16_31: 0x6e1;
    // ENCODE(t4,(value=t4));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 t4 : 16; // 0..15
      uint32 unnamed_16_31 : 16; // 16..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_16_31 : 16; // 16..31
      uint32 t4 : 16; // 0..15
#endif
    };
    uint32  u32;
  } d4;
  READ_FROM_BUFFER_FULL(599,uint32 ,d4,d4.u32,92);
  CHECK_BITS_EQUAL(597,d4.unnamed_16_31,0x6e1);
  {
    t4.value = d4.t4;
  }
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: d4 ", CT_OUT(BOLD), d4.u32, CT_OUT(NORM));
    printf(".t4=%s%4" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  d4.t4, CT_OUT(NORM));
    printf("\n");
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,TIMESTAMP_WHITERABBIT::__unpack,uint32 id);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for TIMESTAMP_WHITERABBIT.
 *
 * Do not edit - automatically generated.
 */

// TIMESTAMP_WHITERABBIT(id)
template<typename __data_src_t>
bool TIMESTAMP_WHITERABBIT::__match(__data_src_t &__buffer,uint32 id)
{
  // MEMBER(DATA12 subsystem_id);
  // MEMBER(DATA16 t1);
  // MEMBER(DATA16 t2);
  // MEMBER(DATA16 t3);
  // MEMBER(DATA16 t4);
  // UINT32 header NOENCODE
  // {
    //  0_11: id = MATCH(id);
    // 12_15: 0;
    //    16: error_bit;
    // 17_31: 0;
    // ENCODE(subsystem_id,(value=id));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 id : 12; // 0..11
      uint32 unnamed_12_15 : 4; // 12..15
      uint32 error_bit : 1; // 16
      uint32 unnamed_17_31 : 15; // 17..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_17_31 : 15; // 17..31
      uint32 error_bit : 1; // 16
      uint32 unnamed_12_15 : 4; // 12..15
      uint32 id : 12; // 0..11
#endif
    };
    uint32  u32;
  } header;
  MATCH_READ_FROM_BUFFER_FULL(575,uint32 ,header,header.u32,93);
  MATCH_BITS_EQUAL(570,header.id,id);
  MATCH_BITS_EQUAL(571,header.unnamed_12_15,0);
  MATCH_BITS_EQUAL(573,header.unnamed_17_31,0);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,TIMESTAMP_WHITERABBIT::__match,uint32 id);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for TIMESTAMP_WHITERABBIT.
 *
 * Do not edit - automatically generated.
 */

// TIMESTAMP_WHITERABBIT(id)
template<typename __data_dest_t>
void PACKER_TIMESTAMP_WHITERABBIT::__packer(__data_dest_t &__buffer,uint32 id)
{
  // MEMBER(DATA12 subsystem_id);
  // MEMBER(DATA16 t1);
  // MEMBER(DATA16 t2);
  // MEMBER(DATA16 t3);
  // MEMBER(DATA16 t4);
  // UINT32 header NOENCODE
  // {
    //  0_11: id = MATCH(id);
    // 12_15: 0;
    //    16: error_bit;
    // 17_31: 0;
    // ENCODE(subsystem_id,(value=id));
  // }
  // UINT32 d1 NOENCODE
  // {
    //  0_15: t1;
    // 16_31: 0x3e1;
    // ENCODE(t1,(value=t1));
  // }
  // UINT32 d2 NOENCODE
  // {
    //  0_15: t2;
    // 16_31: 0x4e1;
    // ENCODE(t2,(value=t2));
  // }
  // UINT32 d3 NOENCODE
  // {
    //  0_15: t3;
    // 16_31: 0x5e1;
    // ENCODE(t3,(value=t3));
  // }
  // UINT32 d4 NOENCODE
  // {
    //  0_15: t4;
    // 16_31: 0x6e1;
    // ENCODE(t4,(value=t4));
  // }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,TIMESTAMP_WHITERABBIT::__packer,uint32 id);

/** END_PACKER ********************************************************/

//
// Generating code for: TIMESTAMP_WHITERABBIT_EXTENDED
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for TIMESTAMP_WHITERABBIT_EXTENDED.
 *
 * Do not edit - automatically generated.
 */

// TIMESTAMP_WHITERABBIT_EXTENDED(id)
#if !PACKER_CODE
# define DECLARED_UNPACK_TIMESTAMP_WHITERABBIT_EXTENDED
class TIMESTAMP_WHITERABBIT_EXTENDED
#else//PACKER_CODE
# define DECLARED_PACKER_TIMESTAMP_WHITERABBIT_EXTENDED
class PACKER_TIMESTAMP_WHITERABBIT_EXTENDED
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA16 subsystem_id);
  DATA16 subsystem_id;
  // MEMBER(DATA16 t1);
  DATA16 t1;
  // MEMBER(DATA16 t2);
  DATA16 t2;
  // MEMBER(DATA16 t3);
  DATA16 t3;
  // MEMBER(DATA16 t4);
  DATA16 t4;
  // UINT32 header NOENCODE
  // {
    //  0_12: id = MATCH(id);
    // 13_15: 0;
    //    16: error_bit;
    // 17_31: 0;
    // ENCODE(subsystem_id,(value=id));
  // }
  // UINT32 d1 NOENCODE
  // {
    //  0_15: t1;
    // 16_31: 0x3e1;
    // ENCODE(t1,(value=t1));
  // }
  // UINT32 d2 NOENCODE
  // {
    //  0_15: t2;
    // 16_31: 0x4e1;
    // ENCODE(t2,(value=t2));
  // }
  // UINT32 d3 NOENCODE
  // {
    //  0_15: t3;
    // 16_31: 0x5e1;
    // ENCODE(t3,(value=t3));
  // }
  // UINT32 d4 NOENCODE
  // {
    //  0_15: t4;
    // 16_31: 0x6e1;
    // ENCODE(t4,(value=t4));
  // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 id);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 id);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 id);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(TIMESTAMP_WHITERABBIT_EXTENDED);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for TIMESTAMP_WHITERABBIT_EXTENDED.
 *
 * Do not edit - automatically generated.
 */

// TIMESTAMP_WHITERABBIT_EXTENDED(id)
template<typename __data_src_t>
void TIMESTAMP_WHITERABBIT_EXTENDED::__unpack(__data_src_t &__buffer,uint32 id)
{
  if (__buffer.is_memberdump())
  {
    printf("          %s%s%s: \n", CT_OUT(BOLD_BLUE),  "TIMESTAMP_WHITERABBIT_EXTENDED",CT_OUT(NORM));
  }
  // MEMBER(DATA16 subsystem_id);
  // MEMBER(DATA16 t1);
  // MEMBER(DATA16 t2);
  // MEMBER(DATA16 t3);
  // MEMBER(DATA16 t4);
  // UINT32 header NOENCODE
  // {
    //  0_12: id = MATCH(id);
    // 13_15: 0;
    //    16: error_bit;
    // 17_31: 0;
    // ENCODE(subsystem_id,(value=id));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 id : 13; // 0..12
      uint32 unnamed_13_15 : 3; // 13..15
      uint32 error_bit : 1; // 16
      uint32 unnamed_17_31 : 15; // 17..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_17_31 : 15; // 17..31
      uint32 error_bit : 1; // 16
      uint32 unnamed_13_15 : 3; // 13..15
      uint32 id : 13; // 0..12
#endif
    };
    uint32  u32;
  } header;
  READ_FROM_BUFFER_FULL(616,uint32 ,header,header.u32,94);
  CHECK_BITS_EQUAL(611,header.id,id);
  CHECK_BITS_EQUAL(612,header.unnamed_13_15,0);
  CHECK_BITS_EQUAL(614,header.unnamed_17_31,0);
  {
    subsystem_id.value = header.id;
  }
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: header ", CT_OUT(BOLD), header.u32, CT_OUT(NORM));
    printf(".id=%s%4" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  header.id, CT_OUT(NORM));
    printf(".error_bit=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  header.error_bit, CT_OUT(NORM));
    printf("\n");
  }
  // UINT32 d1 NOENCODE
  // {
    //  0_15: t1;
    // 16_31: 0x3e1;
    // ENCODE(t1,(value=t1));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 t1 : 16; // 0..15
      uint32 unnamed_16_31 : 16; // 16..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_16_31 : 16; // 16..31
      uint32 t1 : 16; // 0..15
#endif
    };
    uint32  u32;
  } d1;
  READ_FROM_BUFFER_FULL(622,uint32 ,d1,d1.u32,95);
  CHECK_BITS_EQUAL(620,d1.unnamed_16_31,0x3e1);
  {
    t1.value = d1.t1;
  }
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: d1 ", CT_OUT(BOLD), d1.u32, CT_OUT(NORM));
    printf(".t1=%s%4" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  d1.t1, CT_OUT(NORM));
    printf("\n");
  }
  // UINT32 d2 NOENCODE
  // {
    //  0_15: t2;
    // 16_31: 0x4e1;
    // ENCODE(t2,(value=t2));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 t2 : 16; // 0..15
      uint32 unnamed_16_31 : 16; // 16..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_16_31 : 16; // 16..31
      uint32 t2 : 16; // 0..15
#endif
    };
    uint32  u32;
  } d2;
  READ_FROM_BUFFER_FULL(628,uint32 ,d2,d2.u32,96);
  CHECK_BITS_EQUAL(626,d2.unnamed_16_31,0x4e1);
  {
    t2.value = d2.t2;
  }
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: d2 ", CT_OUT(BOLD), d2.u32, CT_OUT(NORM));
    printf(".t2=%s%4" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  d2.t2, CT_OUT(NORM));
    printf("\n");
  }
  // UINT32 d3 NOENCODE
  // {
    //  0_15: t3;
    // 16_31: 0x5e1;
    // ENCODE(t3,(value=t3));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 t3 : 16; // 0..15
      uint32 unnamed_16_31 : 16; // 16..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_16_31 : 16; // 16..31
      uint32 t3 : 16; // 0..15
#endif
    };
    uint32  u32;
  } d3;
  READ_FROM_BUFFER_FULL(634,uint32 ,d3,d3.u32,97);
  CHECK_BITS_EQUAL(632,d3.unnamed_16_31,0x5e1);
  {
    t3.value = d3.t3;
  }
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: d3 ", CT_OUT(BOLD), d3.u32, CT_OUT(NORM));
    printf(".t3=%s%4" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  d3.t3, CT_OUT(NORM));
    printf("\n");
  }
  // UINT32 d4 NOENCODE
  // {
    //  0_15: t4;
    // 16_31: 0x6e1;
    // ENCODE(t4,(value=t4));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 t4 : 16; // 0..15
      uint32 unnamed_16_31 : 16; // 16..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_16_31 : 16; // 16..31
      uint32 t4 : 16; // 0..15
#endif
    };
    uint32  u32;
  } d4;
  READ_FROM_BUFFER_FULL(640,uint32 ,d4,d4.u32,98);
  CHECK_BITS_EQUAL(638,d4.unnamed_16_31,0x6e1);
  {
    t4.value = d4.t4;
  }
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: d4 ", CT_OUT(BOLD), d4.u32, CT_OUT(NORM));
    printf(".t4=%s%4" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  d4.t4, CT_OUT(NORM));
    printf("\n");
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,TIMESTAMP_WHITERABBIT_EXTENDED::__unpack,uint32 id);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for TIMESTAMP_WHITERABBIT_EXTENDED.
 *
 * Do not edit - automatically generated.
 */

// TIMESTAMP_WHITERABBIT_EXTENDED(id)
template<typename __data_src_t>
bool TIMESTAMP_WHITERABBIT_EXTENDED::__match(__data_src_t &__buffer,uint32 id)
{
  // MEMBER(DATA16 subsystem_id);
  // MEMBER(DATA16 t1);
  // MEMBER(DATA16 t2);
  // MEMBER(DATA16 t3);
  // MEMBER(DATA16 t4);
  // UINT32 header NOENCODE
  // {
    //  0_12: id = MATCH(id);
    // 13_15: 0;
    //    16: error_bit;
    // 17_31: 0;
    // ENCODE(subsystem_id,(value=id));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 id : 13; // 0..12
      uint32 unnamed_13_15 : 3; // 13..15
      uint32 error_bit : 1; // 16
      uint32 unnamed_17_31 : 15; // 17..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_17_31 : 15; // 17..31
      uint32 error_bit : 1; // 16
      uint32 unnamed_13_15 : 3; // 13..15
      uint32 id : 13; // 0..12
#endif
    };
    uint32  u32;
  } header;
  MATCH_READ_FROM_BUFFER_FULL(616,uint32 ,header,header.u32,99);
  MATCH_BITS_EQUAL(611,header.id,id);
  MATCH_BITS_EQUAL(612,header.unnamed_13_15,0);
  MATCH_BITS_EQUAL(614,header.unnamed_17_31,0);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,TIMESTAMP_WHITERABBIT_EXTENDED::__match,uint32 id);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for TIMESTAMP_WHITERABBIT_EXTENDED.
 *
 * Do not edit - automatically generated.
 */

// TIMESTAMP_WHITERABBIT_EXTENDED(id)
template<typename __data_dest_t>
void PACKER_TIMESTAMP_WHITERABBIT_EXTENDED::__packer(__data_dest_t &__buffer,uint32 id)
{
  // MEMBER(DATA16 subsystem_id);
  // MEMBER(DATA16 t1);
  // MEMBER(DATA16 t2);
  // MEMBER(DATA16 t3);
  // MEMBER(DATA16 t4);
  // UINT32 header NOENCODE
  // {
    //  0_12: id = MATCH(id);
    // 13_15: 0;
    //    16: error_bit;
    // 17_31: 0;
    // ENCODE(subsystem_id,(value=id));
  // }
  // UINT32 d1 NOENCODE
  // {
    //  0_15: t1;
    // 16_31: 0x3e1;
    // ENCODE(t1,(value=t1));
  // }
  // UINT32 d2 NOENCODE
  // {
    //  0_15: t2;
    // 16_31: 0x4e1;
    // ENCODE(t2,(value=t2));
  // }
  // UINT32 d3 NOENCODE
  // {
    //  0_15: t3;
    // 16_31: 0x5e1;
    // ENCODE(t3,(value=t3));
  // }
  // UINT32 d4 NOENCODE
  // {
    //  0_15: t4;
    // 16_31: 0x6e1;
    // ENCODE(t4,(value=t4));
  // }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,TIMESTAMP_WHITERABBIT_EXTENDED::__packer,uint32 id);

/** END_PACKER ********************************************************/

//
// Generating code for: TPC_CRATE_DATA
//
//
// Generating code for: VME_CAEN_V7X5_FRS
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for VME_CAEN_V7X5_FRS.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V7X5_FRS()
#if !PACKER_CODE
# define DECLARED_UNPACK_VME_CAEN_V7X5_FRS
class VME_CAEN_V7X5_FRS
#else//PACKER_CODE
# define DECLARED_PACKER_VME_CAEN_V7X5_FRS
class PACKER_VME_CAEN_V7X5_FRS
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA12_OVERFLOW data[32] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA12_OVERFLOW,DATA12_OVERFLOW,32> data;
  // MEMBER(DATA8 channel[32] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA8,DATA8,32> channel;
  // MEMBER(DATA8 geo[32] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA8,DATA8,32> geo;
  // UINT32 header NOENCODE
  // {
    //  0_07: undefined;
    //  8_13: count;
    // 16_23: crate;
    // 24_26: 2;
    // 27_31: geom;
  // }
  // list(0<=index<header.count)

    // UINT32 ch_data NOENCODE
    // {
      //  0_11: value;
      //    12: overflow;
      //    13: underflow;
      //    14: valid;
      //    15: undefined;
      // 16_20: channel;
      // 21_23: undefined2;
      // 24_26: 0;
      // 27_31: geom;
      // ENCODE(geo[index],(value=geom));
      // ENCODE(channel[index],(value=channel));
      // ENCODE(data[index],(value=value,overflow=overflow));
    // }
  // UINT32 eob NOENCODE
  // {
    //  0_23: nothing;
    // 24_26: 4;
    // 27_31: geom;
  // }
  // list(0<=i<2)

    // optional UINT32 eob2 NOENCODE
    // {
      //  0_23: nothing;
      // 24_26: id = MATCH(6);
      // 27_31: geom;
    // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(VME_CAEN_V7X5_FRS);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for VME_CAEN_V7X5_FRS.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V7X5_FRS()
template<typename __data_src_t>
void VME_CAEN_V7X5_FRS::__unpack(__data_src_t &__buffer)
{
  if (__buffer.is_memberdump())
  {
    printf("          %s%s%s: \n", CT_OUT(BOLD_BLUE),  "VME_CAEN_V7X5_FRS",CT_OUT(NORM));
  }
  // MEMBER(DATA12_OVERFLOW data[32] ZERO_SUPPRESS);
  // MEMBER(DATA8 channel[32] ZERO_SUPPRESS);
  // MEMBER(DATA8 geo[32] ZERO_SUPPRESS);
  // UINT32 header NOENCODE
  // {
    //  0_07: undefined;
    //  8_13: count;
    // 16_23: crate;
    // 24_26: 2;
    // 27_31: geom;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 undefined : 8; // 0..7
      uint32 count : 6; // 8..13
      uint32 dummy_14_15 : 2;
      uint32 crate : 8; // 16..23
      uint32 unnamed_24_26 : 3; // 24..26
      uint32 geom : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 geom : 5; // 27..31
      uint32 unnamed_24_26 : 3; // 24..26
      uint32 crate : 8; // 16..23
      uint32 dummy_14_15 : 2;
      uint32 count : 6; // 8..13
      uint32 undefined : 8; // 0..7
#endif
    };
    uint32  u32;
  } header;
  READ_FROM_BUFFER_FULL(865,uint32 ,header,header.u32,100);
  CHECK_BITS_EQUAL(863,header.unnamed_24_26,2);
  CHECK_UNNAMED_BITS_ZERO(865,header.u32,0x0000c000);
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: header ", CT_OUT(BOLD), header.u32, CT_OUT(NORM));
    printf(".undefined=%s%2" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  header.undefined, CT_OUT(NORM));
    printf(".count=%s%2" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  header.count, CT_OUT(NORM));
    printf(".crate=%s%2" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  header.crate, CT_OUT(NORM));
    printf(".geom=%s%2" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  header.geom, CT_OUT(NORM));
    printf("\n");
  }
  // list(0<=index<header.count)

  for (uint32 index = 0; index < (uint32) (header.count); ++index)
  {
    // UINT32 ch_data NOENCODE
    // {
      //  0_11: value;
      //    12: overflow;
      //    13: underflow;
      //    14: valid;
      //    15: undefined;
      // 16_20: channel;
      // 21_23: undefined2;
      // 24_26: 0;
      // 27_31: geom;
      // ENCODE(geo[index],(value=geom));
      // ENCODE(channel[index],(value=channel));
      // ENCODE(data[index],(value=value,overflow=overflow));
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 value : 12; // 0..11
        uint32 overflow : 1; // 12
        uint32 underflow : 1; // 13
        uint32 valid : 1; // 14
        uint32 undefined : 1; // 15
        uint32 channel : 5; // 16..20
        uint32 undefined2 : 3; // 21..23
        uint32 unnamed_24_26 : 3; // 24..26
        uint32 geom : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 geom : 5; // 27..31
        uint32 unnamed_24_26 : 3; // 24..26
        uint32 undefined2 : 3; // 21..23
        uint32 channel : 5; // 16..20
        uint32 undefined : 1; // 15
        uint32 valid : 1; // 14
        uint32 underflow : 1; // 13
        uint32 overflow : 1; // 12
        uint32 value : 12; // 0..11
#endif
      };
      uint32  u32;
    } ch_data;
    READ_FROM_BUFFER_FULL(882,uint32 ,ch_data,ch_data.u32,101);
    CHECK_BITS_EQUAL(877,ch_data.unnamed_24_26,0);
    {
      {
        typedef __typeof__(*(&(geo))) __array_t;
        typedef typename __array_t::item_t __item_t;
        __item_t &__item = geo.insert_index(879,index);
        __item.value = ch_data.geom;
      }
      {
        typedef __typeof__(*(&(channel))) __array_t;
        typedef typename __array_t::item_t __item_t;
        __item_t &__item = channel.insert_index(880,index);
        __item.value = ch_data.channel;
      }
      {
        typedef __typeof__(*(&(data))) __array_t;
        typedef typename __array_t::item_t __item_t;
        __item_t &__item = data.insert_index(881,index);
        __item.value = ch_data.value;
        __item.overflow = ch_data.overflow;
      }
    }
    if (__buffer.is_memberdump())
    {
      printf("%s%08" PRIx32 "%s: ch_data ", CT_OUT(BOLD), ch_data.u32, CT_OUT(NORM));
      printf(".value=%s%3" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  ch_data.value, CT_OUT(NORM));
      printf(".overflow=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  ch_data.overflow, CT_OUT(NORM));
      printf(".underflow=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  ch_data.underflow, CT_OUT(NORM));
      printf(".valid=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  ch_data.valid, CT_OUT(NORM));
      printf(".undefined=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  ch_data.undefined, CT_OUT(NORM));
      printf(".channel=%s%2" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  ch_data.channel, CT_OUT(NORM));
      printf(".undefined2=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  ch_data.undefined2, CT_OUT(NORM));
      printf(".geom=%s%2" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  ch_data.geom, CT_OUT(NORM));
      printf("\n");
    }
  }
  // UINT32 eob NOENCODE
  // {
    //  0_23: nothing;
    // 24_26: 4;
    // 27_31: geom;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 nothing : 24; // 0..23
      uint32 unnamed_24_26 : 3; // 24..26
      uint32 geom : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 geom : 5; // 27..31
      uint32 unnamed_24_26 : 3; // 24..26
      uint32 nothing : 24; // 0..23
#endif
    };
    uint32  u32;
  } eob;
  READ_FROM_BUFFER_FULL(889,uint32 ,eob,eob.u32,102);
  CHECK_BITS_EQUAL(887,eob.unnamed_24_26,4);
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: eob ", CT_OUT(BOLD), eob.u32, CT_OUT(NORM));
    printf(".nothing=%s%6" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  eob.nothing, CT_OUT(NORM));
    printf(".geom=%s%2" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  eob.geom, CT_OUT(NORM));
    printf("\n");
  }
  // list(0<=i<2)

  for (uint32 i = 0; i < (uint32) (2); ++i)
  {
    // optional UINT32 eob2 NOENCODE
    // {
      //  0_23: nothing;
      // 24_26: id = MATCH(6);
      // 27_31: geom;
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 nothing : 24; // 0..23
        uint32 id : 3; // 24..26
        uint32 geom : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 geom : 5; // 27..31
        uint32 id : 3; // 24..26
        uint32 nothing : 24; // 0..23
#endif
      };
      uint32  u32;
    } eob2;
    if (__buffer.empty()) goto data_done_7;
    PEEK_FROM_BUFFER_FULL(897,uint32 ,eob2,eob2.u32,103);
    CHECK_JUMP_BITS_EQUAL(895,eob2.id,6,data_done_7);
    __buffer.advance(sizeof(eob2.u32));
    if (__buffer.is_memberdump())
    {
      printf("%s%08" PRIx32 "%s: eob2 ", CT_OUT(BOLD), eob2.u32, CT_OUT(NORM));
      printf(".nothing=%s%6" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  eob2.nothing, CT_OUT(NORM));
      printf(".id=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  eob2.id, CT_OUT(NORM));
      printf(".geom=%s%2" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  eob2.geom, CT_OUT(NORM));
      printf("\n");
    }
    data_done_7:;
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,VME_CAEN_V7X5_FRS::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for VME_CAEN_V7X5_FRS.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V7X5_FRS()
template<typename __data_src_t>
bool VME_CAEN_V7X5_FRS::__match(__data_src_t &__buffer)
{
  // MEMBER(DATA12_OVERFLOW data[32] ZERO_SUPPRESS);
  // MEMBER(DATA8 channel[32] ZERO_SUPPRESS);
  // MEMBER(DATA8 geo[32] ZERO_SUPPRESS);
  // UINT32 header NOENCODE
  // {
    //  0_07: undefined;
    //  8_13: count;
    // 16_23: crate;
    // 24_26: 2;
    // 27_31: geom;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 undefined : 8; // 0..7
      uint32 count : 6; // 8..13
      uint32 dummy_14_15 : 2;
      uint32 crate : 8; // 16..23
      uint32 unnamed_24_26 : 3; // 24..26
      uint32 geom : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 geom : 5; // 27..31
      uint32 unnamed_24_26 : 3; // 24..26
      uint32 crate : 8; // 16..23
      uint32 dummy_14_15 : 2;
      uint32 count : 6; // 8..13
      uint32 undefined : 8; // 0..7
#endif
    };
    uint32  u32;
  } header;
  MATCH_READ_FROM_BUFFER_FULL(865,uint32 ,header,header.u32,104);
  MATCH_BITS_EQUAL(863,header.unnamed_24_26,2);
  MATCH_UNNAMED_BITS_ZERO(865,header.u32,0x0000c000);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN(bool,VME_CAEN_V7X5_FRS::__match);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for VME_CAEN_V7X5_FRS.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V7X5_FRS()
template<typename __data_dest_t>
void PACKER_VME_CAEN_V7X5_FRS::__packer(__data_dest_t &__buffer)
{
  // MEMBER(DATA12_OVERFLOW data[32] ZERO_SUPPRESS);
  // MEMBER(DATA8 channel[32] ZERO_SUPPRESS);
  // MEMBER(DATA8 geo[32] ZERO_SUPPRESS);
  // UINT32 header NOENCODE
  // {
    //  0_07: undefined;
    //  8_13: count;
    // 16_23: crate;
    // 24_26: 2;
    // 27_31: geom;
  // }
  // list(0<=index<header.count)

  {
    // UINT32 ch_data NOENCODE
    // {
      //  0_11: value;
      //    12: overflow;
      //    13: underflow;
      //    14: valid;
      //    15: undefined;
      // 16_20: channel;
      // 21_23: undefined2;
      // 24_26: 0;
      // 27_31: geom;
      // ENCODE(geo[index],(value=geom));
      // ENCODE(channel[index],(value=channel));
      // ENCODE(data[index],(value=value,overflow=overflow));
    // }
  }
  // UINT32 eob NOENCODE
  // {
    //  0_23: nothing;
    // 24_26: 4;
    // 27_31: geom;
  // }
  // list(0<=i<2)

  {
    // optional UINT32 eob2 NOENCODE
    // {
      //  0_23: nothing;
      // 24_26: id = MATCH(6);
      // 27_31: geom;
    // }
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,VME_CAEN_V7X5_FRS::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: VME_CAEN_V1190_FRS
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for VME_CAEN_V1190_FRS.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1190_FRS()
#if !PACKER_CODE
# define DECLARED_UNPACK_VME_CAEN_V1190_FRS
class VME_CAEN_V1190_FRS
#else//PACKER_CODE
# define DECLARED_PACKER_VME_CAEN_V1190_FRS
class PACKER_VME_CAEN_V1190_FRS
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA24 data[128] ZERO_SUPPRESS_MULTI(128));
  raw_array_multi_zero_suppress<DATA24,DATA24,128,128> data;
  // MEMBER(DATA8 leadOrTrail[128] ZERO_SUPPRESS_MULTI(128));
  raw_array_multi_zero_suppress<DATA8,DATA8,128,128> leadOrTrail;
  // UINT32 header NOENCODE
  // {
    //  0_04: geo;
    //  5_26: event_count;
    // 27_31: seven_f;
  // }
  // if((header.seven_f != 8))

    // UINT32 second1 NOENCODE
    // {
      //  0_31: 0xffffffff;
    // }
    // UINT32 real_header NOENCODE
    // {
      //  0_04: geo;
      //  5_26: event_count;
      // 27_31: 8;
    // }
  // select several

    // tdc_header = TDC_HEADER();
    // measurement = TDC_DATA_V1190(data=data,leadOrTrail=leadOrTrail);
    // tdc_error = TDC_ERROR();
    // tdc_trailer = TDC_TRAILER();
  SINGLE(TDC_HEADER,tdc_header);
  SINGLE(TDC_DATA_V1190,measurement);
  SINGLE(TDC_ERROR,tdc_error);
  SINGLE(TDC_TRAILER,tdc_trailer);
  // optional UINT32 ext_time_tag NOENCODE
  // {
    //  0_26: time_tag;
    // 27_31: 17;
  // }
  // UINT32 trailer NOENCODE
  // {
    //  0_04: geo;
    //  5_20: word_count;
    // 21_23: unused;
    //    24: tdc_error;
    //    25: overflow;
    //    26: trigger_lost;
    // 27_31: 16;
  // }
  // optional UINT32 eob NOENCODE;

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(VME_CAEN_V1190_FRS);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for VME_CAEN_V1190_FRS.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1190_FRS()
template<typename __data_src_t>
void VME_CAEN_V1190_FRS::__unpack(__data_src_t &__buffer)
{
  if (__buffer.is_memberdump())
  {
    printf("          %s%s%s: \n", CT_OUT(BOLD_BLUE),  "VME_CAEN_V1190_FRS",CT_OUT(NORM));
  }
  // MEMBER(DATA24 data[128] ZERO_SUPPRESS_MULTI(128));
  // MEMBER(DATA8 leadOrTrail[128] ZERO_SUPPRESS_MULTI(128));
  // UINT32 header NOENCODE
  // {
    //  0_04: geo;
    //  5_26: event_count;
    // 27_31: seven_f;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 geo : 5; // 0..4
      uint32 event_count : 22; // 5..26
      uint32 seven_f : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 seven_f : 5; // 27..31
      uint32 event_count : 22; // 5..26
      uint32 geo : 5; // 0..4
#endif
    };
    uint32  u32;
  } header;
  READ_FROM_BUFFER_FULL(736,uint32 ,header,header.u32,105);
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: header ", CT_OUT(BOLD), header.u32, CT_OUT(NORM));
    printf(".geo=%s%2" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  header.geo, CT_OUT(NORM));
    printf(".event_count=%s%6" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  header.event_count, CT_OUT(NORM));
    printf(".seven_f=%s%2" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  header.seven_f, CT_OUT(NORM));
    printf("\n");
  }
  // if((header.seven_f != 8))

  if ((header.seven_f != 8))
  {
    // UINT32 second1 NOENCODE
    // {
      //  0_31: 0xffffffff;
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 unnamed_0_31 : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 unnamed_0_31 : 32; // 0..31
#endif
      };
      uint32  u32;
    } second1;
    READ_FROM_BUFFER_FULL(742,uint32 ,second1,second1.u32,106);
    CHECK_BITS_EQUAL(741,second1.unnamed_0_31,0xffffffff);
    if (__buffer.is_memberdump())
    {
      printf("%s%08" PRIx32 "%s: second1 ", CT_OUT(BOLD), second1.u32, CT_OUT(NORM));
      printf("\n");
    }
    // UINT32 real_header NOENCODE
    // {
      //  0_04: geo;
      //  5_26: event_count;
      // 27_31: 8;
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 geo : 5; // 0..4
        uint32 event_count : 22; // 5..26
        uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 unnamed_27_31 : 5; // 27..31
        uint32 event_count : 22; // 5..26
        uint32 geo : 5; // 0..4
#endif
      };
      uint32  u32;
    } real_header;
    READ_FROM_BUFFER_FULL(748,uint32 ,real_header,real_header.u32,107);
    CHECK_BITS_EQUAL(747,real_header.unnamed_27_31,8);
    if (__buffer.is_memberdump())
    {
      printf("%s%08" PRIx32 "%s: real_header ", CT_OUT(BOLD), real_header.u32, CT_OUT(NORM));
      printf(".geo=%s%2" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  real_header.geo, CT_OUT(NORM));
      printf(".event_count=%s%6" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  real_header.event_count, CT_OUT(NORM));
      printf("\n");
    }
  }
  // select several

    // tdc_header = TDC_HEADER();
    // measurement = TDC_DATA_V1190(data=data,leadOrTrail=leadOrTrail);
    // tdc_error = TDC_ERROR();
    // tdc_trailer = TDC_TRAILER();
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: TDC_HEADER tdc_header: (s32) => (0xf8000000,0x08000000)
    // optimized match 2: TDC_DATA_V1190 measurement: (s32) => (0xf8000000,0x00000000)
    // optimized match 3: TDC_ERROR tdc_error: (s32) => (0xf8000000,0x20000000)
    // optimized match 4: TDC_TRAILER tdc_trailer: (s32) => (0xf8000000,0x18000000)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(756,uint32,__match_peek);
    // differ = 38000000 : 27 28 29
    uint32 __match_index = 0 | /* 27,29 */ ((__match_peek >> 27) & 0x00000007);
    static const sint8 __match_index_array[8] = { 2, 1, 0, 4, 3, 0, 0, 0, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 0
    }
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        CHECK_SPURIOUS_MATCH_DECL(752,spurious_match_abort_loop_2,TDC_HEADER);
        UNPACK_DECL(752,TDC_HEADER,tdc_header);
        break;
      case 2:
        CHECK_SPURIOUS_MATCH_DECL(753,spurious_match_abort_loop_2,TDC_DATA_V1190/*,data:member*//*,leadOrTrail:member*/);
        UNPACK_DECL(753,TDC_DATA_V1190,measurement,/*data*/data,/*leadOrTrail*/leadOrTrail);
        break;
      case 3:
        CHECK_SPURIOUS_MATCH_DECL(754,spurious_match_abort_loop_2,TDC_ERROR);
        UNPACK_DECL(754,TDC_ERROR,tdc_error);
        break;
      case 4:
        CHECK_SPURIOUS_MATCH_DECL(755,spurious_match_abort_loop_2,TDC_TRAILER);
        UNPACK_DECL(755,TDC_TRAILER,tdc_trailer);
        break;
    }
  }
  spurious_match_abort_loop_2:;
  // optional UINT32 ext_time_tag NOENCODE
  // {
    //  0_26: time_tag;
    // 27_31: 17;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 time_tag : 27; // 0..26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 time_tag : 27; // 0..26
#endif
    };
    uint32  u32;
  } ext_time_tag;
  if (__buffer.empty()) goto data_done_8;
  PEEK_FROM_BUFFER_FULL(761,uint32 ,ext_time_tag,ext_time_tag.u32,108);
  CHECK_JUMP_BITS_EQUAL(760,ext_time_tag.unnamed_27_31,17,data_done_8);
  __buffer.advance(sizeof(ext_time_tag.u32));
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: ext_time_tag ", CT_OUT(BOLD), ext_time_tag.u32, CT_OUT(NORM));
    printf(".time_tag=%s%7" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  ext_time_tag.time_tag, CT_OUT(NORM));
    printf("\n");
  }
  data_done_8:;
  // UINT32 trailer NOENCODE
  // {
    //  0_04: geo;
    //  5_20: word_count;
    // 21_23: unused;
    //    24: tdc_error;
    //    25: overflow;
    //    26: trigger_lost;
    // 27_31: 16;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 geo : 5; // 0..4
      uint32 word_count : 16; // 5..20
      uint32 unused : 3; // 21..23
      uint32 tdc_error : 1; // 24
      uint32 overflow : 1; // 25
      uint32 trigger_lost : 1; // 26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 trigger_lost : 1; // 26
      uint32 overflow : 1; // 25
      uint32 tdc_error : 1; // 24
      uint32 unused : 3; // 21..23
      uint32 word_count : 16; // 5..20
      uint32 geo : 5; // 0..4
#endif
    };
    uint32  u32;
  } trailer;
  READ_FROM_BUFFER_FULL(771,uint32 ,trailer,trailer.u32,109);
  CHECK_BITS_EQUAL(770,trailer.unnamed_27_31,16);
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: trailer ", CT_OUT(BOLD), trailer.u32, CT_OUT(NORM));
    printf(".geo=%s%2" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  trailer.geo, CT_OUT(NORM));
    printf(".word_count=%s%4" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  trailer.word_count, CT_OUT(NORM));
    printf(".unused=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  trailer.unused, CT_OUT(NORM));
    printf(".tdc_error=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  trailer.tdc_error, CT_OUT(NORM));
    printf(".overflow=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  trailer.overflow, CT_OUT(NORM));
    printf(".trigger_lost=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  trailer.trigger_lost, CT_OUT(NORM));
    printf("\n");
  }
  // optional UINT32 eob NOENCODE;
  uint32  eob;if (__buffer.empty()) goto data_done_9;
  READ_FROM_BUFFER(772,uint32 ,eob,110);
  data_done_9:;
}
FORCE_IMPL_DATA_SRC_FCN(void,VME_CAEN_V1190_FRS::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for VME_CAEN_V1190_FRS.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1190_FRS()
template<typename __data_src_t>
bool VME_CAEN_V1190_FRS::__match(__data_src_t &__buffer)
{
  // MEMBER(DATA24 data[128] ZERO_SUPPRESS_MULTI(128));
  // MEMBER(DATA8 leadOrTrail[128] ZERO_SUPPRESS_MULTI(128));
  // UINT32 header NOENCODE
  // {
    //  0_04: geo;
    //  5_26: event_count;
    // 27_31: seven_f;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 geo : 5; // 0..4
      uint32 event_count : 22; // 5..26
      uint32 seven_f : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 seven_f : 5; // 27..31
      uint32 event_count : 22; // 5..26
      uint32 geo : 5; // 0..4
#endif
    };
    uint32  u32;
  } header;
  MATCH_READ_FROM_BUFFER_FULL(736,uint32 ,header,header.u32,111);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN(bool,VME_CAEN_V1190_FRS::__match);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for VME_CAEN_V1190_FRS.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1190_FRS()
template<typename __data_dest_t>
void PACKER_VME_CAEN_V1190_FRS::__packer(__data_dest_t &__buffer)
{
  // MEMBER(DATA24 data[128] ZERO_SUPPRESS_MULTI(128));
  // MEMBER(DATA8 leadOrTrail[128] ZERO_SUPPRESS_MULTI(128));
  // UINT32 header NOENCODE
  // {
    //  0_04: geo;
    //  5_26: event_count;
    // 27_31: seven_f;
  // }
  // if((header.seven_f != 8))

  if ((header.seven_f != 8))
  {
    // UINT32 second1 NOENCODE
    // {
      //  0_31: 0xffffffff;
    // }
    // UINT32 real_header NOENCODE
    // {
      //  0_04: geo;
      //  5_26: event_count;
      // 27_31: 8;
    // }
  }
  // select several

    // tdc_header = TDC_HEADER();
    // measurement = TDC_DATA_V1190(data=data,leadOrTrail=leadOrTrail);
    // tdc_error = TDC_ERROR();
    // tdc_trailer = TDC_TRAILER();
  {
    PACK_DECL(752,TDC_HEADER,tdc_header);
    PACK_DECL(753,TDC_DATA_V1190,measurement,/*data*/data,/*leadOrTrail*/leadOrTrail);
    PACK_DECL(754,TDC_ERROR,tdc_error);
    PACK_DECL(755,TDC_TRAILER,tdc_trailer);
  }
  // optional UINT32 ext_time_tag NOENCODE
  // {
    //  0_26: time_tag;
    // 27_31: 17;
  // }
  // UINT32 trailer NOENCODE
  // {
    //  0_04: geo;
    //  5_20: word_count;
    // 21_23: unused;
    //    24: tdc_error;
    //    25: overflow;
    //    26: trigger_lost;
    // 27_31: 16;
  // }
  // optional UINT32 eob NOENCODE;
}
FORCE_IMPL_DATA_SRC_FCN(void,VME_CAEN_V1190_FRS::__packer);

/** END_PACKER ********************************************************/


/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for TPC_CRATE_DATA.
 *
 * Do not edit - automatically generated.
 */

// TPC_CRATE_DATA()
#if !PACKER_CODE
# define DECLARED_UNPACK_TPC_CRATE_DATA
class TPC_CRATE_DATA
#else//PACKER_CODE
# define DECLARED_PACKER_TPC_CRATE_DATA
class PACKER_TPC_CRATE_DATA
#endif//PACKER_CODE

{
public:
  // barrier[0] = BARRIER();
  // v775 = VME_CAEN_V7X5_FRS();
  // barrier[1] = BARRIER();
  // v785 = VME_CAEN_V7X5_FRS();
  // barrier[2] = BARRIER();
  // v1190 = VME_CAEN_V1190_FRS();
  SINGLE(BARRIER,barrier[3]);
  SINGLE(VME_CAEN_V7X5_FRS,v775);
  SINGLE(VME_CAEN_V7X5_FRS,v785);
  SINGLE(VME_CAEN_V1190_FRS,v1190);

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(TPC_CRATE_DATA);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for TPC_CRATE_DATA.
 *
 * Do not edit - automatically generated.
 */

// TPC_CRATE_DATA()
template<typename __data_src_t>
void TPC_CRATE_DATA::__unpack(__data_src_t &__buffer)
{
  if (__buffer.is_memberdump())
  {
    printf("          %s%s%s: \n", CT_OUT(BOLD_BLUE),  "TPC_CRATE_DATA",CT_OUT(NORM));
  }
  // barrier[0] = BARRIER();
  UNPACK_DECL(645,BARRIER,barrier[0]);
  // v775 = VME_CAEN_V7X5_FRS();
  UNPACK_DECL(646,VME_CAEN_V7X5_FRS,v775);
  // barrier[1] = BARRIER();
  UNPACK_DECL(647,BARRIER,barrier[1]);
  // v785 = VME_CAEN_V7X5_FRS();
  UNPACK_DECL(648,VME_CAEN_V7X5_FRS,v785);
  // barrier[2] = BARRIER();
  UNPACK_DECL(649,BARRIER,barrier[2]);
  // v1190 = VME_CAEN_V1190_FRS();
  UNPACK_DECL(650,VME_CAEN_V1190_FRS,v1190);
}
FORCE_IMPL_DATA_SRC_FCN(void,TPC_CRATE_DATA::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for TPC_CRATE_DATA.
 *
 * Do not edit - automatically generated.
 */

// TPC_CRATE_DATA()
template<typename __data_src_t>
bool TPC_CRATE_DATA::__match(__data_src_t &__buffer)
{
  // barrier[0] = BARRIER();
  CHECK_MATCH_DECL(645,BARRIER,barrier[0]);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN(bool,TPC_CRATE_DATA::__match);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for TPC_CRATE_DATA.
 *
 * Do not edit - automatically generated.
 */

// TPC_CRATE_DATA()
template<typename __data_dest_t>
void PACKER_TPC_CRATE_DATA::__packer(__data_dest_t &__buffer)
{
  // barrier[0] = BARRIER();
  PACK_DECL(645,BARRIER,barrier[0]);
  // v775 = VME_CAEN_V7X5_FRS();
  PACK_DECL(646,VME_CAEN_V7X5_FRS,v775);
  // barrier[1] = BARRIER();
  PACK_DECL(647,BARRIER,barrier[1]);
  // v785 = VME_CAEN_V7X5_FRS();
  PACK_DECL(648,VME_CAEN_V7X5_FRS,v785);
  // barrier[2] = BARRIER();
  PACK_DECL(649,BARRIER,barrier[2]);
  // v1190 = VME_CAEN_V1190_FRS();
  PACK_DECL(650,VME_CAEN_V1190_FRS,v1190);
}
FORCE_IMPL_DATA_SRC_FCN(void,TPC_CRATE_DATA::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: TRIG3EVENT
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for TRIG3EVENT.
 *
 * Do not edit - automatically generated.
 */

// TRIG3EVENT()
#if !PACKER_CODE
# define DECLARED_UNPACK_TRIG3EVENT
class TRIG3EVENT
#else//PACKER_CODE
# define DECLARED_PACKER_TRIG3EVENT
class PACKER_TRIG3EVENT
#endif//PACKER_CODE

{
public:
  // UINT32 trig3 NOENCODE
  // {
    //  0_31: 0x20202020;
  // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(TRIG3EVENT);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for TRIG3EVENT.
 *
 * Do not edit - automatically generated.
 */

// TRIG3EVENT()
template<typename __data_src_t>
void TRIG3EVENT::__unpack(__data_src_t &__buffer)
{
  if (__buffer.is_memberdump())
  {
    printf("          %s%s%s: \n", CT_OUT(BOLD_BLUE),  "TRIG3EVENT",CT_OUT(NORM));
  }
  // UINT32 trig3 NOENCODE
  // {
    //  0_31: 0x20202020;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 unnamed_0_31 : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_0_31 : 32; // 0..31
#endif
    };
    uint32  u32;
  } trig3;
  READ_FROM_BUFFER_FULL(658,uint32 ,trig3,trig3.u32,112);
  CHECK_BITS_EQUAL(657,trig3.unnamed_0_31,0x20202020);
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: trig3 ", CT_OUT(BOLD), trig3.u32, CT_OUT(NORM));
    printf("\n");
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,TRIG3EVENT::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for TRIG3EVENT.
 *
 * Do not edit - automatically generated.
 */

// TRIG3EVENT()
template<typename __data_src_t>
bool TRIG3EVENT::__match(__data_src_t &__buffer)
{
  // UINT32 trig3 NOENCODE
  // {
    //  0_31: 0x20202020;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 unnamed_0_31 : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_0_31 : 32; // 0..31
#endif
    };
    uint32  u32;
  } trig3;
  MATCH_READ_FROM_BUFFER_FULL(658,uint32 ,trig3,trig3.u32,113);
  MATCH_BITS_EQUAL(657,trig3.unnamed_0_31,0x20202020);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN(bool,TRIG3EVENT::__match);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for TRIG3EVENT.
 *
 * Do not edit - automatically generated.
 */

// TRIG3EVENT()
template<typename __data_dest_t>
void PACKER_TRIG3EVENT::__packer(__data_dest_t &__buffer)
{
  // UINT32 trig3 NOENCODE
  // {
    //  0_31: 0x20202020;
  // }
}
FORCE_IMPL_DATA_SRC_FCN(void,TRIG3EVENT::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: USER_CRATE_DATA
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for USER_CRATE_DATA.
 *
 * Do not edit - automatically generated.
 */

// USER_CRATE_DATA()
#if !PACKER_CODE
# define DECLARED_UNPACK_USER_CRATE_DATA
class USER_CRATE_DATA
#else//PACKER_CODE
# define DECLARED_PACKER_USER_CRATE_DATA
class PACKER_USER_CRATE_DATA
#endif//PACKER_CODE

{
public:
  // barrier[0] = BARRIER();
  // v830 = VME_CAEN_V830_FRS();
  // filler[0] = ZERO_FILLER();
  // barrier[1] = BARRIER();
  // v775[0] = VME_CAEN_V7X5_FRS();
  // barrier[2] = BARRIER();
  // v775[1] = VME_CAEN_V7X5_FRS();
  // barrier[3] = BARRIER();
  // v785[0] = VME_CAEN_V7X5_FRS();
  // barrier[4] = BARRIER();
  // v785[1] = VME_CAEN_V7X5_FRS();
  SINGLE(BARRIER,barrier[5]);
  SINGLE(VME_CAEN_V830_FRS,v830);
  SINGLE(ZERO_FILLER,filler[1]);
  SINGLE(VME_CAEN_V7X5_FRS,v775[2]);
  SINGLE(VME_CAEN_V7X5_FRS,v785[2]);

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(USER_CRATE_DATA);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for USER_CRATE_DATA.
 *
 * Do not edit - automatically generated.
 */

// USER_CRATE_DATA()
template<typename __data_src_t>
void USER_CRATE_DATA::__unpack(__data_src_t &__buffer)
{
  if (__buffer.is_memberdump())
  {
    printf("          %s%s%s: \n", CT_OUT(BOLD_BLUE),  "USER_CRATE_DATA",CT_OUT(NORM));
  }
  // barrier[0] = BARRIER();
  UNPACK_DECL(663,BARRIER,barrier[0]);
  // v830 = VME_CAEN_V830_FRS();
  UNPACK_DECL(664,VME_CAEN_V830_FRS,v830);
  // filler[0] = ZERO_FILLER();
  UNPACK_DECL(665,ZERO_FILLER,filler[0]);
  // barrier[1] = BARRIER();
  UNPACK_DECL(666,BARRIER,barrier[1]);
  // v775[0] = VME_CAEN_V7X5_FRS();
  UNPACK_DECL(667,VME_CAEN_V7X5_FRS,v775[0]);
  // barrier[2] = BARRIER();
  UNPACK_DECL(668,BARRIER,barrier[2]);
  // v775[1] = VME_CAEN_V7X5_FRS();
  UNPACK_DECL(669,VME_CAEN_V7X5_FRS,v775[1]);
  // barrier[3] = BARRIER();
  UNPACK_DECL(670,BARRIER,barrier[3]);
  // v785[0] = VME_CAEN_V7X5_FRS();
  UNPACK_DECL(671,VME_CAEN_V7X5_FRS,v785[0]);
  // barrier[4] = BARRIER();
  UNPACK_DECL(672,BARRIER,barrier[4]);
  // v785[1] = VME_CAEN_V7X5_FRS();
  UNPACK_DECL(673,VME_CAEN_V7X5_FRS,v785[1]);
}
FORCE_IMPL_DATA_SRC_FCN(void,USER_CRATE_DATA::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for USER_CRATE_DATA.
 *
 * Do not edit - automatically generated.
 */

// USER_CRATE_DATA()
template<typename __data_src_t>
bool USER_CRATE_DATA::__match(__data_src_t &__buffer)
{
  // barrier[0] = BARRIER();
  CHECK_MATCH_DECL(663,BARRIER,barrier[0]);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN(bool,USER_CRATE_DATA::__match);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for USER_CRATE_DATA.
 *
 * Do not edit - automatically generated.
 */

// USER_CRATE_DATA()
template<typename __data_dest_t>
void PACKER_USER_CRATE_DATA::__packer(__data_dest_t &__buffer)
{
  // barrier[0] = BARRIER();
  PACK_DECL(663,BARRIER,barrier[0]);
  // v830 = VME_CAEN_V830_FRS();
  PACK_DECL(664,VME_CAEN_V830_FRS,v830);
  // filler[0] = ZERO_FILLER();
  PACK_DECL(665,ZERO_FILLER,filler[0]);
  // barrier[1] = BARRIER();
  PACK_DECL(666,BARRIER,barrier[1]);
  // v775[0] = VME_CAEN_V7X5_FRS();
  PACK_DECL(667,VME_CAEN_V7X5_FRS,v775[0]);
  // barrier[2] = BARRIER();
  PACK_DECL(668,BARRIER,barrier[2]);
  // v775[1] = VME_CAEN_V7X5_FRS();
  PACK_DECL(669,VME_CAEN_V7X5_FRS,v775[1]);
  // barrier[3] = BARRIER();
  PACK_DECL(670,BARRIER,barrier[3]);
  // v785[0] = VME_CAEN_V7X5_FRS();
  PACK_DECL(671,VME_CAEN_V7X5_FRS,v785[0]);
  // barrier[4] = BARRIER();
  PACK_DECL(672,BARRIER,barrier[4]);
  // v785[1] = VME_CAEN_V7X5_FRS();
  PACK_DECL(673,VME_CAEN_V7X5_FRS,v785[1]);
}
FORCE_IMPL_DATA_SRC_FCN(void,USER_CRATE_DATA::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: VFTX2
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for VFTX2.
 *
 * Do not edit - automatically generated.
 */

// VFTX2(id)
#if !PACKER_CODE
# define DECLARED_UNPACK_VFTX2
class VFTX2
#else//PACKER_CODE
# define DECLARED_PACKER_VFTX2
class PACKER_VFTX2
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA12 time_fine[32] ZERO_SUPPRESS_MULTI(100));
  raw_array_multi_zero_suppress<DATA12,DATA12,32,100> time_fine;
  // MEMBER(DATA16 time_coarse[32] ZERO_SUPPRESS_MULTI(100));
  raw_array_multi_zero_suppress<DATA16,DATA16,32,100> time_coarse;
  // MEMBER(DATA16 time_trigger);
  DATA16 time_trigger;
  // UINT32 custom_header NOENCODE
  // {
    //  0_04: id = MATCH(id);
    //  5_08: internal_status;
    //  9_17: count;
    // 24_31: 171;
  // }
  // UINT32 trigger_window NOENCODE;
  // UINT32 status_register NOENCODE;
  // UINT32 mvlc_header NOENCODE
  // {
    //  0_15: words;
    // 16_31: mh = MATCH(0xf500);
  // }
  // UINT32 skip_event_header NOENCODE;
  // list(1<=index<mvlc_header.words)

    // UINT32 event NOENCODE
    // {
      //  0_10: time_fine;
      // 11_23: time_coarse;
      //    24: future;
      // 25_29: channel;
      // 30_31: meh;
      // ENCODE(time_fine[channel],(value=time_fine));
      // ENCODE(time_coarse[channel],(value=time_coarse));
    // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 id);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 id);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 id);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(VFTX2);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for VFTX2.
 *
 * Do not edit - automatically generated.
 */

// VFTX2(id)
template<typename __data_src_t>
void VFTX2::__unpack(__data_src_t &__buffer,uint32 id)
{
  if (__buffer.is_memberdump())
  {
    printf("          %s%s%s: \n", CT_OUT(BOLD_BLUE),  "VFTX2",CT_OUT(NORM));
  }
  // MEMBER(DATA12 time_fine[32] ZERO_SUPPRESS_MULTI(100));
  // MEMBER(DATA16 time_coarse[32] ZERO_SUPPRESS_MULTI(100));
  // MEMBER(DATA16 time_trigger);
  // UINT32 custom_header NOENCODE
  // {
    //  0_04: id = MATCH(id);
    //  5_08: internal_status;
    //  9_17: count;
    // 24_31: 171;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 id : 5; // 0..4
      uint32 internal_status : 4; // 5..8
      uint32 count : 9; // 9..17
      uint32 dummy_18_23 : 6;
      uint32 unnamed_24_31 : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_24_31 : 8; // 24..31
      uint32 dummy_18_23 : 6;
      uint32 count : 9; // 9..17
      uint32 internal_status : 4; // 5..8
      uint32 id : 5; // 0..4
#endif
    };
    uint32  u32;
  } custom_header;
  READ_FROM_BUFFER_FULL(687,uint32 ,custom_header,custom_header.u32,114);
  CHECK_BITS_EQUAL(683,custom_header.id,id);
  CHECK_BITS_EQUAL(686,custom_header.unnamed_24_31,171);
  CHECK_UNNAMED_BITS_ZERO(687,custom_header.u32,0x00fc0000);
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: custom_header ", CT_OUT(BOLD), custom_header.u32, CT_OUT(NORM));
    printf(".id=%s%2" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  custom_header.id, CT_OUT(NORM));
    printf(".internal_status=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  custom_header.internal_status, CT_OUT(NORM));
    printf(".count=%s%3" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  custom_header.count, CT_OUT(NORM));
    printf("\n");
  }
  // UINT32 trigger_window NOENCODE;
  uint32  trigger_window;READ_FROM_BUFFER(688,uint32 ,trigger_window,115);
  // UINT32 status_register NOENCODE;
  uint32  status_register;READ_FROM_BUFFER(689,uint32 ,status_register,116);
  // UINT32 mvlc_header NOENCODE
  // {
    //  0_15: words;
    // 16_31: mh = MATCH(0xf500);
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 words : 16; // 0..15
      uint32 mh : 16; // 16..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 mh : 16; // 16..31
      uint32 words : 16; // 0..15
#endif
    };
    uint32  u32;
  } mvlc_header;
  READ_FROM_BUFFER_FULL(694,uint32 ,mvlc_header,mvlc_header.u32,117);
  CHECK_BITS_EQUAL(693,mvlc_header.mh,0xf500);
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: mvlc_header ", CT_OUT(BOLD), mvlc_header.u32, CT_OUT(NORM));
    printf(".words=%s%4" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  mvlc_header.words, CT_OUT(NORM));
    printf(".mh=%s%4" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  mvlc_header.mh, CT_OUT(NORM));
    printf("\n");
  }
  // UINT32 skip_event_header NOENCODE;
  uint32  skip_event_header;READ_FROM_BUFFER(695,uint32 ,skip_event_header,118);
  // list(1<=index<mvlc_header.words)

  for (uint32 index = 1; index < (uint32) (mvlc_header.words); ++index)
  {
    // UINT32 event NOENCODE
    // {
      //  0_10: time_fine;
      // 11_23: time_coarse;
      //    24: future;
      // 25_29: channel;
      // 30_31: meh;
      // ENCODE(time_fine[channel],(value=time_fine));
      // ENCODE(time_coarse[channel],(value=time_coarse));
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 time_fine : 11; // 0..10
        uint32 time_coarse : 13; // 11..23
        uint32 future : 1; // 24
        uint32 channel : 5; // 25..29
        uint32 meh : 2; // 30..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 meh : 2; // 30..31
        uint32 channel : 5; // 25..29
        uint32 future : 1; // 24
        uint32 time_coarse : 13; // 11..23
        uint32 time_fine : 11; // 0..10
#endif
      };
      uint32  u32;
    } event;
    READ_FROM_BUFFER_FULL(707,uint32 ,event,event.u32,119);
    {
      {
        typedef __typeof__(*(&(time_fine))) __array_t;
        typedef typename __array_t::item_t __item_t;
        __item_t &__item = time_fine.insert_index(705,event.channel);
        __item.value = event.time_fine;
      }
      {
        typedef __typeof__(*(&(time_coarse))) __array_t;
        typedef typename __array_t::item_t __item_t;
        __item_t &__item = time_coarse.insert_index(706,event.channel);
        __item.value = event.time_coarse;
      }
    }
    if (__buffer.is_memberdump())
    {
      printf("%s%08" PRIx32 "%s: event ", CT_OUT(BOLD), event.u32, CT_OUT(NORM));
      printf(".time_fine=%s%3" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  event.time_fine, CT_OUT(NORM));
      printf(".time_coarse=%s%4" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  event.time_coarse, CT_OUT(NORM));
      printf(".future=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  event.future, CT_OUT(NORM));
      printf(".channel=%s%2" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  event.channel, CT_OUT(NORM));
      printf(".meh=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  event.meh, CT_OUT(NORM));
      printf("\n");
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VFTX2::__unpack,uint32 id);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for VFTX2.
 *
 * Do not edit - automatically generated.
 */

// VFTX2(id)
template<typename __data_src_t>
bool VFTX2::__match(__data_src_t &__buffer,uint32 id)
{
  // MEMBER(DATA12 time_fine[32] ZERO_SUPPRESS_MULTI(100));
  // MEMBER(DATA16 time_coarse[32] ZERO_SUPPRESS_MULTI(100));
  // MEMBER(DATA16 time_trigger);
  // UINT32 custom_header NOENCODE
  // {
    //  0_04: id = MATCH(id);
    //  5_08: internal_status;
    //  9_17: count;
    // 24_31: 171;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 id : 5; // 0..4
      uint32 internal_status : 4; // 5..8
      uint32 count : 9; // 9..17
      uint32 dummy_18_23 : 6;
      uint32 unnamed_24_31 : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_24_31 : 8; // 24..31
      uint32 dummy_18_23 : 6;
      uint32 count : 9; // 9..17
      uint32 internal_status : 4; // 5..8
      uint32 id : 5; // 0..4
#endif
    };
    uint32  u32;
  } custom_header;
  MATCH_READ_FROM_BUFFER_FULL(687,uint32 ,custom_header,custom_header.u32,120);
  MATCH_BITS_EQUAL(683,custom_header.id,id);
  MATCH_BITS_EQUAL(686,custom_header.unnamed_24_31,171);
  MATCH_UNNAMED_BITS_ZERO(687,custom_header.u32,0x00fc0000);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,VFTX2::__match,uint32 id);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for VFTX2.
 *
 * Do not edit - automatically generated.
 */

// VFTX2(id)
template<typename __data_dest_t>
void PACKER_VFTX2::__packer(__data_dest_t &__buffer,uint32 id)
{
  // MEMBER(DATA12 time_fine[32] ZERO_SUPPRESS_MULTI(100));
  // MEMBER(DATA16 time_coarse[32] ZERO_SUPPRESS_MULTI(100));
  // MEMBER(DATA16 time_trigger);
  // UINT32 custom_header NOENCODE
  // {
    //  0_04: id = MATCH(id);
    //  5_08: internal_status;
    //  9_17: count;
    // 24_31: 171;
  // }
  // UINT32 trigger_window NOENCODE;
  // UINT32 status_register NOENCODE;
  // UINT32 mvlc_header NOENCODE
  // {
    //  0_15: words;
    // 16_31: mh = MATCH(0xf500);
  // }
  // UINT32 skip_event_header NOENCODE;
  // list(1<=index<mvlc_header.words)

  {
    // UINT32 event NOENCODE
    // {
      //  0_10: time_fine;
      // 11_23: time_coarse;
      //    24: future;
      // 25_29: channel;
      // 30_31: meh;
      // ENCODE(time_fine[channel],(value=time_fine));
      // ENCODE(time_coarse[channel],(value=time_coarse));
    // }
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VFTX2::__packer,uint32 id);

/** END_PACKER ********************************************************/

//
// Generating code for: VFTX_CRATE_DATA
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for VFTX_CRATE_DATA.
 *
 * Do not edit - automatically generated.
 */

// VFTX_CRATE_DATA()
#if !PACKER_CODE
# define DECLARED_UNPACK_VFTX_CRATE_DATA
class VFTX_CRATE_DATA
#else//PACKER_CODE
# define DECLARED_PACKER_VFTX_CRATE_DATA
class PACKER_VFTX_CRATE_DATA
#endif//PACKER_CODE

{
public:
  // vftx = VFTX2(id=0);
  // barrier[1] = BARRIER();
  // mtdc = MESYTEC_MTDC32_FRS();
  // barrier[2] = BARRIER();
  // select optional

    // mqdc0 = MESYTEC_MQDC32_FRS();
  SINGLE(MESYTEC_MQDC32_FRS,mqdc0);
  // select optional

    // mqdc1 = MESYTEC_MQDC32_FRS();
  SINGLE(MESYTEC_MQDC32_FRS,mqdc1);
  SINGLE(VFTX2,vftx);
  SINGLE(BARRIER,barrier[3]);
  SINGLE(MESYTEC_MTDC32_FRS,mtdc);

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(VFTX_CRATE_DATA);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for VFTX_CRATE_DATA.
 *
 * Do not edit - automatically generated.
 */

// VFTX_CRATE_DATA()
template<typename __data_src_t>
void VFTX_CRATE_DATA::__unpack(__data_src_t &__buffer)
{
  if (__buffer.is_memberdump())
  {
    printf("          %s%s%s: \n", CT_OUT(BOLD_BLUE),  "VFTX_CRATE_DATA",CT_OUT(NORM));
  }
  // vftx = VFTX2(id=0);
  UNPACK_DECL(713,VFTX2,vftx,/*id*/0);
  // barrier[1] = BARRIER();
  UNPACK_DECL(714,BARRIER,barrier[1]);
  // mtdc = MESYTEC_MTDC32_FRS();
  UNPACK_DECL(715,MESYTEC_MTDC32_FRS,mtdc);
  // barrier[2] = BARRIER();
  UNPACK_DECL(716,BARRIER,barrier[2]);
  // select optional

    // mqdc0 = MESYTEC_MQDC32_FRS();
  do
  {
    if (__buffer.empty()) goto no_match_1;
    int __match_no = 0;
    // optimized match 1: MESYTEC_MQDC32_FRS mqdc0: (s32) => (0xff00f000,0x40000000)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(720,uint32,__match_peek);
    // differ = 00000000 :
    uint32 __match_index = 0;
    static const sint8 __match_index_array[1] = { 1, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 0
    }
    if (!__match_no) goto no_match_1;
    switch (__match_no)
    {
      case 1:
        CHECK_SPURIOUS_MATCH_DECL(719,spurious_match_abort_loop_3,MESYTEC_MQDC32_FRS);
        UNPACK_DECL(719,MESYTEC_MQDC32_FRS,mqdc0);
        break;
    }
  }
  while (0);
  spurious_match_abort_loop_3:;
    no_match_1:;
  // select optional

    // mqdc1 = MESYTEC_MQDC32_FRS();
  do
  {
    if (__buffer.empty()) goto no_match_2;
    int __match_no = 0;
    // optimized match 1: MESYTEC_MQDC32_FRS mqdc1: (s32) => (0xff00f000,0x40000000)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(724,uint32,__match_peek);
    // differ = 00000000 :
    uint32 __match_index = 0;
    static const sint8 __match_index_array[1] = { 1, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 0
    }
    if (!__match_no) goto no_match_2;
    switch (__match_no)
    {
      case 1:
        CHECK_SPURIOUS_MATCH_DECL(723,spurious_match_abort_loop_4,MESYTEC_MQDC32_FRS);
        UNPACK_DECL(723,MESYTEC_MQDC32_FRS,mqdc1);
        break;
    }
  }
  while (0);
  spurious_match_abort_loop_4:;
    no_match_2:;
}
FORCE_IMPL_DATA_SRC_FCN(void,VFTX_CRATE_DATA::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for VFTX_CRATE_DATA.
 *
 * Do not edit - automatically generated.
 */

// VFTX_CRATE_DATA()
template<typename __data_src_t>
bool VFTX_CRATE_DATA::__match(__data_src_t &__buffer)
{
  // vftx = VFTX2(id=0);
  CHECK_MATCH_DECL(713,VFTX2,vftx,/*id*/0);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN(bool,VFTX_CRATE_DATA::__match);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for VFTX_CRATE_DATA.
 *
 * Do not edit - automatically generated.
 */

// VFTX_CRATE_DATA()
template<typename __data_dest_t>
void PACKER_VFTX_CRATE_DATA::__packer(__data_dest_t &__buffer)
{
  // vftx = VFTX2(id=0);
  PACK_DECL(713,VFTX2,vftx,/*id*/0);
  // barrier[1] = BARRIER();
  PACK_DECL(714,BARRIER,barrier[1]);
  // mtdc = MESYTEC_MTDC32_FRS();
  PACK_DECL(715,MESYTEC_MTDC32_FRS,mtdc);
  // barrier[2] = BARRIER();
  PACK_DECL(716,BARRIER,barrier[2]);
  // select optional

    // mqdc0 = MESYTEC_MQDC32_FRS();
  {
    PACK_DECL(719,MESYTEC_MQDC32_FRS,mqdc0);
  }
  // select optional

    // mqdc1 = MESYTEC_MQDC32_FRS();
  {
    PACK_DECL(723,MESYTEC_MQDC32_FRS,mqdc1);
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,VFTX_CRATE_DATA::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: WR_MULTI
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for WR_MULTI.
 *
 * Do not edit - automatically generated.
 */

// WR_MULTI()
#if !PACKER_CODE
# define DECLARED_UNPACK_WR_MULTI
class WR_MULTI
#else//PACKER_CODE
# define DECLARED_PACKER_WR_MULTI
class PACKER_WR_MULTI
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA32 time_hi);
  DATA32 time_hi;
  // MEMBER(DATA32 time_lo);
  DATA32 time_lo;
  // UINT32 hi NOENCODE
  // {
    //  0_31: time;
    // ENCODE(time_hi,(value=time));
  // }
  // UINT32 lo NOENCODE
  // {
    //  0_31: time;
    // ENCODE(time_lo,(value=time));
  // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(WR_MULTI);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for WR_MULTI.
 *
 * Do not edit - automatically generated.
 */

// WR_MULTI()
template<typename __data_src_t>
void WR_MULTI::__unpack(__data_src_t &__buffer)
{
  if (__buffer.is_memberdump())
  {
    printf("          %s%s%s: \n", CT_OUT(BOLD_BLUE),  "WR_MULTI",CT_OUT(NORM));
  }
  // MEMBER(DATA32 time_hi);
  // MEMBER(DATA32 time_lo);
  // UINT32 hi NOENCODE
  // {
    //  0_31: time;
    // ENCODE(time_hi,(value=time));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 time : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 time : 32; // 0..31
#endif
    };
    uint32  u32;
  } hi;
  READ_FROM_BUFFER_FULL(931,uint32 ,hi,hi.u32,121);
  {
    time_hi.value = hi.time;
  }
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: hi ", CT_OUT(BOLD), hi.u32, CT_OUT(NORM));
    printf(".time=%s%8" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  hi.time, CT_OUT(NORM));
    printf("\n");
  }
  // UINT32 lo NOENCODE
  // {
    //  0_31: time;
    // ENCODE(time_lo,(value=time));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 time : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 time : 32; // 0..31
#endif
    };
    uint32  u32;
  } lo;
  READ_FROM_BUFFER_FULL(936,uint32 ,lo,lo.u32,122);
  {
    time_lo.value = lo.time;
  }
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: lo ", CT_OUT(BOLD), lo.u32, CT_OUT(NORM));
    printf(".time=%s%8" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  lo.time, CT_OUT(NORM));
    printf("\n");
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,WR_MULTI::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for WR_MULTI.
 *
 * Do not edit - automatically generated.
 */

// WR_MULTI()
template<typename __data_src_t>
bool WR_MULTI::__match(__data_src_t &__buffer)
{
  // MEMBER(DATA32 time_hi);
  // MEMBER(DATA32 time_lo);
  // UINT32 hi NOENCODE
  // {
    //  0_31: time;
    // ENCODE(time_hi,(value=time));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 time : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 time : 32; // 0..31
#endif
    };
    uint32  u32;
  } hi;
  MATCH_READ_FROM_BUFFER_FULL(931,uint32 ,hi,hi.u32,123);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN(bool,WR_MULTI::__match);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for WR_MULTI.
 *
 * Do not edit - automatically generated.
 */

// WR_MULTI()
template<typename __data_dest_t>
void PACKER_WR_MULTI::__packer(__data_dest_t &__buffer)
{
  // MEMBER(DATA32 time_hi);
  // MEMBER(DATA32 time_lo);
  // UINT32 hi NOENCODE
  // {
    //  0_31: time;
    // ENCODE(time_hi,(value=time));
  // }
  // UINT32 lo NOENCODE
  // {
    //  0_31: time;
    // ENCODE(time_lo,(value=time));
  // }
}
FORCE_IMPL_DATA_SRC_FCN(void,WR_MULTI::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: aida_subev
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for aida_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(aida_subev)
#if !PACKER_CODE
# define DECLARED_UNPACK_aida_subev
class aida_subev
#else//PACKER_CODE
# define DECLARED_PACKER_aida_subev
class PACKER_aida_subev
#endif//PACKER_CODE
 : public unpack_subevent_base
{
public:
  // ts = TIMESTAMP_WHITERABBIT(id=0x700);
  // external data = EXT_AIDA();
  SINGLE(TIMESTAMP_WHITERABBIT,ts);
  SINGLE(EXT_AIDA,data);

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(aida_subev);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for aida_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(aida_subev)
template<typename __data_src_t>
void aida_subev::__unpack(__data_src_t &__buffer)
{
  if (__buffer.is_memberdump())
  {
    printf("          %s%s%s: \n", CT_OUT(BOLD_MAGENTA),  "aida_subev",CT_OUT(NORM));
  }
  // ts = TIMESTAMP_WHITERABBIT(id=0x700);
  UNPACK_DECL(949,TIMESTAMP_WHITERABBIT,ts,/*id*/0x700);
  // external data = EXT_AIDA();
  UNPACK_DECL(950,EXT_AIDA,data);
}
FORCE_IMPL_DATA_SRC_FCN(void,aida_subev::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for aida_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(aida_subev)
// No __match function for subevents.

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for aida_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(aida_subev)
template<typename __data_dest_t>
void PACKER_aida_subev::__packer(__data_dest_t &__buffer)
{
  // ts = TIMESTAMP_WHITERABBIT(id=0x700);
  PACK_DECL(949,TIMESTAMP_WHITERABBIT,ts,/*id*/0x700);
  // external data = EXT_AIDA();
  PACK_DECL(950,EXT_AIDA,data);
}
FORCE_IMPL_DATA_SRC_FCN(void,aida_subev::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: bplast_subev
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for bplast_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(bplast_subev)
#if !PACKER_CODE
# define DECLARED_UNPACK_bplast_subev
class bplast_subev
#else//PACKER_CODE
# define DECLARED_PACKER_bplast_subev
class PACKER_bplast_subev
#endif//PACKER_CODE
 : public unpack_subevent_base
{
public:
  // ts = TIMESTAMP_WHITERABBIT(id=0x500);
  // trigger_window = TAMEX4_HEADER();
  // select several

    // padding = TAMEX4_PADDING();
  SINGLE(TAMEX4_PADDING,padding);
  // select several

    // tamex[0] = TAMEX4_SFP(sfp=0,card=0);
    // tamex[1] = TAMEX4_SFP(sfp=0,card=1);
    // tamex[2] = TAMEX4_SFP(sfp=0,card=2);
    // tamex[3] = TAMEX4_SFP(sfp=0,card=3);
    // tamex[4] = TAMEX4_SFP(sfp=0,card=4);
  SINGLE(TAMEX4_SFP,tamex[5]);
  SINGLE(TIMESTAMP_WHITERABBIT,ts);
  SINGLE(TAMEX4_HEADER,trigger_window);

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(bplast_subev);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for bplast_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(bplast_subev)
template<typename __data_src_t>
void bplast_subev::__unpack(__data_src_t &__buffer)
{
  if (__buffer.is_memberdump())
  {
    printf("          %s%s%s: \n", CT_OUT(BOLD_MAGENTA),  "bplast_subev",CT_OUT(NORM));
  }
  // ts = TIMESTAMP_WHITERABBIT(id=0x500);
  UNPACK_DECL(955,TIMESTAMP_WHITERABBIT,ts,/*id*/0x500);
  // trigger_window = TAMEX4_HEADER();
  UNPACK_DECL(956,TAMEX4_HEADER,trigger_window);
  // select several

    // padding = TAMEX4_PADDING();
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: TAMEX4_PADDING padding: (s32) => (0xfff00000,0xadd00000)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(960,uint32,__match_peek);
    // differ = 00000000 :
    uint32 __match_index = 0;
    static const sint8 __match_index_array[1] = { 1, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 0
    }
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        CHECK_SPURIOUS_MATCH_DECL(959,spurious_match_abort_loop_5,TAMEX4_PADDING);
        UNPACK_DECL(959,TAMEX4_PADDING,padding);
        break;
    }
  }
  spurious_match_abort_loop_5:;
  // select several

    // tamex[0] = TAMEX4_SFP(sfp=0,card=0);
    // tamex[1] = TAMEX4_SFP(sfp=0,card=1);
    // tamex[2] = TAMEX4_SFP(sfp=0,card=2);
    // tamex[3] = TAMEX4_SFP(sfp=0,card=3);
    // tamex[4] = TAMEX4_SFP(sfp=0,card=4);
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: TAMEX4_SFP tamex[0]: (s32) => (0xfffff0ff,0x00000034)
    // optimized match 2: TAMEX4_SFP tamex[1]: (s32) => (0xfffff0ff,0x00010034)
    // optimized match 3: TAMEX4_SFP tamex[2]: (s32) => (0xfffff0ff,0x00020034)
    // optimized match 4: TAMEX4_SFP tamex[3]: (s32) => (0xfffff0ff,0x00030034)
    // optimized match 5: TAMEX4_SFP tamex[4]: (s32) => (0xfffff0ff,0x00040034)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(968,uint32,__match_peek);
    // differ = 00070000 : 16 17 18
    uint32 __match_index = 0 | /* 16,18 */ ((__match_peek >> 16) & 0x00000007);
    static const sint8 __match_index_array[8] = { 1, 2, 3, 4, 5, 0, 0, 0, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 1
    }
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        UNPACK_DECL(963,TAMEX4_SFP,tamex[0],/*sfp*/0,/*card*/0);
        break;
      case 2:
        UNPACK_DECL(964,TAMEX4_SFP,tamex[1],/*sfp*/0,/*card*/1);
        break;
      case 3:
        UNPACK_DECL(965,TAMEX4_SFP,tamex[2],/*sfp*/0,/*card*/2);
        break;
      case 4:
        UNPACK_DECL(966,TAMEX4_SFP,tamex[3],/*sfp*/0,/*card*/3);
        break;
      case 5:
        UNPACK_DECL(967,TAMEX4_SFP,tamex[4],/*sfp*/0,/*card*/4);
        break;
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,bplast_subev::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for bplast_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(bplast_subev)
// No __match function for subevents.

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for bplast_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(bplast_subev)
template<typename __data_dest_t>
void PACKER_bplast_subev::__packer(__data_dest_t &__buffer)
{
  // ts = TIMESTAMP_WHITERABBIT(id=0x500);
  PACK_DECL(955,TIMESTAMP_WHITERABBIT,ts,/*id*/0x500);
  // trigger_window = TAMEX4_HEADER();
  PACK_DECL(956,TAMEX4_HEADER,trigger_window);
  // select several

    // padding = TAMEX4_PADDING();
  {
    PACK_DECL(959,TAMEX4_PADDING,padding);
  }
  // select several

    // tamex[0] = TAMEX4_SFP(sfp=0,card=0);
    // tamex[1] = TAMEX4_SFP(sfp=0,card=1);
    // tamex[2] = TAMEX4_SFP(sfp=0,card=2);
    // tamex[3] = TAMEX4_SFP(sfp=0,card=3);
    // tamex[4] = TAMEX4_SFP(sfp=0,card=4);
  {
    PACK_DECL(963,TAMEX4_SFP,tamex[0],/*sfp*/0,/*card*/0);
    PACK_DECL(964,TAMEX4_SFP,tamex[1],/*sfp*/0,/*card*/1);
    PACK_DECL(965,TAMEX4_SFP,tamex[2],/*sfp*/0,/*card*/2);
    PACK_DECL(966,TAMEX4_SFP,tamex[3],/*sfp*/0,/*card*/3);
    PACK_DECL(967,TAMEX4_SFP,tamex[4],/*sfp*/0,/*card*/4);
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,bplast_subev::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: fatima_tamex_subev
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for fatima_tamex_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(fatima_tamex_subev)
#if !PACKER_CODE
# define DECLARED_UNPACK_fatima_tamex_subev
class fatima_tamex_subev
#else//PACKER_CODE
# define DECLARED_PACKER_fatima_tamex_subev
class PACKER_fatima_tamex_subev
#endif//PACKER_CODE
 : public unpack_subevent_base
{
public:
  // ts = TIMESTAMP_WHITERABBIT_EXTENDED(id=0x1600);
  // trigger_window = TAMEX4_HEADER();
  // select several

    // padding = TAMEX4_PADDING();
  SINGLE(TAMEX4_PADDING,padding);
  // select several

    // tamex[0] = TAMEX4_SFP(sfp=0,card=0);
    // tamex[1] = TAMEX4_SFP(sfp=0,card=1);
  SINGLE(TAMEX4_SFP,tamex[2]);
  SINGLE(TIMESTAMP_WHITERABBIT_EXTENDED,ts);
  SINGLE(TAMEX4_HEADER,trigger_window);

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(fatima_tamex_subev);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for fatima_tamex_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(fatima_tamex_subev)
template<typename __data_src_t>
void fatima_tamex_subev::__unpack(__data_src_t &__buffer)
{
  if (__buffer.is_memberdump())
  {
    printf("          %s%s%s: \n", CT_OUT(BOLD_MAGENTA),  "fatima_tamex_subev",CT_OUT(NORM));
  }
  // ts = TIMESTAMP_WHITERABBIT_EXTENDED(id=0x1600);
  UNPACK_DECL(973,TIMESTAMP_WHITERABBIT_EXTENDED,ts,/*id*/0x1600);
  // trigger_window = TAMEX4_HEADER();
  UNPACK_DECL(974,TAMEX4_HEADER,trigger_window);
  // select several

    // padding = TAMEX4_PADDING();
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: TAMEX4_PADDING padding: (s32) => (0xfff00000,0xadd00000)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(978,uint32,__match_peek);
    // differ = 00000000 :
    uint32 __match_index = 0;
    static const sint8 __match_index_array[1] = { 1, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 0
    }
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        CHECK_SPURIOUS_MATCH_DECL(977,spurious_match_abort_loop_6,TAMEX4_PADDING);
        UNPACK_DECL(977,TAMEX4_PADDING,padding);
        break;
    }
  }
  spurious_match_abort_loop_6:;
  // select several

    // tamex[0] = TAMEX4_SFP(sfp=0,card=0);
    // tamex[1] = TAMEX4_SFP(sfp=0,card=1);
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: TAMEX4_SFP tamex[0]: (s32) => (0xfffff0ff,0x00000034)
    // optimized match 2: TAMEX4_SFP tamex[1]: (s32) => (0xfffff0ff,0x00010034)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(983,uint32,__match_peek);
    // differ = 00010000 : 16
    uint32 __match_index = 0 | /* 16,16 */ ((__match_peek >> 16) & 0x00000001);
    static const sint8 __match_index_array[2] = { 1, 2, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 1
    }
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        UNPACK_DECL(981,TAMEX4_SFP,tamex[0],/*sfp*/0,/*card*/0);
        break;
      case 2:
        UNPACK_DECL(982,TAMEX4_SFP,tamex[1],/*sfp*/0,/*card*/1);
        break;
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,fatima_tamex_subev::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for fatima_tamex_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(fatima_tamex_subev)
// No __match function for subevents.

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for fatima_tamex_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(fatima_tamex_subev)
template<typename __data_dest_t>
void PACKER_fatima_tamex_subev::__packer(__data_dest_t &__buffer)
{
  // ts = TIMESTAMP_WHITERABBIT_EXTENDED(id=0x1600);
  PACK_DECL(973,TIMESTAMP_WHITERABBIT_EXTENDED,ts,/*id*/0x1600);
  // trigger_window = TAMEX4_HEADER();
  PACK_DECL(974,TAMEX4_HEADER,trigger_window);
  // select several

    // padding = TAMEX4_PADDING();
  {
    PACK_DECL(977,TAMEX4_PADDING,padding);
  }
  // select several

    // tamex[0] = TAMEX4_SFP(sfp=0,card=0);
    // tamex[1] = TAMEX4_SFP(sfp=0,card=1);
  {
    PACK_DECL(981,TAMEX4_SFP,tamex[0],/*sfp*/0,/*card*/0);
    PACK_DECL(982,TAMEX4_SFP,tamex[1],/*sfp*/0,/*card*/1);
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,fatima_tamex_subev::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: febex_subev
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for febex_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(febex_subev)
#if !PACKER_CODE
# define DECLARED_UNPACK_febex_subev
class febex_subev
#else//PACKER_CODE
# define DECLARED_PACKER_febex_subev
class PACKER_febex_subev
#endif//PACKER_CODE
 : public unpack_subevent_base
{
public:
  // ts = TIMESTAMP_WHITERABBIT(id=0x400);
  // select several

    // padding = FEBEX_PADDING();
  SINGLE(FEBEX_PADDING,padding);
  // select several

    // data[0] = FEBEX_EVENT(card=0);
    // data[1] = FEBEX_EVENT(card=1);
    // data[2] = FEBEX_EVENT(card=2);
    // data[3] = FEBEX_EVENT(card=3);
  SINGLE(FEBEX_EVENT,data[4]);
  SINGLE(TIMESTAMP_WHITERABBIT,ts);

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(febex_subev);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for febex_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(febex_subev)
template<typename __data_src_t>
void febex_subev::__unpack(__data_src_t &__buffer)
{
  if (__buffer.is_memberdump())
  {
    printf("          %s%s%s: \n", CT_OUT(BOLD_MAGENTA),  "febex_subev",CT_OUT(NORM));
  }
  // ts = TIMESTAMP_WHITERABBIT(id=0x400);
  UNPACK_DECL(988,TIMESTAMP_WHITERABBIT,ts,/*id*/0x400);
  // select several

    // padding = FEBEX_PADDING();
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: FEBEX_PADDING padding: (s32) => (0xfff00000,0xadd00000)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(992,uint32,__match_peek);
    // differ = 00000000 :
    uint32 __match_index = 0;
    static const sint8 __match_index_array[1] = { 1, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 0
    }
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        CHECK_SPURIOUS_MATCH_DECL(991,spurious_match_abort_loop_7,FEBEX_PADDING);
        UNPACK_DECL(991,FEBEX_PADDING,padding);
        break;
    }
  }
  spurious_match_abort_loop_7:;
  // select several

    // data[0] = FEBEX_EVENT(card=0);
    // data[1] = FEBEX_EVENT(card=1);
    // data[2] = FEBEX_EVENT(card=2);
    // data[3] = FEBEX_EVENT(card=3);
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: FEBEX_EVENT data[0]: (s32) => (0xffff00ff,0xff000034)
    // optimized match 2: FEBEX_EVENT data[1]: (s32) => (0xffff00ff,0xff010034)
    // optimized match 3: FEBEX_EVENT data[2]: (s32) => (0xffff00ff,0xff020034)
    // optimized match 4: FEBEX_EVENT data[3]: (s32) => (0xffff00ff,0xff030034)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(999,uint32,__match_peek);
    // differ = 00030000 : 16 17
    uint32 __match_index = 0 | /* 16,17 */ ((__match_peek >> 16) & 0x00000003);
    static const sint8 __match_index_array[4] = { 1, 2, 3, 4, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 1
    }
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        UNPACK_DECL(995,FEBEX_EVENT,data[0],/*card*/0);
        break;
      case 2:
        UNPACK_DECL(996,FEBEX_EVENT,data[1],/*card*/1);
        break;
      case 3:
        UNPACK_DECL(997,FEBEX_EVENT,data[2],/*card*/2);
        break;
      case 4:
        UNPACK_DECL(998,FEBEX_EVENT,data[3],/*card*/3);
        break;
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,febex_subev::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for febex_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(febex_subev)
// No __match function for subevents.

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for febex_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(febex_subev)
template<typename __data_dest_t>
void PACKER_febex_subev::__packer(__data_dest_t &__buffer)
{
  // ts = TIMESTAMP_WHITERABBIT(id=0x400);
  PACK_DECL(988,TIMESTAMP_WHITERABBIT,ts,/*id*/0x400);
  // select several

    // padding = FEBEX_PADDING();
  {
    PACK_DECL(991,FEBEX_PADDING,padding);
  }
  // select several

    // data[0] = FEBEX_EVENT(card=0);
    // data[1] = FEBEX_EVENT(card=1);
    // data[2] = FEBEX_EVENT(card=2);
    // data[3] = FEBEX_EVENT(card=3);
  {
    PACK_DECL(995,FEBEX_EVENT,data[0],/*card*/0);
    PACK_DECL(996,FEBEX_EVENT,data[1],/*card*/1);
    PACK_DECL(997,FEBEX_EVENT,data[2],/*card*/2);
    PACK_DECL(998,FEBEX_EVENT,data[3],/*card*/3);
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,febex_subev::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: frs_main_subev
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for frs_main_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(frs_main_subev)
#if !PACKER_CODE
# define DECLARED_UNPACK_frs_main_subev
class frs_main_subev
#else//PACKER_CODE
# define DECLARED_PACKER_frs_main_subev
class PACKER_frs_main_subev
#endif//PACKER_CODE
 : public unpack_subevent_base
{
public:
  // select several

    // wr = TIMESTAMP_WHITERABBIT(id=0x100);
  SINGLE(TIMESTAMP_WHITERABBIT,wr);
  // select several

    // trig3 = TRIG3EVENT();
  SINGLE(TRIG3EVENT,trig3);
  // select several

    // data = MAIN_CRATE_DATA();
  SINGLE(MAIN_CRATE_DATA,data);

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(frs_main_subev);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for frs_main_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(frs_main_subev)
template<typename __data_src_t>
void frs_main_subev::__unpack(__data_src_t &__buffer)
{
  if (__buffer.is_memberdump())
  {
    printf("          %s%s%s: \n", CT_OUT(BOLD_MAGENTA),  "frs_main_subev",CT_OUT(NORM));
  }
  // select several

    // wr = TIMESTAMP_WHITERABBIT(id=0x100);
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: TIMESTAMP_WHITERABBIT wr: (s32) => (0xfffeffff,0x00000100)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(1007,uint32,__match_peek);
    // differ = 00000000 :
    uint32 __match_index = 0;
    static const sint8 __match_index_array[1] = { 1, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 0
    }
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        CHECK_SPURIOUS_MATCH_DECL(1006,spurious_match_abort_loop_8,TIMESTAMP_WHITERABBIT,/*id*/0x100);
        UNPACK_DECL(1006,TIMESTAMP_WHITERABBIT,wr,/*id*/0x100);
        break;
    }
  }
  spurious_match_abort_loop_8:;
  // select several

    // trig3 = TRIG3EVENT();
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: TRIG3EVENT trig3: (s32) => (0xffffffff,0x20202020)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(1011,uint32,__match_peek);
    // differ = 00000000 :
    uint32 __match_index = 0;
    static const sint8 __match_index_array[1] = { 1, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 0
    }
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        CHECK_SPURIOUS_MATCH_DECL(1010,spurious_match_abort_loop_9,TRIG3EVENT);
        UNPACK_DECL(1010,TRIG3EVENT,trig3);
        break;
    }
  }
  spurious_match_abort_loop_9:;
  // select several

    // data = MAIN_CRATE_DATA();
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: MAIN_CRATE_DATA data: could not get bits
    __buffer.peeking();
    MATCH_DECL(1014,__match_no,1,MAIN_CRATE_DATA,data);
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        UNPACK_DECL(1014,MAIN_CRATE_DATA,data);
        break;
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,frs_main_subev::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for frs_main_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(frs_main_subev)
// No __match function for subevents.

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for frs_main_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(frs_main_subev)
template<typename __data_dest_t>
void PACKER_frs_main_subev::__packer(__data_dest_t &__buffer)
{
  // select several

    // wr = TIMESTAMP_WHITERABBIT(id=0x100);
  {
    PACK_DECL(1006,TIMESTAMP_WHITERABBIT,wr,/*id*/0x100);
  }
  // select several

    // trig3 = TRIG3EVENT();
  {
    PACK_DECL(1010,TRIG3EVENT,trig3);
  }
  // select several

    // data = MAIN_CRATE_DATA();
  {
    PACK_DECL(1014,MAIN_CRATE_DATA,data);
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,frs_main_subev::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: frs_tpc_subev
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for frs_tpc_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(frs_tpc_subev)
#if !PACKER_CODE
# define DECLARED_UNPACK_frs_tpc_subev
class frs_tpc_subev
#else//PACKER_CODE
# define DECLARED_PACKER_frs_tpc_subev
class PACKER_frs_tpc_subev
#endif//PACKER_CODE
 : public unpack_subevent_base
{
public:
  // select several

    // trig3 = TRIG3EVENT();
  SINGLE(TRIG3EVENT,trig3);
  // select several

    // data = TPC_CRATE_DATA();
  SINGLE(TPC_CRATE_DATA,data);

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(frs_tpc_subev);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for frs_tpc_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(frs_tpc_subev)
template<typename __data_src_t>
void frs_tpc_subev::__unpack(__data_src_t &__buffer)
{
  if (__buffer.is_memberdump())
  {
    printf("          %s%s%s: \n", CT_OUT(BOLD_MAGENTA),  "frs_tpc_subev",CT_OUT(NORM));
  }
  // select several

    // trig3 = TRIG3EVENT();
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: TRIG3EVENT trig3: (s32) => (0xffffffff,0x20202020)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(1023,uint32,__match_peek);
    // differ = 00000000 :
    uint32 __match_index = 0;
    static const sint8 __match_index_array[1] = { 1, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 0
    }
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        CHECK_SPURIOUS_MATCH_DECL(1022,spurious_match_abort_loop_10,TRIG3EVENT);
        UNPACK_DECL(1022,TRIG3EVENT,trig3);
        break;
    }
  }
  spurious_match_abort_loop_10:;
  // select several

    // data = TPC_CRATE_DATA();
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: TPC_CRATE_DATA data: could not get bits
    __buffer.peeking();
    MATCH_DECL(1026,__match_no,1,TPC_CRATE_DATA,data);
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        UNPACK_DECL(1026,TPC_CRATE_DATA,data);
        break;
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,frs_tpc_subev::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for frs_tpc_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(frs_tpc_subev)
// No __match function for subevents.

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for frs_tpc_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(frs_tpc_subev)
template<typename __data_dest_t>
void PACKER_frs_tpc_subev::__packer(__data_dest_t &__buffer)
{
  // select several

    // trig3 = TRIG3EVENT();
  {
    PACK_DECL(1022,TRIG3EVENT,trig3);
  }
  // select several

    // data = TPC_CRATE_DATA();
  {
    PACK_DECL(1026,TPC_CRATE_DATA,data);
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,frs_tpc_subev::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: frs_user_subev
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for frs_user_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(frs_user_subev)
#if !PACKER_CODE
# define DECLARED_UNPACK_frs_user_subev
class frs_user_subev
#else//PACKER_CODE
# define DECLARED_PACKER_frs_user_subev
class PACKER_frs_user_subev
#endif//PACKER_CODE
 : public unpack_subevent_base
{
public:
  // select several

    // trig3 = TRIG3EVENT();
  SINGLE(TRIG3EVENT,trig3);
  // select several

    // data = USER_CRATE_DATA();
  SINGLE(USER_CRATE_DATA,data);

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(frs_user_subev);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for frs_user_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(frs_user_subev)
template<typename __data_src_t>
void frs_user_subev::__unpack(__data_src_t &__buffer)
{
  if (__buffer.is_memberdump())
  {
    printf("          %s%s%s: \n", CT_OUT(BOLD_MAGENTA),  "frs_user_subev",CT_OUT(NORM));
  }
  // select several

    // trig3 = TRIG3EVENT();
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: TRIG3EVENT trig3: (s32) => (0xffffffff,0x20202020)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(1035,uint32,__match_peek);
    // differ = 00000000 :
    uint32 __match_index = 0;
    static const sint8 __match_index_array[1] = { 1, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 0
    }
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        CHECK_SPURIOUS_MATCH_DECL(1034,spurious_match_abort_loop_11,TRIG3EVENT);
        UNPACK_DECL(1034,TRIG3EVENT,trig3);
        break;
    }
  }
  spurious_match_abort_loop_11:;
  // select several

    // data = USER_CRATE_DATA();
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: USER_CRATE_DATA data: could not get bits
    __buffer.peeking();
    MATCH_DECL(1038,__match_no,1,USER_CRATE_DATA,data);
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        UNPACK_DECL(1038,USER_CRATE_DATA,data);
        break;
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,frs_user_subev::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for frs_user_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(frs_user_subev)
// No __match function for subevents.

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for frs_user_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(frs_user_subev)
template<typename __data_dest_t>
void PACKER_frs_user_subev::__packer(__data_dest_t &__buffer)
{
  // select several

    // trig3 = TRIG3EVENT();
  {
    PACK_DECL(1034,TRIG3EVENT,trig3);
  }
  // select several

    // data = USER_CRATE_DATA();
  {
    PACK_DECL(1038,USER_CRATE_DATA,data);
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,frs_user_subev::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: frs_vftx_subev
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for frs_vftx_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(frs_vftx_subev)
#if !PACKER_CODE
# define DECLARED_UNPACK_frs_vftx_subev
class frs_vftx_subev
#else//PACKER_CODE
# define DECLARED_PACKER_frs_vftx_subev
class PACKER_frs_vftx_subev
#endif//PACKER_CODE
 : public unpack_subevent_base
{
public:
  // select several

    // trig3 = TRIG3EVENT();
  SINGLE(TRIG3EVENT,trig3);
  // select several

    // data = VFTX_CRATE_DATA();
  SINGLE(VFTX_CRATE_DATA,data);

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(frs_vftx_subev);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for frs_vftx_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(frs_vftx_subev)
template<typename __data_src_t>
void frs_vftx_subev::__unpack(__data_src_t &__buffer)
{
  if (__buffer.is_memberdump())
  {
    printf("          %s%s%s: \n", CT_OUT(BOLD_MAGENTA),  "frs_vftx_subev",CT_OUT(NORM));
  }
  // select several

    // trig3 = TRIG3EVENT();
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: TRIG3EVENT trig3: (s32) => (0xffffffff,0x20202020)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(1047,uint32,__match_peek);
    // differ = 00000000 :
    uint32 __match_index = 0;
    static const sint8 __match_index_array[1] = { 1, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 0
    }
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        CHECK_SPURIOUS_MATCH_DECL(1046,spurious_match_abort_loop_12,TRIG3EVENT);
        UNPACK_DECL(1046,TRIG3EVENT,trig3);
        break;
    }
  }
  spurious_match_abort_loop_12:;
  // select several

    // data = VFTX_CRATE_DATA();
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: VFTX_CRATE_DATA data: could not get bits
    __buffer.peeking();
    MATCH_DECL(1050,__match_no,1,VFTX_CRATE_DATA,data);
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        UNPACK_DECL(1050,VFTX_CRATE_DATA,data);
        break;
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,frs_vftx_subev::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for frs_vftx_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(frs_vftx_subev)
// No __match function for subevents.

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for frs_vftx_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(frs_vftx_subev)
template<typename __data_dest_t>
void PACKER_frs_vftx_subev::__packer(__data_dest_t &__buffer)
{
  // select several

    // trig3 = TRIG3EVENT();
  {
    PACK_DECL(1046,TRIG3EVENT,trig3);
  }
  // select several

    // data = VFTX_CRATE_DATA();
  {
    PACK_DECL(1050,VFTX_CRATE_DATA,data);
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,frs_vftx_subev::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for EVENT
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for EVENT.
 *
 * Do not edit - automatically generated.
 */

// EVENT
class unpack_event : public unpack_event_base
{
public:
  // revisit aida = aida_subev(type=10,subtype=1,procid=90,control=37);
  // bplast = bplast_subev(type=10,subtype=1,procid=80,control=20,subcrate=0);
  // frsmain = frs_main_subev(procid=10);
  // frstpc = frs_tpc_subev(procid=20);
  // frsuser = frs_user_subev(procid=30);
  // frsvftx = frs_vftx_subev(procid=40);
  // ignore_unknown_subevent;
SINGLE(aida_subev,aida);
SINGLE(bplast_subev,bplast);
SINGLE(frs_main_subev,frsmain);
SINGLE(frs_tpc_subev,frstpc);
SINGLE(frs_user_subev,frsuser);
SINGLE(frs_vftx_subev,frsvftx);
public:
#ifndef __PSDC__
  bitsone<7> __visited;
  void __clear_visited() { __visited.clear(); }
  bool ignore_unknown_subevent() { return true; }
#endif//!__PSDC__

public:
#ifndef __PSDC__
template<typename __data_src_t>
  int __unpack_subevent(subevent_header *__header,__data_src_t &__buffer);
  int __revoke_subevent(subevent_header *__header);
  // void __clean_event();

  STRUCT_FCNS_DECL(unpack_event);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for EVENT.
 *
 * Do not edit - automatically generated.
 */

// EVENT
template<typename __data_src_t>
int unpack_event::__unpack_subevent(subevent_header *__header,__data_src_t &__buffer)
  // revisit aida = aida_subev(type=10,subtype=1,procid=90,control=37);
  // bplast = bplast_subev(type=10,subtype=1,procid=80,control=20,subcrate=0);
  // frsmain = frs_main_subev(procid=10);
  // frstpc = frs_tpc_subev(procid=20);
  // frsuser = frs_user_subev(procid=30);
  // frsvftx = frs_vftx_subev(procid=40);
  // ignore_unknown_subevent;
{
  int __match_no = 0;
  MATCH_SUBEVENT_DECL(1060,__match_no,1,((VES10_1_type==10)&&(VES10_1_subtype==1)&&(VES10_1_control==37)&&(VES10_1_procid==90)),aida);
  MATCH_SUBEVENT_DECL(1061,__match_no,2,((VES10_1_type==10)&&(VES10_1_subtype==1)&&(VES10_1_control==20)&&(VES10_1_subcrate==0)&&(VES10_1_procid==80)),bplast);
  MATCH_SUBEVENT_DECL(1062,__match_no,3,((VES10_1_procid==10)),frsmain);
  MATCH_SUBEVENT_DECL(1063,__match_no,4,((VES10_1_procid==20)),frstpc);
  MATCH_SUBEVENT_DECL(1064,__match_no,5,((VES10_1_procid==30)),frsuser);
  MATCH_SUBEVENT_DECL(1065,__match_no,6,((VES10_1_procid==40)),frsvftx);
  if (!__match_no) return 0;
  switch (__match_no)
  {
    case 1:
      UNPACK_SUBEVENT_DECL(1060,0,aida_subev,aida);
      break;
    case 2:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(1061,bplast_subev,bplast,0);
      UNPACK_SUBEVENT_DECL(1061,0,bplast_subev,bplast);
      break;
    case 3:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(1062,frs_main_subev,frsmain,1);
      UNPACK_SUBEVENT_DECL(1062,0,frs_main_subev,frsmain);
      break;
    case 4:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(1063,frs_tpc_subev,frstpc,2);
      UNPACK_SUBEVENT_DECL(1063,0,frs_tpc_subev,frstpc);
      break;
    case 5:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(1064,frs_user_subev,frsuser,3);
      UNPACK_SUBEVENT_DECL(1064,0,frs_user_subev,frsuser);
      break;
    case 6:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(1065,frs_vftx_subev,frsvftx,4);
      UNPACK_SUBEVENT_DECL(1065,0,frs_vftx_subev,frsvftx);
      break;
  }
  return 0;
}
FORCE_IMPL_DATA_SRC_FCN_HDR(int,unpack_event::__unpack_subevent);

/** END_UNPACKER ******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for EVENT.
 *
 * Do not edit - automatically generated.
 */

// EVENT
  // revisit aida = aida_subev(type=10,subtype=1,procid=90,control=37);
  // bplast = bplast_subev(type=10,subtype=1,procid=80,control=20,subcrate=0);
  // frsmain = frs_main_subev(procid=10);
  // frstpc = frs_tpc_subev(procid=20);
  // frsuser = frs_user_subev(procid=30);
  // frsvftx = frs_vftx_subev(procid=40);
  // ignore_unknown_subevent;
{
}

/** END_PACKER ********************************************************/


/** BEGIN_REVOKE *******************************************************
 *
 * Event revoker for EVENT.
 *
 * Do not edit - automatically generated.
 */

// EVENT
int unpack_event::__revoke_subevent(subevent_header *__header)
  // revisit aida = aida_subev(type=10,subtype=1,procid=90,control=37);
  // bplast = bplast_subev(type=10,subtype=1,procid=80,control=20,subcrate=0);
  // frsmain = frs_main_subev(procid=10);
  // frstpc = frs_tpc_subev(procid=20);
  // frsuser = frs_user_subev(procid=30);
  // frsvftx = frs_vftx_subev(procid=40);
  // ignore_unknown_subevent;
{
  int __match_no = 0;
  MATCH_SUBEVENT_DECL(1060,__match_no,1,((VES10_1_type==10)&&(VES10_1_subtype==1)&&(VES10_1_control==37)&&(VES10_1_procid==90)),aida);
  MATCH_SUBEVENT_DECL(1061,__match_no,2,((VES10_1_type==10)&&(VES10_1_subtype==1)&&(VES10_1_control==20)&&(VES10_1_subcrate==0)&&(VES10_1_procid==80)),bplast);
  MATCH_SUBEVENT_DECL(1062,__match_no,3,((VES10_1_procid==10)),frsmain);
  MATCH_SUBEVENT_DECL(1063,__match_no,4,((VES10_1_procid==20)),frstpc);
  MATCH_SUBEVENT_DECL(1064,__match_no,5,((VES10_1_procid==30)),frsuser);
  MATCH_SUBEVENT_DECL(1065,__match_no,6,((VES10_1_procid==40)),frsvftx);
  if (!__match_no) return 0;
  switch (__match_no)
  {
    case 1:
      REVOKE_SUBEVENT_DECL(1060,0,aida_subev,aida);
      break;
    case 2:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(1061,bplast_subev,bplast,0);
      REVOKE_SUBEVENT_DECL(1061,0,bplast_subev,bplast);
      break;
    case 3:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(1062,frs_main_subev,frsmain,1);
      REVOKE_SUBEVENT_DECL(1062,0,frs_main_subev,frsmain);
      break;
    case 4:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(1063,frs_tpc_subev,frstpc,2);
      REVOKE_SUBEVENT_DECL(1063,0,frs_tpc_subev,frstpc);
      break;
    case 5:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(1064,frs_user_subev,frsuser,3);
      REVOKE_SUBEVENT_DECL(1064,0,frs_user_subev,frsuser);
      break;
    case 6:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(1065,frs_vftx_subev,frsvftx,4);
      REVOKE_SUBEVENT_DECL(1065,0,frs_vftx_subev,frsvftx);
      break;
  }
  return 0;
}

/** END_REVOKE ********************************************************/


/** BEGIN_SUBEVENT_NAMES ***********************************************
 *
 * Mappings of names for [incl|excl] name lookup.
 *
 * Do not edit - automatically generated.
 */

{ "aida", "type=10:subtype=1:procid=90:control=37" },
{ "bplast", "type=10:subtype=1:procid=80:control=20:subcrate=0" },
{ "frsmain", "procid=10" },
{ "frstpc", "procid=20" },
{ "frsuser", "procid=30" },
{ "frsvftx", "procid=40" },

/** END_SUBEVENT_NAMES ************************************************/

//
// Generating code for EVENT
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for EVENT.
 *
 * Do not edit - automatically generated.
 */

// STICKY_EVENT
class unpack_sticky_event : public unpack_sticky_event_base
{
public:
public:
#ifndef __PSDC__
  void __clear_visited() { }
  bool ignore_unknown_subevent() { return false; }
#endif//!__PSDC__

public:
#ifndef __PSDC__
template<typename __data_src_t>
  int __unpack_subevent(subevent_header *__header,__data_src_t &__buffer);
  int __revoke_subevent(subevent_header *__header);
  // void __clean_event();

  STRUCT_FCNS_DECL(unpack_sticky_event);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for EVENT.
 *
 * Do not edit - automatically generated.
 */

// STICKY_EVENT
template<typename __data_src_t>
int unpack_sticky_event::__unpack_subevent(subevent_header *__header,__data_src_t &__buffer)
{
  int __match_no = 0;
  if (!__match_no) return 0;
  switch (__match_no)
  {
  }
  return 0;
}
FORCE_IMPL_DATA_SRC_FCN_HDR(int,unpack_sticky_event::__unpack_subevent);

/** END_UNPACKER ******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for EVENT.
 *
 * Do not edit - automatically generated.
 */

// STICKY_EVENT
{
}

/** END_PACKER ********************************************************/


/** BEGIN_REVOKE *******************************************************
 *
 * Event revoker for EVENT.
 *
 * Do not edit - automatically generated.
 */

// STICKY_EVENT
int unpack_sticky_event::__revoke_subevent(subevent_header *__header)
{
  int __match_no = 0;
  if (!__match_no) return 0;
  switch (__match_no)
  {
  }
  return 0;
}

/** END_REVOKE ********************************************************/


/** BEGIN_SUBEVENT_NAMES ***********************************************
 *
 * Mappings of names for [incl|excl] name lookup.
 *
 * Do not edit - automatically generated.
 */


/** END_SUBEVENT_NAMES ************************************************/


/** BEGIN_UNPACKER_DEFINES *********************************************
 *
 * Control
 *
 * Do not edit - automatically generated.
 */

#define STICKY_EVENT_IS_NONTRIVIAL  0


/** END_UNPACKER_DEFINES **********************************************/

/**********************************************************/
/**********************************************************
 * Generating event structure...
 */


/** BEGIN_EVENT_RAW_STRUCTURE ******************************************
 *
 * Event data structure.
 *
 * Do not edit - automatically generated.
 */

class raw_event : public raw_event_base
{
public:

public:
#ifndef __PSDC__
  STRUCT_FCNS_DECL(raw_event);
#endif//!__PSDC__
} ;

/** END_EVENT_RAW_STRUCTURE *******************************************/


/** BEGIN_EVENT_CAL_STRUCTURE ******************************************
 *
 * Event data structure.
 *
 * Do not edit - automatically generated.
 */

class cal_event : public cal_event_base
{
public:

public:
#ifndef __PSDC__
  STRUCT_FCNS_DECL(cal_event);
#endif//!__PSDC__
} ;

/** END_EVENT_CAL_STRUCTURE *******************************************/


/** BEGIN_EVENT_RAW_STRUCTURE ******************************************
 *
 * Event data structure.
 *
 * Do not edit - automatically generated.
 */

class raw_sticky : public raw_sticky_base
{
public:

public:
#ifndef __PSDC__
  STRUCT_FCNS_DECL(raw_sticky);
#endif//!__PSDC__
} ;

/** END_EVENT_RAW_STRUCTURE *******************************************/


/** BEGIN_EVENT_DATA_MAPPING *******************************************
 *
 * Event data mapping.
 *
 * Do not edit - automatically generated.
 */

// The order in this file does not matter.
// This information parsed once and not treated eventwise,
// it is used to initialize a structure.


/** END_EVENT_DATA_MAPPING ********************************************/


/** BEGIN_EVENT_DATA_MAPPING *******************************************
 *
 * Event data mapping.
 *
 * Do not edit - automatically generated.
 */

// The order in this file does not matter.
// This information parsed once and not treated eventwise,
// it is used to initialize a structure.


/** END_EVENT_DATA_MAPPING ********************************************/

/**********************************************************/

/** BEGIN_LOCATIONS ****************************************************
 *
 * File and line locations from the parsed specification files.
 *
 * Do not edit - automatically generated.
 */

// It's left to the compiler to only store one copy of each
// unique string.

location spec_locations[] =
{ 
  { 2, 1, "gen_NovTest/reparse.uce" },
  { 3, 1, "<built-in>" },
  { 4, 1, "<command-line>" },
  { 5, 1, "/usr/include/stdc-predef.h" },
  { 6, 1, "<command-line>" },
  { 7, 1, "gen_NovTest/reparse.uce" },
  { 8, 12, "gen_NovTest/reparse.uce" },
};

/** END_LOCATIONS *****************************************************/


/** BEGIN_ACCOUNT_IDS **************************************************
 *
 * Structure and identifier for raw data items.
 *
 * Do not edit - automatically generated.
 */

account_id _account_ids[] =
{ 
  { 0, "BARRIER", "barrier" },
  { 1, "BARRIER", "barrier" },
  { 2, "FEBEX_EVENT", "sumchannel" },
  { 3, "FEBEX_EVENT", "channel_size" },
  { 4, "FEBEX_EVENT", "event_timestamp_hi" },
  { 5, "FEBEX_EVENT", "event_timestamp_lo" },
  { 6, "FEBEX_EVENT", "hp" },
  { 7, "FEBEX_EVENT", "deadbeef" },
  { 8, "FEBEX_EVENT", "channelids" },
  { 9, "FEBEX_EVENT", "channel_ts" },
  { 10, "FEBEX_EVENT", "chan_enrgy" },
  { 11, "FEBEX_EVENT", "future_use" },
  { 12, "FEBEX_EVENT", "sumchannel" },
  { 13, "FEBEX_EVENT_TRACES", "sumchannel" },
  { 14, "FEBEX_EVENT_TRACES", "channel_size" },
  { 15, "FEBEX_EVENT_TRACES", "event_timestamp_hi" },
  { 16, "FEBEX_EVENT_TRACES", "event_timestamp_lo" },
  { 17, "FEBEX_EVENT_TRACES", "hp" },
  { 18, "FEBEX_EVENT_TRACES", "deadbeef" },
  { 19, "FEBEX_EVENT_TRACES", "channelids" },
  { 20, "FEBEX_EVENT_TRACES", "channel_ts" },
  { 21, "FEBEX_EVENT_TRACES", "chan_enrgy" },
  { 22, "FEBEX_EVENT_TRACES", "future_use" },
  { 23, "FEBEX_EVENT_TRACES", "header" },
  { 24, "FEBEX_EVENT_TRACES", "tracesize" },
  { 25, "FEBEX_EVENT_TRACES", "tracehead" },
  { 26, "FEBEX_EVENT_TRACES", "channel_trace" },
  { 27, "FEBEX_EVENT_TRACES", "trace_trailer" },
  { 28, "FEBEX_EVENT_TRACES", "header" },
  { 29, "FEBEX_EVENT_TRACES", "tracesize" },
  { 30, "FEBEX_EVENT_TRACES", "tracehead" },
  { 31, "FEBEX_EVENT_TRACES", "trace_trailer" },
  { 32, "FEBEX_EVENT_TRACES", "sumchannel" },
  { 33, "FEBEX_PADDING", "pads_data" },
  { 34, "FEBEX_PADDING", "pads_data" },
  { 35, "VME_CAEN_V830_FRS", "v830_header" },
  { 36, "VME_CAEN_V830_FRS", "data_word" },
  { 37, "VME_CAEN_V830_FRS", "v830_header" },
  { 38, "ZERO_FILLER", "filler" },
  { 39, "ZERO_FILLER", "filler" },
  { 40, "VME_CAEN_V792_FRS", "v792_header" },
  { 41, "VME_CAEN_V792_FRS", "adc_data" },
  { 42, "VME_CAEN_V792_FRS", "eob" },
  { 43, "VME_CAEN_V792_FRS", "eob2" },
  { 44, "VME_CAEN_V792_FRS", "v792_header" },
  { 45, "TDC_HEADER", "tdc_header" },
  { 46, "TDC_HEADER", "tdc_header" },
  { 47, "TDC_DATA_V1290", "tdc_data" },
  { 48, "TDC_DATA_V1290", "tdc_data" },
  { 49, "TDC_ERROR", "tdc_err" },
  { 50, "TDC_ERROR", "tdc_err" },
  { 51, "TDC_TRAILER", "tdc_trailer" },
  { 52, "TDC_TRAILER", "tdc_trailer" },
  { 53, "VME_CAEN_V1290_FRS", "header" },
  { 54, "VME_CAEN_V1290_FRS", "ext_time_tag" },
  { 55, "VME_CAEN_V1290_FRS", "trailer" },
  { 56, "VME_CAEN_V1290_FRS", "eob" },
  { 57, "VME_CAEN_V1290_FRS", "header" },
  { 58, "MESYTEC_MQDC32_FRS", "header" },
  { 59, "MESYTEC_MQDC32_FRS", "ch_data" },
  { 60, "MESYTEC_MQDC32_FRS", "zero" },
  { 61, "MESYTEC_MQDC32_FRS", "end_of_event" },
  { 62, "MESYTEC_MQDC32_FRS", "header" },
  { 63, "MESYTEC_MTDC32_FRS", "header" },
  { 64, "MESYTEC_MTDC32_FRS", "zero" },
  { 65, "MESYTEC_MTDC32_FRS", "ch_data" },
  { 66, "MESYTEC_MTDC32_FRS", "end_of_event" },
  { 67, "MESYTEC_MTDC32_FRS", "header" },
  { 68, "SIS_3820_FRS", "custom_header" },
  { 69, "SIS_3820_FRS", "event" },
  { 70, "SIS_3820_FRS", "event" },
  { 71, "SIS_3820_FRS", "custom_header" },
  { 72, "TAMEX4_EPOCH_DATA", "data" },
  { 73, "TAMEX4_EPOCH_DATA", "data" },
  { 74, "TAMEX4_HEADER", "trigger_window" },
  { 75, "TAMEX4_HEADER", "trigger_window" },
  { 76, "TAMEX4_PADDING", "padding" },
  { 77, "TAMEX4_PADDING", "padding" },
  { 78, "TAMEX4_TIME_DATA", "data" },
  { 79, "TAMEX4_TIME_DATA", "data" },
  { 80, "TAMEX4_SFP", "indicator" },
  { 81, "TAMEX4_SFP", "data_size" },
  { 82, "TAMEX4_SFP", "tdc_header" },
  { 83, "TAMEX4_SFP", "error_bits" },
  { 84, "TAMEX4_SFP", "trailer" },
  { 85, "TAMEX4_SFP", "indicator" },
  { 86, "TDC_DATA_V1190", "tdc_data" },
  { 87, "TDC_DATA_V1190", "tdc_data" },
  { 88, "TIMESTAMP_WHITERABBIT", "header" },
  { 89, "TIMESTAMP_WHITERABBIT", "d1" },
  { 90, "TIMESTAMP_WHITERABBIT", "d2" },
  { 91, "TIMESTAMP_WHITERABBIT", "d3" },
  { 92, "TIMESTAMP_WHITERABBIT", "d4" },
  { 93, "TIMESTAMP_WHITERABBIT", "header" },
  { 94, "TIMESTAMP_WHITERABBIT_EXTENDED", "header" },
  { 95, "TIMESTAMP_WHITERABBIT_EXTENDED", "d1" },
  { 96, "TIMESTAMP_WHITERABBIT_EXTENDED", "d2" },
  { 97, "TIMESTAMP_WHITERABBIT_EXTENDED", "d3" },
  { 98, "TIMESTAMP_WHITERABBIT_EXTENDED", "d4" },
  { 99, "TIMESTAMP_WHITERABBIT_EXTENDED", "header" },
  { 100, "VME_CAEN_V7X5_FRS", "header" },
  { 101, "VME_CAEN_V7X5_FRS", "ch_data" },
  { 102, "VME_CAEN_V7X5_FRS", "eob" },
  { 103, "VME_CAEN_V7X5_FRS", "eob2" },
  { 104, "VME_CAEN_V7X5_FRS", "header" },
  { 105, "VME_CAEN_V1190_FRS", "header" },
  { 106, "VME_CAEN_V1190_FRS", "second1" },
  { 107, "VME_CAEN_V1190_FRS", "real_header" },
  { 108, "VME_CAEN_V1190_FRS", "ext_time_tag" },
  { 109, "VME_CAEN_V1190_FRS", "trailer" },
  { 110, "VME_CAEN_V1190_FRS", "eob" },
  { 111, "VME_CAEN_V1190_FRS", "header" },
  { 112, "TRIG3EVENT", "trig3" },
  { 113, "TRIG3EVENT", "trig3" },
  { 114, "VFTX2", "custom_header" },
  { 115, "VFTX2", "trigger_window" },
  { 116, "VFTX2", "status_register" },
  { 117, "VFTX2", "mvlc_header" },
  { 118, "VFTX2", "skip_event_header" },
  { 119, "VFTX2", "event" },
  { 120, "VFTX2", "custom_header" },
  { 121, "WR_MULTI", "hi" },
  { 122, "WR_MULTI", "lo" },
  { 123, "WR_MULTI", "hi" },
};

#define NUM_ACCOUNT_IDS  124

/** END_ACCOUNT_IDS ***************************************************/

